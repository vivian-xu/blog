{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/job.png","path":"images/job.png","modified":0,"renderable":0},{"_id":"source/images/sup-polo.png","path":"images/sup-polo.png","modified":0,"renderable":0},{"_id":"source/images/sup-shop.jpeg","path":"images/sup-shop.jpeg","modified":0,"renderable":0},{"_id":"source/images/guoguo_sample.png","path":"images/guoguo_sample.png","modified":0,"renderable":0},{"_id":"source/images/guoguo.png","path":"images/guoguo.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"310fc37341c13586d09c4d1d82ca51ed082d6481","modified":1480843274000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1480701901000},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1480919469000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1480701901000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1480701901000},{"_id":"themes/next/.DS_Store","hash":"153cd9e7520c0ef5312901557b4353b0f9ceb534","modified":1480905451000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1480701901000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1480701901000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1480701901000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1480701901000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1480701901000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1480701901000},{"_id":"themes/next/_config.yml","hash":"8baa1b6e38a1d769b7c13267bb27f8fc8121a144","modified":1480906287000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1480701901000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1480701901000},{"_id":"source/_drafts/this","hash":"65ad73f17f7f8741ec6f372ae44dbd9263fad64f","modified":1480940418000},{"_id":"source/_drafts/Cookie.md","hash":"bffb6b20a08793f2fdab2c3948b0a927604f9ae7","modified":1480763169000},{"_id":"source/_posts/React Review .md","hash":"17bc74afccd42f1feb8a7549c6cd32ab7b318ab9","modified":1481270796000},{"_id":"source/_posts/Web-storage.md","hash":"41c1f80b9ab07f73cd11cef60b3bea9a5840968f","modified":1480918822000},{"_id":"source/_posts/ci.md","hash":"2f4826ec686930894816b01df9fe307da94d9163","modified":1481271663000},{"_id":"source/_posts/es6-arrowfunction.mdown","hash":"241e9017f4feaeef07e41b5e54c30cb1c66bd535","modified":1480918769000},{"_id":"source/_posts/closure.md","hash":"f8d0433525920966551546babf534ec07ef94c3f","modified":1481352591000},{"_id":"source/_posts/execution context.md","hash":"ded4dd7243506b465d104021754393aab5ee3730","modified":1480919625000},{"_id":"source/_posts/start.md","hash":"3e9ab63f9822e8751418f12ec3ee4ebba981987c","modified":1480914115000},{"_id":"source/_posts/nodelist.md","hash":"cba58369f9136a35f1df75db7b70fb67a463cb95","modified":1480918704000},{"_id":"source/about/index.md","hash":"c155153d10820202fadff5d2ca53b398bf72d6bf","modified":1481531169000},{"_id":"source/my-projects/index.md","hash":"eb7dd5046529b40d5007e453e3ccc9fe21afe6bc","modified":1482421810000},{"_id":"source/_posts/querySelector.md","hash":"04259a9276e929bee1a6e1cbf8c29844d8acca58","modified":1480918512000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1480701901000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1480701901000},{"_id":"source/_posts/start with hexo.md","hash":"78bfb68864e790aac387a16f51202747f8d889ac","modified":1480918751000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1480701765000},{"_id":"themes/next/.git/index","hash":"2a31fd6059084c931f6c088781fb1e9736292a41","modified":1480906637000},{"_id":"themes/next/.git/packed-refs","hash":"80908fda4226cdf164a41c85c7fbea49cb816125","modified":1480701901000},{"_id":"source/tags/index.md","hash":"cb5d64d2dc5ccf3eb6f985f036e3b74eaf70cf31","modified":1480772082000},{"_id":"source/categories/index.md","hash":"9bdcb918a64df8c88900a5b9ddb69e1f8bd70db3","modified":1481182984000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1480701901000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1480701901000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1480701901000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1480701901000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1480701901000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1480701901000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1480701901000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1480701901000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1480701901000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1480701901000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1480701901000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1480701901000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1480701901000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1480701901000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1480701901000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1480906636000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1480701901000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1480701901000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1480701901000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1480701901000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1480701901000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1480701901000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1480701901000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1480701901000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1480701901000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1480701901000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1480701901000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1480701765000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1480701765000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1480701765000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1480701765000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1480701765000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1480701765000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1480701765000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1480701765000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1480701765000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1480701765000},{"_id":"themes/next/.git/logs/HEAD","hash":"c780f838af517e3c25b9828d8eab4bf986d59fc6","modified":1480701901000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1480701901000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1480701901000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f12f108c1f8e91cc55d49805d42c1fd96cdf51a6","modified":1480701901000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1480701901000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1480701901000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a3ef28678467c45ee9416b41b943252e8036285","modified":1480701901000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b21143ca616463dc4b2dd337baf3f4f01e2735f4","modified":1480848223000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1480701901000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1480701901000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1480701901000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1480701901000},{"_id":"themes/next/layout/_partials/header.swig","hash":"f3627f51810bc906e4020a3fef61bc3629b63581","modified":1480701901000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1480701901000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1480701901000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1480701901000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1480701901000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1480701901000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1480701901000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1480701901000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1480701901000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1480701901000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1480701901000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1480701901000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1480701901000},{"_id":"themes/next/source/css/main.styl","hash":"4b0681764810933318a7468211630b8fd83fb508","modified":1481186365000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1480701901000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"9a352f855a0545c61ed190e74da4806d895b1767","modified":1480905239000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1480701901000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1480701901000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1480701901000},{"_id":"themes/next/source/images/avatar.jpg","hash":"61c4e1b6b07b4ddec08ecb2b10df87fb1eb7edd5","modified":1480905328000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1480701901000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1480701901000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480701901000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1480701901000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480701901000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1480701901000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1480701901000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1480701901000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480701901000},{"_id":"themes/next/.git/refs/heads/master","hash":"93d0f27eb58dcc033accd3711a6d88c269c8e1e8","modified":1480701901000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1480701901000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1480701901000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1480701901000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1480701901000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1480701901000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1480701901000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1480701901000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1480701901000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1480701901000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1480701901000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"82a2ac14d4200480a36bf10abcc3cc554ad744d6","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1480701901000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1480701901000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1480701901000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1480701901000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1480701901000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"21472a2d16693f44960c335dd29997b167cd858a","modified":1480906652000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1480701901000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1480701901000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c5b28519b446c2af1e8754a6ae4d766823e6b348","modified":1480701901000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1480701901000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1480701901000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1480701901000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1480701901000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1480701901000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1480701901000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1480701901000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1480701901000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1480701901000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1480701901000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1480701901000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1480701901000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c780f838af517e3c25b9828d8eab4bf986d59fc6","modified":1480701901000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1480701901000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1480701901000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1480701901000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1480701901000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1480701901000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1480701901000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1480701901000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1480701901000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1480701901000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1480701901000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1480701901000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1480701901000},{"_id":"themes/next/.git/objects/pack/pack-2beef8093c52583b95a9e8b3c6565c4a4b99a024.idx","hash":"18f99930748195202f356b888450ef110b1a6dbb","modified":1480701900000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1480701901000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1480701901000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c780f838af517e3c25b9828d8eab4bf986d59fc6","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"3d311c666d19f3f06d8c8d28657ce46c2651c952","modified":1480844359000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"99b7c7c4630130c3a097f2dcf82421c4d05aeeb4","modified":1480856806000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1480701901000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5433b6bc9d8f0c4685e760b326445ac51245b0a8","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1480701901000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1480701901000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1480701901000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1480701901000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1480701901000},{"_id":"themes/next/.git/objects/pack/pack-2beef8093c52583b95a9e8b3c6565c4a4b99a024.pack","hash":"1406aa53b4b2c76a365056279cf4090c86170940","modified":1480701900000},{"_id":"source/images/sup-polo.png","hash":"d143a0db397fc1f027af7ca1f5b148918d8e4937","modified":1481183320000},{"_id":"source/images/job.png","hash":"95d1d13683ef5178b318586164bbacfa729d498a","modified":1481183289000},{"_id":"themes/next/source/css/_mystyle/my_projects.styl","hash":"0cbf3d85bc81a9d956e065f67d1e1609e586334d","modified":1481217607000},{"_id":"source/_posts/sup-shop.jpeg","hash":"c17f82661c0448f716eabfa4ecb13e214e1d1f67","modified":1481214862000},{"_id":"source/_posts/router","hash":"f43ae8853a78091f0f0079ccceb56490416f1cee","modified":1481467646000},{"_id":"source/images/sup-shop.jpeg","hash":"c17f82661c0448f716eabfa4ecb13e214e1d1f67","modified":1481214862000},{"_id":"source/images/guoguo.png","hash":"4a157ff4532e12b6f77bff0e486a6d3356f7354a","modified":1481260882000},{"_id":"source/images/guoguo_sample.png","hash":"321a18a3011d4133d806e7f1858f9b171d62e271","modified":1481260911000},{"_id":"source/_drafts/BFC","hash":"13caf9ad0e78050f76de350bd822ab116a4e9e76","modified":1481464978000},{"_id":"source/_posts/margin collaspe.md","hash":"22d155542b2ce84966dd794dee10ba2c173db5b1","modified":1481467240000},{"_id":"source/_drafts/float.md","hash":"7cbd00a74b8366573b5adc7d3691e2d3382fb2f4","modified":1481867242000},{"_id":"source/_posts/this","hash":"65ad73f17f7f8741ec6f372ae44dbd9263fad64f","modified":1480940418000},{"_id":"public/404.html","hash":"2142d1179e37c66c6513af7dbb02ed7e5ad25cb7","modified":1482769684985},{"_id":"public/about/index.html","hash":"be91328c513d8b15b184fc06c6c49635b8a116a7","modified":1482769685024},{"_id":"public/tags/index.html","hash":"71fa0f582cd8203da9159e5ce831cd5a74cebdc8","modified":1482769685025},{"_id":"public/categories/index.html","hash":"fda8eb984e53a5b8c064a4a24f6f74f688a7b4cc","modified":1482769685146},{"_id":"public/2016/12/01/start/index.html","hash":"65f09d83ac396bab794a7dbf33be9bb1a9b98434","modified":1482769685147},{"_id":"public/categories/programming/index.html","hash":"baaae5a5a9dd04275e90d1e718998919d4808750","modified":1482769685155},{"_id":"public/categories/life/index.html","hash":"2b2945e12a86b861e9b8192620a01665eae4be98","modified":1482769685147},{"_id":"public/tags/记录/index.html","hash":"e726a3bf10b8ef289f15dea63ba1075fab1e339b","modified":1482769685147},{"_id":"public/tags/抄抄抄/index.html","hash":"e3012db90343f05f9014fa4c49bc812a24bb760e","modified":1482769685155},{"_id":"public/tags/JS-基础/index.html","hash":"3d32550b78ccb3759fdf7262c217055f54f02d1a","modified":1482769685147},{"_id":"public/tags/总结/index.html","hash":"771424d6b9ab9ed0b748ac682c597ed9d2df5c93","modified":1482769685147},{"_id":"public/tags/操作/index.html","hash":"1491e9eb81cc2ed4b5242bdc0af9a087d5d6a171","modified":1482769685147},{"_id":"public/tags/CI/index.html","hash":"af5cefb05a236e669b4db52335fd65b0a0e7cc13","modified":1482769685147},{"_id":"public/tags/开篇/index.html","hash":"4fdc6aa2640f2c5fcb07fe0f894274c8acb9e70e","modified":1482769685147},{"_id":"public/tags/DOM/index.html","hash":"54df6cb79477fae63baad56a7993115765652657","modified":1482769685147},{"_id":"public/tags/Hexo/index.html","hash":"927cc3df000df473025f4c444d1f1946defb1e3b","modified":1482769685147},{"_id":"public/my-projects/index.html","hash":"c1590c4f698d35321ef63688dc9a3a94bafd2d8b","modified":1482769685025},{"_id":"public/2016/12/07/React Review /index.html","hash":"db29af2996553aac8f186e4d5d6059b56a9b9201","modified":1482769685149},{"_id":"public/2016/12/05/execution context/index.html","hash":"d55d22c5754e02860c4cfed01058548e0d2271f7","modified":1482769685154},{"_id":"public/2016/12/05/closure/index.html","hash":"90a3580857baa2de95c35b74ac1c19bc5d2c2b62","modified":1482769685153},{"_id":"public/2016/12/04/ci/index.html","hash":"bf04353f47042666d7d7784ead47e4c2beae5e0d","modified":1482769685153},{"_id":"public/2016/12/03/nodelist/index.html","hash":"a8a5f5885a66e17d60b0a5254144079a9d2c169a","modified":1482769685154},{"_id":"public/2016/12/03/querySelector/index.html","hash":"31b6191952a59ce72a5703d894753184e6de29f5","modified":1482769685154},{"_id":"public/2016/12/02/start with hexo/index.html","hash":"1f71064570517c0329bcd74ec515b4fd2f79f234","modified":1482769685154},{"_id":"public/2016/12/02/Web-storage/index.html","hash":"079af16b369448f85be825a6206166170f3a547a","modified":1482769685154},{"_id":"public/archives/index.html","hash":"c04112df0582adafe66fe99ad5074f0ee3fb18e0","modified":1482769685155},{"_id":"public/archives/2016/index.html","hash":"2bb07e0e0e1230e222bab21a133f1a96859a3bb0","modified":1482769685155},{"_id":"public/archives/2016/12/index.html","hash":"d07118fcc0e07c41962460a6671429aca12b8e6c","modified":1482769685155},{"_id":"public/index.html","hash":"2d7070ba85fd3065d97e372a2bf78ec5c72e2c48","modified":1482769685155},{"_id":"public/tags/CSS-布局/index.html","hash":"eac260f43f233adcc1bccb4f05a1c28feacfdcfd","modified":1482769685148},{"_id":"public/tags/margin/index.html","hash":"0b8983865884df1aaaaf476f568b5f77d8b6b438","modified":1482769685147},{"_id":"public/2016/12/11/margin collaspe/index.html","hash":"4f8aaa5f0d97d46c3a89e1e8fb6380807298d44b","modified":1482769685148},{"_id":"source/_posts/this.md","hash":"ffae4760bfb81238759196f159a243e876545b91","modified":1481778478000},{"_id":"source/_posts/router.md","hash":"23d15eaac940c40812a56891892a0857a6f737c2","modified":1481778463000},{"_id":"public/2016/12/11/router/index.html","hash":"7ed9f621ec9e5b6c10e280a9225cf26ff192c878","modified":1482769685149},{"_id":"public/archives/2016/page/2/index.html","hash":"c2907d99e9a66fd7784d84d9c0387d4edf582f5f","modified":1482769685155},{"_id":"public/archives/page/2/index.html","hash":"ac0fdcf55fca8850acc1951eb3bd74319efbfebf","modified":1482769685155},{"_id":"public/archives/2016/12/page/2/index.html","hash":"08edaf5c891676433aec96e854d48073e1c628f2","modified":1482769685155},{"_id":"public/categories/programming/page/2/index.html","hash":"3887dc49457fc44ba3847b599e5754ad5b877cad","modified":1482769685155},{"_id":"public/tags/吵吵吵/index.html","hash":"99853461d77745f1238e42dc890749741f6ade83","modified":1482769685147},{"_id":"public/tags/React/index.html","hash":"d3baaf81b79a8bff5d6a87ef6d408a9f08284c4b","modified":1482769685147},{"_id":"public/page/2/index.html","hash":"1a1bd30163e4732cb975de4fba9050e65b26fa5b","modified":1482769685155},{"_id":"public/2016/12/05/this/index.html","hash":"5060d9005e65e0096e72d37635866382e4023e91","modified":1482769685154},{"_id":"source/_drafts/interview_doc_1.md","hash":"e80c54744289e756cc8250b8bb9427c85b47072a","modified":1481875560000},{"_id":"source/_drafts/面试 DaoClound.md","hash":"095e8c9b2e9ffd415009eb0a7b1d46f757654ac2","modified":1481718354000},{"_id":"source/_drafts/BFC.md","hash":"c041765aaa73ca2fe72af0b4d6707ed57994ea7f","modified":1481895526000},{"_id":"source/_posts/babel.md","hash":"9bdb026a435444a507e598c2bcb51237d7d64f5c","modified":1481534723000},{"_id":"source/_posts/array.mdown","hash":"74014d449f4532475955c2275bdaa7b51ba743ba","modified":1481777286000},{"_id":"source/_posts/webpack.md","hash":"4e7f058197081886496f149fd4d61092b7b20196","modified":1481534666000},{"_id":"public/tags/环境/index.html","hash":"cc8c773ff335bcdfb447d5d4dcb34c9907208c0e","modified":1482769685148},{"_id":"public/tags/存档/index.html","hash":"ce150122d8a8d993eed64d95d22ab4cbbff14eff","modified":1482769685148},{"_id":"public/2016/12/12/babel/index.html","hash":"fcf78a7d1ffceec3d6560d81e535849ffd7eb956","modified":1482769685148},{"_id":"public/2016/12/12/webpack/index.html","hash":"93041cfa8cbd3e6af81d0b51890445efc1b3deda","modified":1482769685148},{"_id":"source/_posts/array.md","hash":"59c889891369541a7995adf1c06ba05e77c36ac9","modified":1481780452000},{"_id":"source/_posts/es6-arrowfunction.md","hash":"241e9017f4feaeef07e41b5e54c30cb1c66bd535","modified":1480918769000},{"_id":"source/_posts/promise.md","hash":"2ef827ec02b358eade14b2d565ab4cef571f1641","modified":1481811520000},{"_id":"source/_drafts/prototype.md","hash":"f410d2b312d97ee957916062934c8a41d38cd219","modified":1481895463000},{"_id":"source/_drafts/Jackon Yang 的思想发展史.md","hash":"f9a16a1b7216eb481910476c747afeffcaf41b38","modified":1482032402000},{"_id":"source/_drafts/rekit","hash":"512ad84c01f301e6c9713ba60152580e330cc2b4","modified":1481960439000},{"_id":"source/_posts/XMLHttpRequest.md","hash":"68d8a3899cb20f7edd8369efe1e915a6839339bd","modified":1482081173000},{"_id":"source/_posts/interview.md","hash":"7331b7ef35360bb4ccc763fbf3221f187794d77a","modified":1482489544000},{"_id":"source/_posts/BFC.md","hash":"5b95de0f08defa041da119cdeec642e6eb9c5228","modified":1482118306000},{"_id":"source/_posts/prototype.md","hash":"c74a75634099bdd8d7834464f13c80197ec4d7ac","modified":1482421758000},{"_id":"source/_posts/top.md","hash":"1d4629f4152327f676917ac5b2217117875ae626","modified":1482119505000},{"_id":"public/2016/12/19/top/index.html","hash":"c235881aab339d9130c3373dee1bed45a2dda452","modified":1482769685146},{"_id":"public/archives/page/3/index.html","hash":"074456b19264dd5cdd5227469b4c25be3e3cd343","modified":1482769685147},{"_id":"public/archives/2016/page/3/index.html","hash":"dd8ce194092d9d03bffa28eea44b48525e2ca355","modified":1482769685147},{"_id":"public/archives/2016/12/page/3/index.html","hash":"e5de67c2fac7ef22f005663d4d244c94928ab12e","modified":1482769685147},{"_id":"public/tags/抄抄抄/page/2/index.html","hash":"a89cd2b21b29ac5212b3c5802edb38d1bfccd1ba","modified":1482769685148},{"_id":"public/tags/BFC/index.html","hash":"9368ca953140a3d3e1e3012b090e8a28315038a2","modified":1482769685147},{"_id":"public/tags/数组/index.html","hash":"0f266d1e8fe2dc94b08c885eeac8fd7d98eef660","modified":1482769685148},{"_id":"public/tags/ES6/index.html","hash":"34ee8db460ff658366244ba5ba75e98e49a19265","modified":1482769685148},{"_id":"public/tags/promise/index.html","hash":"5a88a595526fcf0456674dcec5dde33acbf4f411","modified":1482769685148},{"_id":"public/tags/XMLHttpRequest/index.html","hash":"d0017647bc7a70238ccc799ef5d6331db7c0df8b","modified":1482769685148},{"_id":"public/tags/原型/index.html","hash":"4691587b1fa17b1b6dc45423adb1772e4ab8385e","modified":1482769685148},{"_id":"public/tags/prototype/index.html","hash":"e95c5f64039486d77c3ade47f4845da64e36d19c","modified":1482769685148},{"_id":"public/tags/lists/index.html","hash":"8b63edc1262fe72fe5a9b428469b69fbbe48f7dd","modified":1482769685148},{"_id":"public/2016/12/18/interview/index.html","hash":"1b502ca6ce81b77d5bd2ba6684756ed108e49a6d","modified":1482769685148},{"_id":"public/2016/12/16/XMLHttpRequest/index.html","hash":"7d30563f526f017667a411cf96d7160e6789a874","modified":1482769685148},{"_id":"public/2016/12/15/prototype/index.html","hash":"3d0f1203d90d76e1f85a95a94d8626c5fb46c470","modified":1482769685148},{"_id":"public/2016/12/15/promise/index.html","hash":"f78cdd3a6e125a1c677152020a20f6f42f1b1b50","modified":1482769685148},{"_id":"public/2016/12/15/array/index.html","hash":"f92d26305989266c9abf7bc450225464b218f3f9","modified":1482769685148},{"_id":"public/2016/12/10/BFC/index.html","hash":"b8a841db46325a1082e3911247350f58a131a3b4","modified":1482769685149},{"_id":"public/2016/12/01/es6-arrowfunction/index.html","hash":"5b6886c032dabb1ac208d108d6fadde998399078","modified":1482769685155},{"_id":"public/page/3/index.html","hash":"1be2648958eb1ab484cdbd472abae3a552852db0","modified":1482769685155},{"_id":"source/_posts/timers.md","hash":"8cc1ae9032c6c9e9ae07df5051a97a7e3e2ae43c","modified":1482769638000},{"_id":"public/categories/programming/page/3/index.html","hash":"3a77a8f107a0bb8e915332706d50e83712ef9c3e","modified":1482769685159},{"_id":"public/tags/定时器/index.html","hash":"1bef1ab7e3b56ea2610db7c428826728372308f7","modified":1482769685159},{"_id":"public/2016/12/23/timers/index.html","hash":"b69ba74c28bb335cd7edb251ca58bf5f83737578","modified":1482769685160}],"Category":[{"name":"编程","_id":"ciwfxj93l00058mra6ie3vkd3"},{"name":"生活","_id":"ciwfxj94m000o8mra20fk29vr"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","date":"2016-12-04T09:21:14.000Z","updated":"2016-12-04T09:21:14.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciwfxj8wp00008mraq0bokg7v","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"your site url \" homepagename=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"your site url \"\n        homePageName=\"回到我的主页\">\n</script>\n\n</body>\n</html>\n"},{"title":"about Me","type":"about","date":"2016-12-02T16:00:00.000Z","auto_spacing":true,"_content":"{% cq class=\"blockquote-center\" %}\n  \n前端开发攻城狮一枚～～\n\n毕业于 2015年 西北大学物理学院\n\n先开始学习了一点点 __Python__ ( 男票写 Python 的 ), 写过一个小小的爬虫\n\n之后开始踏上前端的道路\n\n自学前端技术\n\n前半年基本上是在公司切图 ( 西安 )\n\n后半年自由职业，基本上都是移动端的项目\n\n切图刚开始使用 ps, 现在使用 __sketch__ ( 超方便！ )\n\n刚开始的时候纯手写 HTML, 后来用 __Pug__ 编写 ( 开始用的时候感觉真是神器！方便了 n 多！！而且代码感觉整洁了好多～ )\n\nCSS 使用 __SCSS__, 在了解 BEM 命名规则后, 现在更加倾向于 大量的 __CSS__ + 少量 __SCSS__，对 scoped style 比较好奇\n\n刚开始使用 Jquery, 后来上手 原生JS ( 与 React  ) , ES6\n\n框架使用主要用 __React__, 尝试过 __Vue__ , 了解 React 的  数据驱动 和 虚拟 DOM 的思想。\n\nmock 工具 暂时使用 __superagent-mock__\n\n构建工具最开始, 使用  gulp, 现在使用 __webpack__\n\n代码管理 __github__ ( 之前一段时间用国内的 __码云 (  私有库 )__)\n\n常用 IDE  __Sublime__, 想尝试下 Atom 但是怕卡机 ( 我一般使用都会卡( 4G 内存 ) )\n\n开发 工具 __MAC__\n\n调试工具 __Chrome__, Safari ( Chrome 卡死后用 )\n\n越学习越知道自己的知识的薄弱, 但是会努力的！！\n  \n     \n---\n想看我具体的项目经历 \n请点击：[我做的项目](/my-projects)\n\n\n\n{% endcq %}\n","source":"about/index.md","raw":"---\ntitle: about Me\ntype: about\ndate: 2016-12-03\nauto_spacing: true\n---\n{% cq class=\"blockquote-center\" %}\n  \n前端开发攻城狮一枚～～\n\n毕业于 2015年 西北大学物理学院\n\n先开始学习了一点点 __Python__ ( 男票写 Python 的 ), 写过一个小小的爬虫\n\n之后开始踏上前端的道路\n\n自学前端技术\n\n前半年基本上是在公司切图 ( 西安 )\n\n后半年自由职业，基本上都是移动端的项目\n\n切图刚开始使用 ps, 现在使用 __sketch__ ( 超方便！ )\n\n刚开始的时候纯手写 HTML, 后来用 __Pug__ 编写 ( 开始用的时候感觉真是神器！方便了 n 多！！而且代码感觉整洁了好多～ )\n\nCSS 使用 __SCSS__, 在了解 BEM 命名规则后, 现在更加倾向于 大量的 __CSS__ + 少量 __SCSS__，对 scoped style 比较好奇\n\n刚开始使用 Jquery, 后来上手 原生JS ( 与 React  ) , ES6\n\n框架使用主要用 __React__, 尝试过 __Vue__ , 了解 React 的  数据驱动 和 虚拟 DOM 的思想。\n\nmock 工具 暂时使用 __superagent-mock__\n\n构建工具最开始, 使用  gulp, 现在使用 __webpack__\n\n代码管理 __github__ ( 之前一段时间用国内的 __码云 (  私有库 )__)\n\n常用 IDE  __Sublime__, 想尝试下 Atom 但是怕卡机 ( 我一般使用都会卡( 4G 内存 ) )\n\n开发 工具 __MAC__\n\n调试工具 __Chrome__, Safari ( Chrome 卡死后用 )\n\n越学习越知道自己的知识的薄弱, 但是会努力的！！\n  \n     \n---\n想看我具体的项目经历 \n请点击：[我做的项目](/my-projects)\n\n\n\n{% endcq %}\n","updated":"2016-12-12T08:26:09.000Z","path":"about/index.html","_id":"ciwfxj93e00028mrahlk1hi9z","comments":1,"layout":"page","content":"<blockquote class=\"blockquote-center\"><p>前端开发攻城狮一枚～～</p>\n<p>毕业于 2015年 西北大学物理学院</p>\n<p>先开始学习了一点点 <strong>Python</strong> ( 男票写 Python 的 ), 写过一个小小的爬虫</p>\n<p>之后开始踏上前端的道路</p>\n<p>自学前端技术</p>\n<p>前半年基本上是在公司切图 ( 西安 )</p>\n<p>后半年自由职业，基本上都是移动端的项目</p>\n<p>切图刚开始使用 ps, 现在使用 <strong>sketch</strong> ( 超方便！ )</p>\n<p>刚开始的时候纯手写 HTML, 后来用 <strong>Pug</strong> 编写 ( 开始用的时候感觉真是神器！方便了 n 多！！而且代码感觉整洁了好多～ )</p>\n<p>CSS 使用 <strong>SCSS</strong>, 在了解 BEM 命名规则后, 现在更加倾向于 大量的 <strong>CSS</strong> + 少量 <strong>SCSS</strong>，对 scoped style 比较好奇</p>\n<p>刚开始使用 Jquery, 后来上手 原生JS ( 与 React  ) , ES6</p>\n<p>框架使用主要用 <strong>React</strong>, 尝试过 <strong>Vue</strong> , 了解 React 的  数据驱动 和 虚拟 DOM 的思想。</p>\n<p>mock 工具 暂时使用 <strong>superagent-mock</strong></p>\n<p>构建工具最开始, 使用  gulp, 现在使用 <strong>webpack</strong></p>\n<p>代码管理 <strong>github</strong> ( 之前一段时间用国内的 <strong>码云 (  私有库 )</strong>)</p>\n<p>常用 IDE  <strong>Sublime</strong>, 想尝试下 Atom 但是怕卡机 ( 我一般使用都会卡( 4G 内存 ) )</p>\n<p>开发 工具 <strong>MAC</strong></p>\n<p>调试工具 <strong>Chrome</strong>, Safari ( Chrome 卡死后用 )</p>\n<p>越学习越知道自己的知识的薄弱, 但是会努力的！！</p>\n<hr>\n<p>想看我具体的项目经历<br>请点击：<a href=\"/my-projects\">我做的项目</a></p>\n</blockquote>\n","excerpt":"","more":"<blockquote class=\"blockquote-center\"><p>前端开发攻城狮一枚～～</p>\n<p>毕业于 2015年 西北大学物理学院</p>\n<p>先开始学习了一点点 <strong>Python</strong> ( 男票写 Python 的 ), 写过一个小小的爬虫</p>\n<p>之后开始踏上前端的道路</p>\n<p>自学前端技术</p>\n<p>前半年基本上是在公司切图 ( 西安 )</p>\n<p>后半年自由职业，基本上都是移动端的项目</p>\n<p>切图刚开始使用 ps, 现在使用 <strong>sketch</strong> ( 超方便！ )</p>\n<p>刚开始的时候纯手写 HTML, 后来用 <strong>Pug</strong> 编写 ( 开始用的时候感觉真是神器！方便了 n 多！！而且代码感觉整洁了好多～ )</p>\n<p>CSS 使用 <strong>SCSS</strong>, 在了解 BEM 命名规则后, 现在更加倾向于 大量的 <strong>CSS</strong> + 少量 <strong>SCSS</strong>，对 scoped style 比较好奇</p>\n<p>刚开始使用 Jquery, 后来上手 原生JS ( 与 React  ) , ES6</p>\n<p>框架使用主要用 <strong>React</strong>, 尝试过 <strong>Vue</strong> , 了解 React 的  数据驱动 和 虚拟 DOM 的思想。</p>\n<p>mock 工具 暂时使用 <strong>superagent-mock</strong></p>\n<p>构建工具最开始, 使用  gulp, 现在使用 <strong>webpack</strong></p>\n<p>代码管理 <strong>github</strong> ( 之前一段时间用国内的 <strong>码云 (  私有库 )</strong>)</p>\n<p>常用 IDE  <strong>Sublime</strong>, 想尝试下 Atom 但是怕卡机 ( 我一般使用都会卡( 4G 内存 ) )</p>\n<p>开发 工具 <strong>MAC</strong></p>\n<p>调试工具 <strong>Chrome</strong>, Safari ( Chrome 卡死后用 )</p>\n<p>越学习越知道自己的知识的薄弱, 但是会努力的！！</p>\n<hr>\n<p>想看我具体的项目经历<br>请点击：<a href=\"/my-projects\">我做的项目</a></p>\n</blockquote>\n"},{"title":"我做的项目","date":"2016-12-08T05:34:40.000Z","_content":"<ul class=\"my-projects-list\" >\n\n  <li class=\"my-project-item\" >\n    <img src=\"../images/shangdong.png\" class=\"my-project-img big-img\" />\n      山东大学深圳研究院官网\n      [网站请戳](http://www.shz.sdu.edu.cn/shfw/szxydt.htm)\n      独立完成的第 1 个上线的项目！公司有一套 Java 开发的建站系统，前端以组件的方式开发页面模版，后端负责渲染数据并生成页面，属于传统的 BS 架构开发模式。要适配 IE7+。\n      这个项目从开发、到最后的实施上线，都是我负责的。最终发现，开发是项目流程中最简单的一个环节。\n      使用 __gulp__ 构建，__Sass__ 编写 CSS , __Jade (Pug )__ 编写 HTML, 简单的 Jquery。\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/sup-polo.png\" class=\"my-project-img\" />\n      React 第一个项目\n      [demo 请戳](http://sup-polo.zhangxiaoxu.com)\n      [原码请戳](https://github.com/vivian-xu/job-src)\n      第一次用使用 React 开发的项目。虽然开发过程十分曲折，并且代码和结构都很不好，但是经过了这个项目，进一步的理解了 react 的理念。也进一步喜欢上了 React，它可以使我的思维更加有条理。\n      这个项目也是第一真正的与后端对接代码，虽然第一次对接的过程也不是很顺利，但是充分的了解到了与后端共同制定 API 的重要性以及 mock 的重要性。\n      使用 __webpack__ 打包构建，__React__ + __React-router__, __Sass__ 编写 CSS , __Jquery__。\n  </li>\n  <li class=\"my-project-item\">\n    <img src=\"../images/job.png\" class=\"my-project-img\" />\n      React 第二个项目\n\n      [原码请戳](https://github.com/vivian-xu/job-src)\n      [demo](http://shifu.zhangxiaoxu.com)\n\n      这个项目是比较简单的项目，相对于第一个 React 来说更得心应手了。\n      在这个项目上努力使自己的代码更加规范，整洁，结构更加的合理，并且尽量使性能更优。将组件更细分，储存在 state 里的变量尽量减少，利用 PureComponent 减少不必要的 Mount 等等。\n      为了改善用户体验，加入 Loading 和 无限滚动加载等小组件。\n      使用 __webpack__ 打包构建，__React__ + __React-router__, __原生 JS + ES6, 用 __superagent-mock__ mock 数据 ,____Sass__ 编写 CSS\n  </li>\n  <li class=\"my-project-item\">\n    <img src=\"../images/sup-shop.jpeg\" class=\"my-project-img\" />\n      我是在做完第一个 React 项目后，开始首次尝试 Vue.js 的。这次是跟一个比较有经验的前端工程师合作写的。但是其实我是以学习为主，所以最终我也没有写多少行，但是我认真的读了他的代码 ( 环境配置没太看, 其实是没太看懂 ...)。\n\n      学到很多，首先，我知道了比较正规的大公司的前端开发的正规的流程是什么。其次，这个项目给我真实的展示了怎么样划分组件。也学到了一个项目大概的内容规划。还有这个项目也是用了 mock server，更加坚定了我之后一个项目使用 mock server 的想法。当然最基础的还是如何使用 Vue 写一个简单的项目。\n\n      [原码请戳](https://github.com/vivian-xu/sup-shop-src)\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/guoguo.png\" class=\"my-project-img\" />\n      设计并实现页面。\n      产品主要针对移动端用户 ( 尤其微信 )。\n      使用 __weui__, __Css__ , 后期加入 __gulp__ 构建,  最终实现静态页面。\n      这是在公司做的第一个项目，最难的部分就是要自己设计页面。参考了很多网站，网站也实现了一大部分，但是最终也是 __达不到满意__的效果。新来了设计师后就不再开发这个版本了。\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/guoguo_sample.png\" class=\"my-project-img\" />\n      是开发的第二个版本的产品，与设计师和另一名前端程序员合作开发。\n      相对于上一个版本来说，有了专业的设计师开发更加愉快～\n      项目依旧需要适配基本的手机端。\n      基本上纯静态页面，加入了少量的 Jquery。\n      使用 __gulp__ 构建,  __Sass__ 编写 CSS , 加入少量 weui 实现的。\n  </li>\n</ul>\n\n<p>\n  联系我\n</p>\n<p>\n  Email: hi@zhangxiaoxu.com\n\n</p>\n","source":"my-projects/index.md","raw":"---\ntitle: 我做的项目\ndate: 2016-12-08 13:34:40\n---\n<ul class=\"my-projects-list\" >\n\n  <li class=\"my-project-item\" >\n    <img src=\"../images/shangdong.png\" class=\"my-project-img big-img\" />\n      山东大学深圳研究院官网\n      [网站请戳](http://www.shz.sdu.edu.cn/shfw/szxydt.htm)\n      独立完成的第 1 个上线的项目！公司有一套 Java 开发的建站系统，前端以组件的方式开发页面模版，后端负责渲染数据并生成页面，属于传统的 BS 架构开发模式。要适配 IE7+。\n      这个项目从开发、到最后的实施上线，都是我负责的。最终发现，开发是项目流程中最简单的一个环节。\n      使用 __gulp__ 构建，__Sass__ 编写 CSS , __Jade (Pug )__ 编写 HTML, 简单的 Jquery。\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/sup-polo.png\" class=\"my-project-img\" />\n      React 第一个项目\n      [demo 请戳](http://sup-polo.zhangxiaoxu.com)\n      [原码请戳](https://github.com/vivian-xu/job-src)\n      第一次用使用 React 开发的项目。虽然开发过程十分曲折，并且代码和结构都很不好，但是经过了这个项目，进一步的理解了 react 的理念。也进一步喜欢上了 React，它可以使我的思维更加有条理。\n      这个项目也是第一真正的与后端对接代码，虽然第一次对接的过程也不是很顺利，但是充分的了解到了与后端共同制定 API 的重要性以及 mock 的重要性。\n      使用 __webpack__ 打包构建，__React__ + __React-router__, __Sass__ 编写 CSS , __Jquery__。\n  </li>\n  <li class=\"my-project-item\">\n    <img src=\"../images/job.png\" class=\"my-project-img\" />\n      React 第二个项目\n\n      [原码请戳](https://github.com/vivian-xu/job-src)\n      [demo](http://shifu.zhangxiaoxu.com)\n\n      这个项目是比较简单的项目，相对于第一个 React 来说更得心应手了。\n      在这个项目上努力使自己的代码更加规范，整洁，结构更加的合理，并且尽量使性能更优。将组件更细分，储存在 state 里的变量尽量减少，利用 PureComponent 减少不必要的 Mount 等等。\n      为了改善用户体验，加入 Loading 和 无限滚动加载等小组件。\n      使用 __webpack__ 打包构建，__React__ + __React-router__, __原生 JS + ES6, 用 __superagent-mock__ mock 数据 ,____Sass__ 编写 CSS\n  </li>\n  <li class=\"my-project-item\">\n    <img src=\"../images/sup-shop.jpeg\" class=\"my-project-img\" />\n      我是在做完第一个 React 项目后，开始首次尝试 Vue.js 的。这次是跟一个比较有经验的前端工程师合作写的。但是其实我是以学习为主，所以最终我也没有写多少行，但是我认真的读了他的代码 ( 环境配置没太看, 其实是没太看懂 ...)。\n\n      学到很多，首先，我知道了比较正规的大公司的前端开发的正规的流程是什么。其次，这个项目给我真实的展示了怎么样划分组件。也学到了一个项目大概的内容规划。还有这个项目也是用了 mock server，更加坚定了我之后一个项目使用 mock server 的想法。当然最基础的还是如何使用 Vue 写一个简单的项目。\n\n      [原码请戳](https://github.com/vivian-xu/sup-shop-src)\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/guoguo.png\" class=\"my-project-img\" />\n      设计并实现页面。\n      产品主要针对移动端用户 ( 尤其微信 )。\n      使用 __weui__, __Css__ , 后期加入 __gulp__ 构建,  最终实现静态页面。\n      这是在公司做的第一个项目，最难的部分就是要自己设计页面。参考了很多网站，网站也实现了一大部分，但是最终也是 __达不到满意__的效果。新来了设计师后就不再开发这个版本了。\n  </li>\n  <li class=\"my-project-item\" >\n    <img src=\"../images/guoguo_sample.png\" class=\"my-project-img\" />\n      是开发的第二个版本的产品，与设计师和另一名前端程序员合作开发。\n      相对于上一个版本来说，有了专业的设计师开发更加愉快～\n      项目依旧需要适配基本的手机端。\n      基本上纯静态页面，加入了少量的 Jquery。\n      使用 __gulp__ 构建,  __Sass__ 编写 CSS , 加入少量 weui 实现的。\n  </li>\n</ul>\n\n<p>\n  联系我\n</p>\n<p>\n  Email: hi@zhangxiaoxu.com\n\n</p>\n","updated":"2016-12-22T15:50:10.000Z","path":"my-projects/index.html","_id":"ciwfxj93j00048mrad3y15lhz","comments":1,"layout":"page","content":"<ul class=\"my-projects-list\"><br><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/shangdong.png\" class=\"my-project-img big-img\"><br>      山东大学深圳研究院官网<br>      <a href=\"http://www.shz.sdu.edu.cn/shfw/szxydt.htm\" target=\"_blank\" rel=\"external\">网站请戳</a><br>      独立完成的第 1 个上线的项目！公司有一套 Java 开发的建站系统，前端以组件的方式开发页面模版，后端负责渲染数据并生成页面，属于传统的 BS 架构开发模式。要适配 IE7+。<br>      这个项目从开发、到最后的实施上线，都是我负责的。最终发现，开发是项目流程中最简单的一个环节。<br>      使用 <strong>gulp</strong> 构建，<strong>Sass</strong> 编写 CSS , <strong>Jade (Pug )</strong> 编写 HTML, 简单的 Jquery。<br>  </li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/sup-polo.png\" class=\"my-project-img\"><br>      React 第一个项目<br>      <a href=\"http://sup-polo.zhangxiaoxu.com\" target=\"_blank\" rel=\"external\">demo 请戳</a><br>      <a href=\"https://github.com/vivian-xu/job-src\" target=\"_blank\" rel=\"external\">原码请戳</a><br>      第一次用使用 React 开发的项目。虽然开发过程十分曲折，并且代码和结构都很不好，但是经过了这个项目，进一步的理解了 react 的理念。也进一步喜欢上了 React，它可以使我的思维更加有条理。<br>      这个项目也是第一真正的与后端对接代码，虽然第一次对接的过程也不是很顺利，但是充分的了解到了与后端共同制定 API 的重要性以及 mock 的重要性。<br>      使用 <strong>webpack</strong> 打包构建，<strong>React</strong> + <strong>React-router</strong>, <strong>Sass</strong> 编写 CSS , <strong>Jquery</strong>。<br>  </li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/job.png\" class=\"my-project-img\"><br>      React 第二个项目<br><br>      <a href=\"https://github.com/vivian-xu/job-src\" target=\"_blank\" rel=\"external\">原码请戳</a><br>      <a href=\"http://shifu.zhangxiaoxu.com\" target=\"_blank\" rel=\"external\">demo</a><br><br>      这个项目是比较简单的项目，相对于第一个 React 来说更得心应手了。<br>      在这个项目上努力使自己的代码更加规范，整洁，结构更加的合理，并且尽量使性能更优。将组件更细分，储存在 state 里的变量尽量减少，利用 PureComponent 减少不必要的 Mount 等等。<br>      为了改善用户体验，加入 Loading 和 无限滚动加载等小组件。<br>      使用 <strong>webpack</strong> 打包构建，<strong>React</strong> + <strong>React-router</strong>, <strong>原生 JS + ES6, 用 </strong>superagent-mock<strong> mock 数据 ,__</strong>Sass<strong> 编写 CSS<br>  </strong></li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/sup-shop.jpeg\" class=\"my-project-img\"><br>      我是在做完第一个 React 项目后，开始首次尝试 Vue.js 的。这次是跟一个比较有经验的前端工程师合作写的。但是其实我是以学习为主，所以最终我也没有写多少行，但是我认真的读了他的代码 ( 环境配置没太看, 其实是没太看懂 …)。<br><br>      学到很多，首先，我知道了比较正规的大公司的前端开发的正规的流程是什么。其次，这个项目给我真实的展示了怎么样划分组件。也学到了一个项目大概的内容规划。还有这个项目也是用了 mock server，更加坚定了我之后一个项目使用 mock server 的想法。当然最基础的还是如何使用 Vue 写一个简单的项目。<br><br>      <a href=\"https://github.com/vivian-xu/sup-shop-src\" target=\"_blank\" rel=\"external\">原码请戳</a><br>  </li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/guoguo.png\" class=\"my-project-img\"><br>      设计并实现页面。<br>      产品主要针对移动端用户 ( 尤其微信 )。<br>      使用 weui<strong>, </strong>Css<strong> , 后期加入 </strong>gulp<strong> 构建,  最终实现静态页面。<br>      这是在公司做的第一个项目，最难的部分就是要自己设计页面。参考了很多网站，网站也实现了一大部分，但是最终也是 </strong>达不到满意<strong>的效果。新来了设计师后就不再开发这个版本了。<br>  </strong></li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/guoguo_sample.png\" class=\"my-project-img\"><br>      是开发的第二个版本的产品，与设计师和另一名前端程序员合作开发。<br>      相对于上一个版本来说，有了专业的设计师开发更加愉快～<br>      项目依旧需要适配基本的手机端。<br>      基本上纯静态页面，加入了少量的 Jquery。<br>      使用 gulp<strong> 构建,  </strong>Sass__ 编写 CSS , 加入少量 weui 实现的。<br>  </li><br></ul>\n\n<p><br>  联系我<br></p><br><p><br>  Email: hi@zhangxiaoxu.com<br><br></p>\n","excerpt":"","more":"<ul class=\"my-projects-list\" ><br><br>  <li class=\"my-project-item\" ><br>    <img src=\"../images/shangdong.png\" class=\"my-project-img big-img\" /><br>      山东大学深圳研究院官网<br>      <a href=\"http://www.shz.sdu.edu.cn/shfw/szxydt.htm\">网站请戳</a><br>      独立完成的第 1 个上线的项目！公司有一套 Java 开发的建站系统，前端以组件的方式开发页面模版，后端负责渲染数据并生成页面，属于传统的 BS 架构开发模式。要适配 IE7+。<br>      这个项目从开发、到最后的实施上线，都是我负责的。最终发现，开发是项目流程中最简单的一个环节。<br>      使用 <strong>gulp</strong> 构建，<strong>Sass</strong> 编写 CSS , <strong>Jade (Pug )</strong> 编写 HTML, 简单的 Jquery。<br>  </li><br>  <li class=\"my-project-item\" ><br>    <img src=\"../images/sup-polo.png\" class=\"my-project-img\" /><br>      React 第一个项目<br>      <a href=\"http://sup-polo.zhangxiaoxu.com\">demo 请戳</a><br>      <a href=\"https://github.com/vivian-xu/job-src\">原码请戳</a><br>      第一次用使用 React 开发的项目。虽然开发过程十分曲折，并且代码和结构都很不好，但是经过了这个项目，进一步的理解了 react 的理念。也进一步喜欢上了 React，它可以使我的思维更加有条理。<br>      这个项目也是第一真正的与后端对接代码，虽然第一次对接的过程也不是很顺利，但是充分的了解到了与后端共同制定 API 的重要性以及 mock 的重要性。<br>      使用 <strong>webpack</strong> 打包构建，<strong>React</strong> + <strong>React-router</strong>, <strong>Sass</strong> 编写 CSS , <strong>Jquery</strong>。<br>  </li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/job.png\" class=\"my-project-img\" /><br>      React 第二个项目<br><br>      <a href=\"https://github.com/vivian-xu/job-src\">原码请戳</a><br>      <a href=\"http://shifu.zhangxiaoxu.com\">demo</a><br><br>      这个项目是比较简单的项目，相对于第一个 React 来说更得心应手了。<br>      在这个项目上努力使自己的代码更加规范，整洁，结构更加的合理，并且尽量使性能更优。将组件更细分，储存在 state 里的变量尽量减少，利用 PureComponent 减少不必要的 Mount 等等。<br>      为了改善用户体验，加入 Loading 和 无限滚动加载等小组件。<br>      使用 <strong>webpack</strong> 打包构建，<strong>React</strong> + <strong>React-router</strong>, <strong>原生 JS + ES6, 用 </strong>superagent-mock<strong> mock 数据 ,__</strong>Sass<strong> 编写 CSS<br>  </li><br>  <li class=\"my-project-item\"><br>    <img src=\"../images/sup-shop.jpeg\" class=\"my-project-img\" /><br>      我是在做完第一个 React 项目后，开始首次尝试 Vue.js 的。这次是跟一个比较有经验的前端工程师合作写的。但是其实我是以学习为主，所以最终我也没有写多少行，但是我认真的读了他的代码 ( 环境配置没太看, 其实是没太看懂 …)。<br><br>      学到很多，首先，我知道了比较正规的大公司的前端开发的正规的流程是什么。其次，这个项目给我真实的展示了怎么样划分组件。也学到了一个项目大概的内容规划。还有这个项目也是用了 mock server，更加坚定了我之后一个项目使用 mock server 的想法。当然最基础的还是如何使用 Vue 写一个简单的项目。<br><br>      <a href=\"https://github.com/vivian-xu/sup-shop-src\">原码请戳</a><br>  </li><br>  <li class=\"my-project-item\" ><br>    <img src=\"../images/guoguo.png\" class=\"my-project-img\" /><br>      设计并实现页面。<br>      产品主要针对移动端用户 ( 尤其微信 )。<br>      使用 </strong>weui<strong>, </strong>Css<strong> , 后期加入 </strong>gulp<strong> 构建,  最终实现静态页面。<br>      这是在公司做的第一个项目，最难的部分就是要自己设计页面。参考了很多网站，网站也实现了一大部分，但是最终也是 </strong>达不到满意<strong>的效果。新来了设计师后就不再开发这个版本了。<br>  </li><br>  <li class=\"my-project-item\" ><br>    <img src=\"../images/guoguo_sample.png\" class=\"my-project-img\" /><br>      是开发的第二个版本的产品，与设计师和另一名前端程序员合作开发。<br>      相对于上一个版本来说，有了专业的设计师开发更加愉快～<br>      项目依旧需要适配基本的手机端。<br>      基本上纯静态页面，加入了少量的 Jquery。<br>      使用 </strong>gulp<strong> 构建,  </strong>Sass__ 编写 CSS , 加入少量 weui 实现的。<br>  </li><br></ul>\n\n<p><br>  联系我<br></p><br><p><br>  Email: hi@zhangxiaoxu.com<br><br></p>\n"},{"title":"标签","date":"2016-12-03T13:33:37.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-12-03 21:33:37\ntype: \"tags\"\n---\n","updated":"2016-12-03T13:34:42.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciwfxj93p00088mrawzy0v3l7","content":"","excerpt":"","more":""},{"title":"分类","type":"categories","date":"2016-12-03T13:36:13.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: categories\ndate: 2016-12-03 21:36:13\n---\n","updated":"2016-12-08T07:43:04.000Z","path":"categories/index.html","_id":"ciwfxj942000a8mracjaci6ya","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Cookie","_content":"### 数据存储 Cookie\n\n一. Cookie ( HTTP Cookie )\n\n#### 用法\n\n- 该标准要求服务器任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。\n\n```\n  //  服务器的响应头文件\n  HTTP/1.1 200 OK\n  Content-type: text/html\n  Set-Cookie: name=value\n  Other-header: other-header-value\n```\n\n- 浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。\n\n```\n  GeT/index.html HTTP/1.1\n  Cookie: name=value\n  other-header: other-header-value\n```\n<!-- more -->\n#### 限制\n\n- cookie 在性质上是绑在特定的域名下的。 设定了一个 cookie 之后，再给创建它的域名发送请求时。都会包含这个 cookie.\n- 但是由于 它是 存在客户端的计算机上的，每个域的 cookie  总数有限。 不过浏览器之间不同。\n\nIE6-  -- 20, IE7+ -- 50,\n\nFf -- 50, Opera -- 30, Safari / Chorme 没有规定\n\n当超过限制的时候，浏览器会清除之前的设置的 cookie。\n\n- 对 cookie  的尺寸也有限制。\n\n大多数浏览器都有大约  4096B  的长度限制。\n 尺寸限制影响到一个域下所有的 cookie ，而并非每个 cookie 单独限制。当超过限制的时候，该 cookie 会被悄无声息的丢掉。\n\n #### 构成\n\n - 名称： 唯一确定 cookie 的名称。 不区分大小写。（ 实践中看成区分大小写的，因为有的服务器会这样处理 ） 。 必须是经过 URL 编码的。\n - 值 。 要经过 URL 编码。\n - 域： cookie 是对哪个域是有效的。\n- 路径： 对于制定域中的那个路径，应该向服务器发送 cookie 。\n- 失效时间。\n- 安全标志： 指定后, cookie 只有在使用 SSL 链接时候才发送到服务器。\n\n#### ！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。\n\n使用分号 + 空格分割每一段\n\n```\n  HTTP/1.1 200 OK\n  Content-type: text/html\n  Set-Cookie: name=value; domain=.wrox.com; path=/; secure\n  Other-header: other-header-value\n```\n\n--\n参考 :\n\n  JavaScript 高级程序设计\n","source":"_drafts/Cookie.md","raw":"title: Cookie\ncategories:\n- 编程\ntags:\n- 记录\n\n---\n### 数据存储 Cookie\n\n一. Cookie ( HTTP Cookie )\n\n#### 用法\n\n- 该标准要求服务器任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。\n\n```\n  //  服务器的响应头文件\n  HTTP/1.1 200 OK\n  Content-type: text/html\n  Set-Cookie: name=value\n  Other-header: other-header-value\n```\n\n- 浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。\n\n```\n  GeT/index.html HTTP/1.1\n  Cookie: name=value\n  other-header: other-header-value\n```\n<!-- more -->\n#### 限制\n\n- cookie 在性质上是绑在特定的域名下的。 设定了一个 cookie 之后，再给创建它的域名发送请求时。都会包含这个 cookie.\n- 但是由于 它是 存在客户端的计算机上的，每个域的 cookie  总数有限。 不过浏览器之间不同。\n\nIE6-  -- 20, IE7+ -- 50,\n\nFf -- 50, Opera -- 30, Safari / Chorme 没有规定\n\n当超过限制的时候，浏览器会清除之前的设置的 cookie。\n\n- 对 cookie  的尺寸也有限制。\n\n大多数浏览器都有大约  4096B  的长度限制。\n 尺寸限制影响到一个域下所有的 cookie ，而并非每个 cookie 单独限制。当超过限制的时候，该 cookie 会被悄无声息的丢掉。\n\n #### 构成\n\n - 名称： 唯一确定 cookie 的名称。 不区分大小写。（ 实践中看成区分大小写的，因为有的服务器会这样处理 ） 。 必须是经过 URL 编码的。\n - 值 。 要经过 URL 编码。\n - 域： cookie 是对哪个域是有效的。\n- 路径： 对于制定域中的那个路径，应该向服务器发送 cookie 。\n- 失效时间。\n- 安全标志： 指定后, cookie 只有在使用 SSL 链接时候才发送到服务器。\n\n#### ！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。\n\n使用分号 + 空格分割每一段\n\n```\n  HTTP/1.1 200 OK\n  Content-type: text/html\n  Set-Cookie: name=value; domain=.wrox.com; path=/; secure\n  Other-header: other-header-value\n```\n\n--\n参考 :\n\n  JavaScript 高级程序设计\n","slug":"Cookie","published":0,"date":"2016-12-02T08:37:01.000Z","updated":"2016-12-03T11:06:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj93a00018mrarxin9yzu","content":"<h3 id=\"数据存储-Cookie\"><a href=\"#数据存储-Cookie\" class=\"headerlink\" title=\"数据存储 Cookie\"></a>数据存储 Cookie</h3><p>一. Cookie ( HTTP Cookie )</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><ul>\n<li>该标准要求服务器任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  服务器的响应头文件</div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Content-type: text/html</div><div class=\"line\">Set-Cookie: name=value</div><div class=\"line\">Other-header: other-header-value</div></pre></td></tr></table></figure>\n<ul>\n<li>浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">GeT/index.html HTTP/1.1</div><div class=\"line\">Cookie: name=value</div><div class=\"line\">other-header: other-header-value</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h4><ul>\n<li>cookie 在性质上是绑在特定的域名下的。 设定了一个 cookie 之后，再给创建它的域名发送请求时。都会包含这个 cookie.</li>\n<li>但是由于 它是 存在客户端的计算机上的，每个域的 cookie  总数有限。 不过浏览器之间不同。</li>\n</ul>\n<p>IE6-  – 20, IE7+ – 50,</p>\n<p>Ff – 50, Opera – 30, Safari / Chorme 没有规定</p>\n<p>当超过限制的时候，浏览器会清除之前的设置的 cookie。</p>\n<ul>\n<li>对 cookie  的尺寸也有限制。</li>\n</ul>\n<p>大多数浏览器都有大约  4096B  的长度限制。<br> 尺寸限制影响到一个域下所有的 cookie ，而并非每个 cookie 单独限制。当超过限制的时候，该 cookie 会被悄无声息的丢掉。</p>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><ul>\n<li>名称： 唯一确定 cookie 的名称。 不区分大小写。（ 实践中看成区分大小写的，因为有的服务器会这样处理 ） 。 必须是经过 URL 编码的。</li>\n<li>值 。 要经过 URL 编码。</li>\n<li>域： cookie 是对哪个域是有效的。<ul>\n<li>路径： 对于制定域中的那个路径，应该向服务器发送 cookie 。</li>\n<li>失效时间。</li>\n<li>安全标志： 指定后, cookie 只有在使用 SSL 链接时候才发送到服务器。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"！！注意！！-这些参数不会作为发送到服务器的-cookie-信息的一部分，只有明值对才会被发送。\"><a href=\"#！！注意！！-这些参数不会作为发送到服务器的-cookie-信息的一部分，只有明值对才会被发送。\" class=\"headerlink\" title=\"！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。\"></a>！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。</h4><p>使用分号 + 空格分割每一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Content-type: text/html</div><div class=\"line\">Set-Cookie: name=value; domain=.wrox.com; path=/; secure</div><div class=\"line\">Other-header: other-header-value</div></pre></td></tr></table></figure>\n<p>–<br>参考 :</p>\n<p>  JavaScript 高级程序设计</p>\n","excerpt":"<h3 id=\"数据存储-Cookie\"><a href=\"#数据存储-Cookie\" class=\"headerlink\" title=\"数据存储 Cookie\"></a>数据存储 Cookie</h3><p>一. Cookie ( HTTP Cookie )</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><ul>\n<li>该标准要求服务器任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  服务器的响应头文件</div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Content-type: text/html</div><div class=\"line\">Set-Cookie: name=value</div><div class=\"line\">Other-header: other-header-value</div></pre></td></tr></table></figure>\n<ul>\n<li>浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">GeT/index.html HTTP/1.1</div><div class=\"line\">Cookie: name=value</div><div class=\"line\">other-header: other-header-value</div></pre></td></tr></table></figure>","more":"<h4 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h4><ul>\n<li>cookie 在性质上是绑在特定的域名下的。 设定了一个 cookie 之后，再给创建它的域名发送请求时。都会包含这个 cookie.</li>\n<li>但是由于 它是 存在客户端的计算机上的，每个域的 cookie  总数有限。 不过浏览器之间不同。</li>\n</ul>\n<p>IE6-  – 20, IE7+ – 50,</p>\n<p>Ff – 50, Opera – 30, Safari / Chorme 没有规定</p>\n<p>当超过限制的时候，浏览器会清除之前的设置的 cookie。</p>\n<ul>\n<li>对 cookie  的尺寸也有限制。</li>\n</ul>\n<p>大多数浏览器都有大约  4096B  的长度限制。<br> 尺寸限制影响到一个域下所有的 cookie ，而并非每个 cookie 单独限制。当超过限制的时候，该 cookie 会被悄无声息的丢掉。</p>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><ul>\n<li>名称： 唯一确定 cookie 的名称。 不区分大小写。（ 实践中看成区分大小写的，因为有的服务器会这样处理 ） 。 必须是经过 URL 编码的。</li>\n<li>值 。 要经过 URL 编码。</li>\n<li>域： cookie 是对哪个域是有效的。<ul>\n<li>路径： 对于制定域中的那个路径，应该向服务器发送 cookie 。</li>\n<li>失效时间。</li>\n<li>安全标志： 指定后, cookie 只有在使用 SSL 链接时候才发送到服务器。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"！！注意！！-这些参数不会作为发送到服务器的-cookie-信息的一部分，只有明值对才会被发送。\"><a href=\"#！！注意！！-这些参数不会作为发送到服务器的-cookie-信息的一部分，只有明值对才会被发送。\" class=\"headerlink\" title=\"！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。\"></a>！！注意！！ 这些参数不会作为发送到服务器的 cookie 信息的一部分，只有明值对才会被发送。</h4><p>使用分号 + 空格分割每一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Content-type: text/html</div><div class=\"line\">Set-Cookie: name=value; domain=.wrox.com; path=/; secure</div><div class=\"line\">Other-header: other-header-value</div></pre></td></tr></table></figure>\n<p>–<br>参考 :</p>\n<p>  JavaScript 高级程序设计</p>"},{"title":"Web 存储","auto_spacing":true,"_content":"\n### 目的\n\n- 提供一种在 cookie 之外存储会话数据的途径。\n\n- 提供一种存储大量可以跨会话存在的数据机制。\n\n\n#### 类型\n\n最初的 Web Storage 规范包含了两种对象的定义： sessionStorage 和 globalStorage。 它们是以 window  的对象属性的形式存在的。\n\n##### Storage 类型\n\n  Storage 类型提供最大的存储空间, 来存储名值对。( 只能存储字符串，非字符串会在存储前转换成字符串 )\n<!-- more -->\n\n  Storage 的实例与其他对象类似，有如下方法。\n\n  + clear(): 删除所有值; Ff 中没有实现\n\n  + getItem(name): 根据指定的名字 name 获取对应的值\n\n  + key(index): 获取 index 位置处的值的名字\n\n  + removeItem(name, value): 删除由 name 指定的名值对\n\n  + setItem(name, value): 为指定的 name 设置一个对应的值\n\n其中， getItem(), removeItem(), setItem() 方法可以直接调用，也可以通过 Storage 对象间接调用。\n\n\n因为每个项目都是作为属性存储在该对象上的，所以可以通过 点语法 或者 方括号 访问属性来读取，设置值，或 通过 delete 来删除值。 ( __不建议__ )\n\n我们还可以用 __length__ 属性来判断有多少名值对，但无法判断所有数据的大小。( IE8 提供了 remainingSpace 属性，用于获取还可以使用的存储空间的字节数 )\n\n##### sessionStorage 对象 ( Storage 的一个实例 )\n\n  + 存储特定于每个会话的数据 ( 即该数据只保持到 __浏览器__ 关闭 )\n\n  + 可以跨越页面刷新而存在 ( __不是跨越会话__ )\n\n  + 如果浏览器支持，浏览器崩溃重启之后依然可以使用 ( Ff 和 Webkit 支持, IE 不行 )\n\n  + sessionStorage 对象绑定于某个服务器会话。( 文件本地运行不可用 )\n\n  + 存储在它里面的数据只能由最初给对象存储数据的页面访问到，所以对 __多页面__ 应用有限制\n\n  + 由于它是 Storage 的一个实例，所以可以用 setItem() 或者直接设置新的属性来存储数据\n\n```\n  // 使用方法存储数据\n  sessionStorage.setItem(\"name\", \"Nicholas\");\n\n  // 使用属性存储数据\n  sessionStorage.book = \"Professional JavaScript\";\n\n```\n  + 不同浏览器写入数据方面略有不同。Ff 和 Webkit 同步写入， IE  异步写入。 所以，IE 在设置数据和将数据实际写入磁盘之间可能会有一些延迟, 但是它会更快的回复执行。\n\n  + IE8 中可以强制把数据写入磁盘： 在设置新数据前使用 begin() , 在所有设置完了后调用 commit() 。\n\n```\n  sessionStorage.begin();\n  sessionStorage.name = \"Nicholas\";\n  sessionStorage.book = \"Professional JavaScript\";\n  sessionStorage.commit();\n```\n\n这样就确保 name book 在调用 commit() 后被立刻写入了磁盘。 begin() 是确保在这段代码执行的时候不会有其他磁盘写入操作。\n\n  + 读取数据可以使用 getItem() 或 通过直接访问属性名。\n\n  ```\n  // 使用方法获取\n  var name = sessionStorage.getItem(\"name\");\n\n  // 使用属性读取\n  var book = sessionStorage.book;\n```\n  + 迭代\n    - 通过 length 和 key()\n\n```\n  for(var i = 0, len = sessionStorage.length(); i < len; i++) {\n    var key = sessionStorage.key(i);\n    var value = sessionStorage.getItem(key);\n    alert(key + \"=\" + value);\n  }\n```\n    - 通过 for  in\n```\n  for (var key in sessionStorage) {\n    var value = sessionStorage.getItem(key);\n    alert(key + \"=\" + value);\n  }\n```\n  + 删除\n\n    - delete 操作符\n\n```\n  // Webkit 中无效\n  delete sessionStorage.name\n```\n\n    - removeItem()\n\n```\n  // removeItem()\n  sessionStorage.removeItem('book');\n```\n\n##### globalStorage 对象\n\n    - 目的是实现跨越会话的存储数据，但是有特定的访问权限\n\n    - 使用之前先指定哪些域可以访问该数据。( 通过方括号标记使用属性实现 )\n\n```\n  // 保存数据\n  globalStorage[\"wrox.com\"].name = \"Nicholas\";\n\n  // 获取数据\n  var name = globalStorage[\"wrox.com\"].name;\n```\n上面是针对 wrox.com 的存储空间。对于  wrox.com 和 它的子域都是可访问的\n\n    - globalStorage 对象 __不是  Storage 的实例__\n    - globalStorage[\"wrox.com\"] 才是\n\n    - 可以这样限制只有 子域名 www.wrox.com 可访问\n\n```\n  // 保存数据\n  globalStorage[\"www.wrox.com\"].name = \"Nicholas\";\n\n  // 获取数据\n  var name = globalStorage[\"www.wrox.com\"].name;\n```\n\n  - 对于 globalStorage\n  空间的访问，是依据发起请求的页面的 __域名，协议，端口__ 来限制的。\n\n  比如：\n\n    通过 HTTP 不能访问 通过 HTTPS 存储的数据\n\n    端口不同，不能访问\n\n  - __globalStorage 的每个属性都是 Storage 的实例__\n\n    可以这样子：\n\n```\n  globalStorage[\"www.wrox.com\"].name = \"Nicholas\";\n  globalStorage[\"www.wrox.com\"].book = \"Professional JavaScript\";\n  globalStorage[\"www.wrox.com\"].removeItem(\"name\");\n\n  var book = globalStorage[\"www.wrox.com\"].getItem(\"book\");\n```\n\n  - 当不能确定域名的时候 用 location.host\n\n  - 若不使用 removeItem() / delete 删除，或 用户未清除缓存， globalStorage 里的数据会一直保留在磁盘上\n\n##### localStorage\n\n  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage\n---\n\n  - localStorage 不能指定任何访问规则。\n\n  - 要访问同一个 localStorage 对象， 页面必须来自同一个域名，使用同一个端口，在同一个协议下 ( 相当于 globalStorage[location.host] )\n\n  - localStorage 是 Storage 的实例，可以像使用 sessionStorage 一样来使用它\n\n```\n  // 使用方法存储数据\n  localStorage.setItem(\"name\", \"Nicholas\");\n\n // 使用属性存储数据\n  localStorage.book = \"Professional JavaScript\";\n\n  //  使用方法 读取数据\n  var name = localStorage.getItem(\"name\");\n\n  // 使用属性读取数据\n  var book = localStorage.book;\n```\n  - 存储在 localStorage 中的数据和存储在 globalStorage 中的数据一样， __数据保留到通过 JS 删除，或者用户清除缓存  __\n\n##### storage 事件\n\n  对 storage 对象进行任何修改，都会在文档上触发 storage 事件。\n\n  这个事件的 event 对象有以下几个属性\n\n    + domain':' 发生变化的存储空间的域名\n    + key'':'' 设置或者删除的键名\n    + newValue':' 如果是设置值，则是新值; 如果是删除键，则是 null\n    + oldValue':' 键被更改之前的值\n\n  其中 IE8 和 Ff 只实现了 domain 属性。 webkit 尚不支持 storage 事件。\n\n##### 限制\n\n  - 因浏览器而异\n\n  - 以每个 来源( 协议，端口，域 ) 为单位 ( 每个来源都有固定的空间 )\n\n  - localStorage 多数为 5MB 限制， Chorme 和 Safari 是 2.5MB 限制。 IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。\n\n  - sessionStorage， 有的没有限制，  Chorme 和 Safari , IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。\n    IE8+ 和 Opera 是 5MB\n\n--\n参考 :\n\n  JavaScript 高级程序设计\n","source":"_posts/Web-storage.md","raw":"---\ntitle: Web 存储\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- JS 基础\nauto_spacing: true\n---\n\n### 目的\n\n- 提供一种在 cookie 之外存储会话数据的途径。\n\n- 提供一种存储大量可以跨会话存在的数据机制。\n\n\n#### 类型\n\n最初的 Web Storage 规范包含了两种对象的定义： sessionStorage 和 globalStorage。 它们是以 window  的对象属性的形式存在的。\n\n##### Storage 类型\n\n  Storage 类型提供最大的存储空间, 来存储名值对。( 只能存储字符串，非字符串会在存储前转换成字符串 )\n<!-- more -->\n\n  Storage 的实例与其他对象类似，有如下方法。\n\n  + clear(): 删除所有值; Ff 中没有实现\n\n  + getItem(name): 根据指定的名字 name 获取对应的值\n\n  + key(index): 获取 index 位置处的值的名字\n\n  + removeItem(name, value): 删除由 name 指定的名值对\n\n  + setItem(name, value): 为指定的 name 设置一个对应的值\n\n其中， getItem(), removeItem(), setItem() 方法可以直接调用，也可以通过 Storage 对象间接调用。\n\n\n因为每个项目都是作为属性存储在该对象上的，所以可以通过 点语法 或者 方括号 访问属性来读取，设置值，或 通过 delete 来删除值。 ( __不建议__ )\n\n我们还可以用 __length__ 属性来判断有多少名值对，但无法判断所有数据的大小。( IE8 提供了 remainingSpace 属性，用于获取还可以使用的存储空间的字节数 )\n\n##### sessionStorage 对象 ( Storage 的一个实例 )\n\n  + 存储特定于每个会话的数据 ( 即该数据只保持到 __浏览器__ 关闭 )\n\n  + 可以跨越页面刷新而存在 ( __不是跨越会话__ )\n\n  + 如果浏览器支持，浏览器崩溃重启之后依然可以使用 ( Ff 和 Webkit 支持, IE 不行 )\n\n  + sessionStorage 对象绑定于某个服务器会话。( 文件本地运行不可用 )\n\n  + 存储在它里面的数据只能由最初给对象存储数据的页面访问到，所以对 __多页面__ 应用有限制\n\n  + 由于它是 Storage 的一个实例，所以可以用 setItem() 或者直接设置新的属性来存储数据\n\n```\n  // 使用方法存储数据\n  sessionStorage.setItem(\"name\", \"Nicholas\");\n\n  // 使用属性存储数据\n  sessionStorage.book = \"Professional JavaScript\";\n\n```\n  + 不同浏览器写入数据方面略有不同。Ff 和 Webkit 同步写入， IE  异步写入。 所以，IE 在设置数据和将数据实际写入磁盘之间可能会有一些延迟, 但是它会更快的回复执行。\n\n  + IE8 中可以强制把数据写入磁盘： 在设置新数据前使用 begin() , 在所有设置完了后调用 commit() 。\n\n```\n  sessionStorage.begin();\n  sessionStorage.name = \"Nicholas\";\n  sessionStorage.book = \"Professional JavaScript\";\n  sessionStorage.commit();\n```\n\n这样就确保 name book 在调用 commit() 后被立刻写入了磁盘。 begin() 是确保在这段代码执行的时候不会有其他磁盘写入操作。\n\n  + 读取数据可以使用 getItem() 或 通过直接访问属性名。\n\n  ```\n  // 使用方法获取\n  var name = sessionStorage.getItem(\"name\");\n\n  // 使用属性读取\n  var book = sessionStorage.book;\n```\n  + 迭代\n    - 通过 length 和 key()\n\n```\n  for(var i = 0, len = sessionStorage.length(); i < len; i++) {\n    var key = sessionStorage.key(i);\n    var value = sessionStorage.getItem(key);\n    alert(key + \"=\" + value);\n  }\n```\n    - 通过 for  in\n```\n  for (var key in sessionStorage) {\n    var value = sessionStorage.getItem(key);\n    alert(key + \"=\" + value);\n  }\n```\n  + 删除\n\n    - delete 操作符\n\n```\n  // Webkit 中无效\n  delete sessionStorage.name\n```\n\n    - removeItem()\n\n```\n  // removeItem()\n  sessionStorage.removeItem('book');\n```\n\n##### globalStorage 对象\n\n    - 目的是实现跨越会话的存储数据，但是有特定的访问权限\n\n    - 使用之前先指定哪些域可以访问该数据。( 通过方括号标记使用属性实现 )\n\n```\n  // 保存数据\n  globalStorage[\"wrox.com\"].name = \"Nicholas\";\n\n  // 获取数据\n  var name = globalStorage[\"wrox.com\"].name;\n```\n上面是针对 wrox.com 的存储空间。对于  wrox.com 和 它的子域都是可访问的\n\n    - globalStorage 对象 __不是  Storage 的实例__\n    - globalStorage[\"wrox.com\"] 才是\n\n    - 可以这样限制只有 子域名 www.wrox.com 可访问\n\n```\n  // 保存数据\n  globalStorage[\"www.wrox.com\"].name = \"Nicholas\";\n\n  // 获取数据\n  var name = globalStorage[\"www.wrox.com\"].name;\n```\n\n  - 对于 globalStorage\n  空间的访问，是依据发起请求的页面的 __域名，协议，端口__ 来限制的。\n\n  比如：\n\n    通过 HTTP 不能访问 通过 HTTPS 存储的数据\n\n    端口不同，不能访问\n\n  - __globalStorage 的每个属性都是 Storage 的实例__\n\n    可以这样子：\n\n```\n  globalStorage[\"www.wrox.com\"].name = \"Nicholas\";\n  globalStorage[\"www.wrox.com\"].book = \"Professional JavaScript\";\n  globalStorage[\"www.wrox.com\"].removeItem(\"name\");\n\n  var book = globalStorage[\"www.wrox.com\"].getItem(\"book\");\n```\n\n  - 当不能确定域名的时候 用 location.host\n\n  - 若不使用 removeItem() / delete 删除，或 用户未清除缓存， globalStorage 里的数据会一直保留在磁盘上\n\n##### localStorage\n\n  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage\n---\n\n  - localStorage 不能指定任何访问规则。\n\n  - 要访问同一个 localStorage 对象， 页面必须来自同一个域名，使用同一个端口，在同一个协议下 ( 相当于 globalStorage[location.host] )\n\n  - localStorage 是 Storage 的实例，可以像使用 sessionStorage 一样来使用它\n\n```\n  // 使用方法存储数据\n  localStorage.setItem(\"name\", \"Nicholas\");\n\n // 使用属性存储数据\n  localStorage.book = \"Professional JavaScript\";\n\n  //  使用方法 读取数据\n  var name = localStorage.getItem(\"name\");\n\n  // 使用属性读取数据\n  var book = localStorage.book;\n```\n  - 存储在 localStorage 中的数据和存储在 globalStorage 中的数据一样， __数据保留到通过 JS 删除，或者用户清除缓存  __\n\n##### storage 事件\n\n  对 storage 对象进行任何修改，都会在文档上触发 storage 事件。\n\n  这个事件的 event 对象有以下几个属性\n\n    + domain':' 发生变化的存储空间的域名\n    + key'':'' 设置或者删除的键名\n    + newValue':' 如果是设置值，则是新值; 如果是删除键，则是 null\n    + oldValue':' 键被更改之前的值\n\n  其中 IE8 和 Ff 只实现了 domain 属性。 webkit 尚不支持 storage 事件。\n\n##### 限制\n\n  - 因浏览器而异\n\n  - 以每个 来源( 协议，端口，域 ) 为单位 ( 每个来源都有固定的空间 )\n\n  - localStorage 多数为 5MB 限制， Chorme 和 Safari 是 2.5MB 限制。 IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。\n\n  - sessionStorage， 有的没有限制，  Chorme 和 Safari , IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。\n    IE8+ 和 Opera 是 5MB\n\n--\n参考 :\n\n  JavaScript 高级程序设计\n","slug":"Web-storage","published":1,"date":"2016-12-02T08:59:38.000Z","updated":"2016-12-05T06:20:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj93h00038mrat1t8ucin","content":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><ul>\n<li><p>提供一种在 cookie 之外存储会话数据的途径。</p>\n</li>\n<li><p>提供一种存储大量可以跨会话存在的数据机制。</p>\n</li>\n</ul>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>最初的 Web Storage 规范包含了两种对象的定义： sessionStorage 和 globalStorage。 它们是以 window  的对象属性的形式存在的。</p>\n<h5 id=\"Storage-类型\"><a href=\"#Storage-类型\" class=\"headerlink\" title=\"Storage 类型\"></a>Storage 类型</h5><p>  Storage 类型提供最大的存储空间, 来存储名值对。( 只能存储字符串，非字符串会在存储前转换成字符串 )<br><a id=\"more\"></a></p>\n<p>  Storage 的实例与其他对象类似，有如下方法。</p>\n<ul>\n<li><p>clear(): 删除所有值; Ff 中没有实现</p>\n</li>\n<li><p>getItem(name): 根据指定的名字 name 获取对应的值</p>\n</li>\n<li><p>key(index): 获取 index 位置处的值的名字</p>\n</li>\n<li><p>removeItem(name, value): 删除由 name 指定的名值对</p>\n</li>\n<li><p>setItem(name, value): 为指定的 name 设置一个对应的值</p>\n</li>\n</ul>\n<p>其中， getItem(), removeItem(), setItem() 方法可以直接调用，也可以通过 Storage 对象间接调用。</p>\n<p>因为每个项目都是作为属性存储在该对象上的，所以可以通过 点语法 或者 方括号 访问属性来读取，设置值，或 通过 delete 来删除值。 ( <strong>不建议</strong> )</p>\n<p>我们还可以用 <strong>length</strong> 属性来判断有多少名值对，但无法判断所有数据的大小。( IE8 提供了 remainingSpace 属性，用于获取还可以使用的存储空间的字节数 )</p>\n<h5 id=\"sessionStorage-对象-Storage-的一个实例\"><a href=\"#sessionStorage-对象-Storage-的一个实例\" class=\"headerlink\" title=\"sessionStorage 对象 ( Storage 的一个实例 )\"></a>sessionStorage 对象 ( Storage 的一个实例 )</h5><ul>\n<li><p>存储特定于每个会话的数据 ( 即该数据只保持到 <strong>浏览器</strong> 关闭 )</p>\n</li>\n<li><p>可以跨越页面刷新而存在 ( <strong>不是跨越会话</strong> )</p>\n</li>\n<li><p>如果浏览器支持，浏览器崩溃重启之后依然可以使用 ( Ff 和 Webkit 支持, IE 不行 )</p>\n</li>\n<li><p>sessionStorage 对象绑定于某个服务器会话。( 文件本地运行不可用 )</p>\n</li>\n<li><p>存储在它里面的数据只能由最初给对象存储数据的页面访问到，所以对 <strong>多页面</strong> 应用有限制</p>\n</li>\n<li><p>由于它是 Storage 的一个实例，所以可以用 setItem() 或者直接设置新的属性来存储数据</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用方法存储数据</div><div class=\"line\">sessionStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性存储数据</div><div class=\"line\">sessionStorage.book = &quot;Professional JavaScript&quot;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>不同浏览器写入数据方面略有不同。Ff 和 Webkit 同步写入， IE  异步写入。 所以，IE 在设置数据和将数据实际写入磁盘之间可能会有一些延迟, 但是它会更快的回复执行。</p>\n</li>\n<li><p>IE8 中可以强制把数据写入磁盘： 在设置新数据前使用 begin() , 在所有设置完了后调用 commit() 。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sessionStorage.begin();</div><div class=\"line\">sessionStorage.name = &quot;Nicholas&quot;;</div><div class=\"line\">sessionStorage.book = &quot;Professional JavaScript&quot;;</div><div class=\"line\">sessionStorage.commit();</div></pre></td></tr></table></figure>\n<p>这样就确保 name book 在调用 commit() 后被立刻写入了磁盘。 begin() 是确保在这段代码执行的时候不会有其他磁盘写入操作。</p>\n<ul>\n<li><p>读取数据可以使用 getItem() 或 通过直接访问属性名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用方法获取</div><div class=\"line\">var name = sessionStorage.getItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性读取</div><div class=\"line\">var book = sessionStorage.book;</div></pre></td></tr></table></figure>\n</li>\n<li><p>迭代</p>\n<ul>\n<li>通过 length 和 key()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0, len = sessionStorage.length(); i &lt; len; i++) &#123;</div><div class=\"line\">  var key = sessionStorage.key(i);</div><div class=\"line\">  var value = sessionStorage.getItem(key);</div><div class=\"line\">  alert(key + &quot;=&quot; + value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>- 通过 for  in\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var key in sessionStorage) &#123;</div><div class=\"line\">  var value = sessionStorage.getItem(key);</div><div class=\"line\">  alert(key + &quot;=&quot; + value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>删除</p>\n<ul>\n<li>delete 操作符</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Webkit 中无效</div><div class=\"line\">delete sessionStorage.name</div></pre></td></tr></table></figure>\n<pre><code>- removeItem()\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// removeItem()</div><div class=\"line\">sessionStorage.removeItem(&apos;book&apos;);</div></pre></td></tr></table></figure>\n<h5 id=\"globalStorage-对象\"><a href=\"#globalStorage-对象\" class=\"headerlink\" title=\"globalStorage 对象\"></a>globalStorage 对象</h5><pre><code>- 目的是实现跨越会话的存储数据，但是有特定的访问权限\n\n- 使用之前先指定哪些域可以访问该数据。( 通过方括号标记使用属性实现 )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 保存数据</div><div class=\"line\">globalStorage[&quot;wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\"></div><div class=\"line\">// 获取数据</div><div class=\"line\">var name = globalStorage[&quot;wrox.com&quot;].name;</div></pre></td></tr></table></figure>\n<p>上面是针对 wrox.com 的存储空间。对于  wrox.com 和 它的子域都是可访问的</p>\n<pre><code>- globalStorage 对象 __不是  Storage 的实例__\n- globalStorage[&quot;wrox.com&quot;] 才是\n\n- 可以这样限制只有 子域名 www.wrox.com 可访问\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 保存数据</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\"></div><div class=\"line\">// 获取数据</div><div class=\"line\">var name = globalStorage[&quot;www.wrox.com&quot;].name;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>对于 globalStorage<br>空间的访问，是依据发起请求的页面的 <strong>域名，协议，端口</strong> 来限制的。</p>\n<p>比如：</p>\n<p>通过 HTTP 不能访问 通过 HTTPS 存储的数据</p>\n<p>端口不同，不能访问</p>\n</li>\n<li><p><strong>globalStorage 的每个属性都是 Storage 的实例</strong></p>\n<p>可以这样子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].book = &quot;Professional JavaScript&quot;;</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].removeItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">var book = globalStorage[&quot;www.wrox.com&quot;].getItem(&quot;book&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>当不能确定域名的时候 用 location.host</p>\n</li>\n<li><p>若不使用 removeItem() / delete 删除，或 用户未清除缓存， globalStorage 里的数据会一直保留在磁盘上</p>\n</li>\n</ul>\n<h5 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h5><h2 id=\"localStorage-在-HTML5-规范中作为-持久保存-客户端数据的方案取代了-globalStorage\"><a href=\"#localStorage-在-HTML5-规范中作为-持久保存-客户端数据的方案取代了-globalStorage\" class=\"headerlink\" title=\"  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage\"></a>  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage</h2><ul>\n<li><p>localStorage 不能指定任何访问规则。</p>\n</li>\n<li><p>要访问同一个 localStorage 对象， 页面必须来自同一个域名，使用同一个端口，在同一个协议下 ( 相当于 globalStorage[location.host] )</p>\n</li>\n<li><p>localStorage 是 Storage 的实例，可以像使用 sessionStorage 一样来使用它</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // 使用方法存储数据</div><div class=\"line\"> localStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性存储数据</div><div class=\"line\"> localStorage.book = &quot;Professional JavaScript&quot;;</div><div class=\"line\"></div><div class=\"line\"> //  使用方法 读取数据</div><div class=\"line\"> var name = localStorage.getItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\"> // 使用属性读取数据</div><div class=\"line\"> var book = localStorage.book;</div></pre></td></tr></table></figure>\n<ul>\n<li>存储在 localStorage 中的数据和存储在 globalStorage 中的数据一样， <strong>数据保留到通过 JS 删除，或者用户清除缓存  </strong></li>\n</ul>\n<h5 id=\"storage-事件\"><a href=\"#storage-事件\" class=\"headerlink\" title=\"storage 事件\"></a>storage 事件</h5><p>  对 storage 对象进行任何修改，都会在文档上触发 storage 事件。</p>\n<p>  这个事件的 event 对象有以下几个属性</p>\n<pre><code>+ domain&apos;:&apos; 发生变化的存储空间的域名\n+ key&apos;&apos;:&apos;&apos; 设置或者删除的键名\n+ newValue&apos;:&apos; 如果是设置值，则是新值; 如果是删除键，则是 null\n+ oldValue&apos;:&apos; 键被更改之前的值\n</code></pre><p>  其中 IE8 和 Ff 只实现了 domain 属性。 webkit 尚不支持 storage 事件。</p>\n<h5 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h5><ul>\n<li><p>因浏览器而异</p>\n</li>\n<li><p>以每个 来源( 协议，端口，域 ) 为单位 ( 每个来源都有固定的空间 )</p>\n</li>\n<li><p>localStorage 多数为 5MB 限制， Chorme 和 Safari 是 2.5MB 限制。 IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。</p>\n</li>\n<li><p>sessionStorage， 有的没有限制，  Chorme 和 Safari , IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。<br>IE8+ 和 Opera 是 5MB</p>\n</li>\n</ul>\n<p>–<br>参考 :</p>\n<p>  JavaScript 高级程序设计</p>\n","excerpt":"<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><ul>\n<li><p>提供一种在 cookie 之外存储会话数据的途径。</p>\n</li>\n<li><p>提供一种存储大量可以跨会话存在的数据机制。</p>\n</li>\n</ul>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p>最初的 Web Storage 规范包含了两种对象的定义： sessionStorage 和 globalStorage。 它们是以 window  的对象属性的形式存在的。</p>\n<h5 id=\"Storage-类型\"><a href=\"#Storage-类型\" class=\"headerlink\" title=\"Storage 类型\"></a>Storage 类型</h5><p>  Storage 类型提供最大的存储空间, 来存储名值对。( 只能存储字符串，非字符串会在存储前转换成字符串 )<br>","more":"</p>\n<p>  Storage 的实例与其他对象类似，有如下方法。</p>\n<ul>\n<li><p>clear(): 删除所有值; Ff 中没有实现</p>\n</li>\n<li><p>getItem(name): 根据指定的名字 name 获取对应的值</p>\n</li>\n<li><p>key(index): 获取 index 位置处的值的名字</p>\n</li>\n<li><p>removeItem(name, value): 删除由 name 指定的名值对</p>\n</li>\n<li><p>setItem(name, value): 为指定的 name 设置一个对应的值</p>\n</li>\n</ul>\n<p>其中， getItem(), removeItem(), setItem() 方法可以直接调用，也可以通过 Storage 对象间接调用。</p>\n<p>因为每个项目都是作为属性存储在该对象上的，所以可以通过 点语法 或者 方括号 访问属性来读取，设置值，或 通过 delete 来删除值。 ( <strong>不建议</strong> )</p>\n<p>我们还可以用 <strong>length</strong> 属性来判断有多少名值对，但无法判断所有数据的大小。( IE8 提供了 remainingSpace 属性，用于获取还可以使用的存储空间的字节数 )</p>\n<h5 id=\"sessionStorage-对象-Storage-的一个实例\"><a href=\"#sessionStorage-对象-Storage-的一个实例\" class=\"headerlink\" title=\"sessionStorage 对象 ( Storage 的一个实例 )\"></a>sessionStorage 对象 ( Storage 的一个实例 )</h5><ul>\n<li><p>存储特定于每个会话的数据 ( 即该数据只保持到 <strong>浏览器</strong> 关闭 )</p>\n</li>\n<li><p>可以跨越页面刷新而存在 ( <strong>不是跨越会话</strong> )</p>\n</li>\n<li><p>如果浏览器支持，浏览器崩溃重启之后依然可以使用 ( Ff 和 Webkit 支持, IE 不行 )</p>\n</li>\n<li><p>sessionStorage 对象绑定于某个服务器会话。( 文件本地运行不可用 )</p>\n</li>\n<li><p>存储在它里面的数据只能由最初给对象存储数据的页面访问到，所以对 <strong>多页面</strong> 应用有限制</p>\n</li>\n<li><p>由于它是 Storage 的一个实例，所以可以用 setItem() 或者直接设置新的属性来存储数据</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用方法存储数据</div><div class=\"line\">sessionStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性存储数据</div><div class=\"line\">sessionStorage.book = &quot;Professional JavaScript&quot;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>不同浏览器写入数据方面略有不同。Ff 和 Webkit 同步写入， IE  异步写入。 所以，IE 在设置数据和将数据实际写入磁盘之间可能会有一些延迟, 但是它会更快的回复执行。</p>\n</li>\n<li><p>IE8 中可以强制把数据写入磁盘： 在设置新数据前使用 begin() , 在所有设置完了后调用 commit() 。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sessionStorage.begin();</div><div class=\"line\">sessionStorage.name = &quot;Nicholas&quot;;</div><div class=\"line\">sessionStorage.book = &quot;Professional JavaScript&quot;;</div><div class=\"line\">sessionStorage.commit();</div></pre></td></tr></table></figure>\n<p>这样就确保 name book 在调用 commit() 后被立刻写入了磁盘。 begin() 是确保在这段代码执行的时候不会有其他磁盘写入操作。</p>\n<ul>\n<li><p>读取数据可以使用 getItem() 或 通过直接访问属性名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用方法获取</div><div class=\"line\">var name = sessionStorage.getItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性读取</div><div class=\"line\">var book = sessionStorage.book;</div></pre></td></tr></table></figure>\n</li>\n<li><p>迭代</p>\n<ul>\n<li>通过 length 和 key()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0, len = sessionStorage.length(); i &lt; len; i++) &#123;</div><div class=\"line\">  var key = sessionStorage.key(i);</div><div class=\"line\">  var value = sessionStorage.getItem(key);</div><div class=\"line\">  alert(key + &quot;=&quot; + value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>- 通过 for  in\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var key in sessionStorage) &#123;</div><div class=\"line\">  var value = sessionStorage.getItem(key);</div><div class=\"line\">  alert(key + &quot;=&quot; + value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>删除</p>\n<ul>\n<li>delete 操作符</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Webkit 中无效</div><div class=\"line\">delete sessionStorage.name</div></pre></td></tr></table></figure>\n<pre><code>- removeItem()\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// removeItem()</div><div class=\"line\">sessionStorage.removeItem(&apos;book&apos;);</div></pre></td></tr></table></figure>\n<h5 id=\"globalStorage-对象\"><a href=\"#globalStorage-对象\" class=\"headerlink\" title=\"globalStorage 对象\"></a>globalStorage 对象</h5><pre><code>- 目的是实现跨越会话的存储数据，但是有特定的访问权限\n\n- 使用之前先指定哪些域可以访问该数据。( 通过方括号标记使用属性实现 )\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 保存数据</div><div class=\"line\">globalStorage[&quot;wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\"></div><div class=\"line\">// 获取数据</div><div class=\"line\">var name = globalStorage[&quot;wrox.com&quot;].name;</div></pre></td></tr></table></figure>\n<p>上面是针对 wrox.com 的存储空间。对于  wrox.com 和 它的子域都是可访问的</p>\n<pre><code>- globalStorage 对象 __不是  Storage 的实例__\n- globalStorage[&quot;wrox.com&quot;] 才是\n\n- 可以这样限制只有 子域名 www.wrox.com 可访问\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 保存数据</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\"></div><div class=\"line\">// 获取数据</div><div class=\"line\">var name = globalStorage[&quot;www.wrox.com&quot;].name;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>对于 globalStorage<br>空间的访问，是依据发起请求的页面的 <strong>域名，协议，端口</strong> 来限制的。</p>\n<p>比如：</p>\n<p>通过 HTTP 不能访问 通过 HTTPS 存储的数据</p>\n<p>端口不同，不能访问</p>\n</li>\n<li><p><strong>globalStorage 的每个属性都是 Storage 的实例</strong></p>\n<p>可以这样子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].name = &quot;Nicholas&quot;;</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].book = &quot;Professional JavaScript&quot;;</div><div class=\"line\">globalStorage[&quot;www.wrox.com&quot;].removeItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">var book = globalStorage[&quot;www.wrox.com&quot;].getItem(&quot;book&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>当不能确定域名的时候 用 location.host</p>\n</li>\n<li><p>若不使用 removeItem() / delete 删除，或 用户未清除缓存， globalStorage 里的数据会一直保留在磁盘上</p>\n</li>\n</ul>\n<h5 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h5><h2 id=\"localStorage-在-HTML5-规范中作为-持久保存-客户端数据的方案取代了-globalStorage\"><a href=\"#localStorage-在-HTML5-规范中作为-持久保存-客户端数据的方案取代了-globalStorage\" class=\"headerlink\" title=\"  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage\"></a>  localStorage 在 HTML5 规范中作为 持久保存 客户端数据的方案取代了 globalStorage</h2><ul>\n<li><p>localStorage 不能指定任何访问规则。</p>\n</li>\n<li><p>要访问同一个 localStorage 对象， 页面必须来自同一个域名，使用同一个端口，在同一个协议下 ( 相当于 globalStorage[location.host] )</p>\n</li>\n<li><p>localStorage 是 Storage 的实例，可以像使用 sessionStorage 一样来使用它</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // 使用方法存储数据</div><div class=\"line\"> localStorage.setItem(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 使用属性存储数据</div><div class=\"line\"> localStorage.book = &quot;Professional JavaScript&quot;;</div><div class=\"line\"></div><div class=\"line\"> //  使用方法 读取数据</div><div class=\"line\"> var name = localStorage.getItem(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\"> // 使用属性读取数据</div><div class=\"line\"> var book = localStorage.book;</div></pre></td></tr></table></figure>\n<ul>\n<li>存储在 localStorage 中的数据和存储在 globalStorage 中的数据一样， <strong>数据保留到通过 JS 删除，或者用户清除缓存  </strong></li>\n</ul>\n<h5 id=\"storage-事件\"><a href=\"#storage-事件\" class=\"headerlink\" title=\"storage 事件\"></a>storage 事件</h5><p>  对 storage 对象进行任何修改，都会在文档上触发 storage 事件。</p>\n<p>  这个事件的 event 对象有以下几个属性</p>\n<pre><code>+ domain&apos;:&apos; 发生变化的存储空间的域名\n+ key&apos;&apos;:&apos;&apos; 设置或者删除的键名\n+ newValue&apos;:&apos; 如果是设置值，则是新值; 如果是删除键，则是 null\n+ oldValue&apos;:&apos; 键被更改之前的值\n</code></pre><p>  其中 IE8 和 Ff 只实现了 domain 属性。 webkit 尚不支持 storage 事件。</p>\n<h5 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h5><ul>\n<li><p>因浏览器而异</p>\n</li>\n<li><p>以每个 来源( 协议，端口，域 ) 为单位 ( 每个来源都有固定的空间 )</p>\n</li>\n<li><p>localStorage 多数为 5MB 限制， Chorme 和 Safari 是 2.5MB 限制。 IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。</p>\n</li>\n<li><p>sessionStorage， 有的没有限制，  Chorme 和 Safari , IOS 版的 Safari , Android 版 Webkit 也是 2.5MB。<br>IE8+ 和 Opera 是 5MB</p>\n</li>\n</ul>\n<p>–<br>参考 :</p>\n<p>  JavaScript 高级程序设计</p>"},{"title":"React 优化","date":"2016-12-06T16:00:00.000Z","auto_spacing":true,"_content":"\n#### 背景\n\n这两天，把自己用 React 的第一项目小小重新改了下。其实我内心是有一点小拒绝的 。。。因为，通过这三个月的练手，这个项目和之后的一个小项目，加上我对第二个小项目重写了大概 3～4 遍，(至今还对它不是很满意 ),  我对 React 的这种思维方式及代码规范收集到了更多的知识。\n\n我是大概看了两三天的 API 然后找到一个实践教程 ( 不知道这么叫对不对...), _Hacking With React_ 。\n\n<!-- more-->\n\n然后就直接开始做项目了，刚开始的时候，我完全不知道从哪里下手，该怎么做，那个时候甚至不知道除了 state 和 props，别的变量在组件内声明是不是一个好的做法。因此，基本上全都用 state，也不知道用 componentShouldMount 来去除避免不需要的 Mount。\n\n导致的结果就是，整个组件的结构都一团糟，全是 state, 无用代码大概有 1/2 到 2/3。\n\n其实我也并不是不想整理，而是时间的问题，我是准备之后用它练手 Redux  ( 现在也就大概能初步上手的样子 )。但是，迫于无奈，我现在必须要稍微整理下 (准备找工作 )。\n\n这次整理，不动整体的组件的结构，只是将 components 的写法规整。\n\n\n#### 整理过程\n\n首先，因为当时是跟后端对接的，我在项目的最后把本来写在组件里的实例数据全删了。这个项目中，我还不会使用 mock  之类的，在我的电脑上搭了一个 nginx 起了一个服务器来返回数据 ( 里面是后端的代码 )。然后，这两天我用的时候，重新 pull 了一下代码，然后发现，数据只有一两个网页能用，别的都不能用，貌似后端后来之后又改过代码。尝试了多次，试了一下去找后端的代码，发现看不懂，遂弃。\n\n本来想拿 superagent-mock 做一个简单的数，又考虑希望直接可以放在网上浏览，所以最后决定直接在代码里面放数据 ( 主要放在 container 组件 )，生成静态页面就好了。\n\n然后，我从每个 container 组件入手，主要根据的 fetching 成功后的数据整理，大概将数据还原，然后再一个一个的组件的确认调整。\n\n数据通了我就可以调整代码了，主要的整理的有这几个点：\n\n1. 组件里的自定义 Function ( 方法 ) 都在 constructor 里绑定 this ( .bind(this) )\n\n2. 将大部分的变量 ( 属性 ) 移出 state，同样在 constructor 里声明 ( this.num = 0 之类 )。\n\n3. 其中还有一大部分的 state 来自 props，同样将它们大部分都移出 state。\n\n4. 将组件中用到上述两条中的 this.state.XXX, 改成相应正确调用的形式。\n\n5. 同样由于前两条，很多的 componentWillReceiveProps 和 componentWillUpdate 需要移出。\n\n6. 对于 render 里面很多写 this.state.XXX 和 this.props.XXX 情况，用 ES6解构赋值 const { n1,n2 } = this.state, 这种形式。\n\n7. map 函数中的 function(){}  ( 偶尔还会给后面 加 bind( this ) ), 改成箭头函数，同时去除 bind。\n\n8. 将里面大部分的用 let 声明的常量用 const 声明。\n\n9. 哦对，我之前一直都没有初始化 props, 需要的组件额后面加上 XXX.defaultProps, XXX.propTypes。\n\n10. 将某些 class componennt 改成 function component。\n\n11. 将某些注册监听滚动的组件，在 unmount 的时候解除监听。 ( 监听事件和解除监听事件这里不是很懂 )\n\n12. 将某些组件的 React.Component 改成 React.PureComponent ( 相比于 shouldComponentUnpadte 方便多～ )\n\n嗯，大概这一次就大概改这些吧～ \n\n更多的优化留给之后啦～\n\n\n__待优化的方向，__\n\n- 组件细分\n- load transtion 之类的，优化效果\n- eslint ( 好处多多 )\n- 数据 Immutable \n- Redux 用起来！\n- CSS module \n- class 命名\n\n其中，Redux 小试了一下，Css module 和 Immutable 都没有用过。\n\n\n---\n\n标记下： 我在调试的时候，在 Chrome React 的那个调试工具，发现有时候会多出几套 组件，就是相当于把现在的组件全复制了几份，不知道是哪里出的问题。。复现不了。。。\n\n\n\n\n{% blockquote %}\n#### 更多组件优化参考\n\n[React移动web极致优化](http://dev.qq.com/topic/579083d1c9da73584b02587d)\n\n[React：创建可维护、高性能的 UI 组件](http://www.ibm.com/developerworks/cn/web/wa-react-intro/)\n\n{% endblockquote %}\n \n\n","source":"_posts/React Review .md","raw":"---\ntitle: React 优化 \ndate: 2016-12-07\ncategories:\n- 编程\ntags:\n- 总结\nauto_spacing: true\n---\n\n#### 背景\n\n这两天，把自己用 React 的第一项目小小重新改了下。其实我内心是有一点小拒绝的 。。。因为，通过这三个月的练手，这个项目和之后的一个小项目，加上我对第二个小项目重写了大概 3～4 遍，(至今还对它不是很满意 ),  我对 React 的这种思维方式及代码规范收集到了更多的知识。\n\n我是大概看了两三天的 API 然后找到一个实践教程 ( 不知道这么叫对不对...), _Hacking With React_ 。\n\n<!-- more-->\n\n然后就直接开始做项目了，刚开始的时候，我完全不知道从哪里下手，该怎么做，那个时候甚至不知道除了 state 和 props，别的变量在组件内声明是不是一个好的做法。因此，基本上全都用 state，也不知道用 componentShouldMount 来去除避免不需要的 Mount。\n\n导致的结果就是，整个组件的结构都一团糟，全是 state, 无用代码大概有 1/2 到 2/3。\n\n其实我也并不是不想整理，而是时间的问题，我是准备之后用它练手 Redux  ( 现在也就大概能初步上手的样子 )。但是，迫于无奈，我现在必须要稍微整理下 (准备找工作 )。\n\n这次整理，不动整体的组件的结构，只是将 components 的写法规整。\n\n\n#### 整理过程\n\n首先，因为当时是跟后端对接的，我在项目的最后把本来写在组件里的实例数据全删了。这个项目中，我还不会使用 mock  之类的，在我的电脑上搭了一个 nginx 起了一个服务器来返回数据 ( 里面是后端的代码 )。然后，这两天我用的时候，重新 pull 了一下代码，然后发现，数据只有一两个网页能用，别的都不能用，貌似后端后来之后又改过代码。尝试了多次，试了一下去找后端的代码，发现看不懂，遂弃。\n\n本来想拿 superagent-mock 做一个简单的数，又考虑希望直接可以放在网上浏览，所以最后决定直接在代码里面放数据 ( 主要放在 container 组件 )，生成静态页面就好了。\n\n然后，我从每个 container 组件入手，主要根据的 fetching 成功后的数据整理，大概将数据还原，然后再一个一个的组件的确认调整。\n\n数据通了我就可以调整代码了，主要的整理的有这几个点：\n\n1. 组件里的自定义 Function ( 方法 ) 都在 constructor 里绑定 this ( .bind(this) )\n\n2. 将大部分的变量 ( 属性 ) 移出 state，同样在 constructor 里声明 ( this.num = 0 之类 )。\n\n3. 其中还有一大部分的 state 来自 props，同样将它们大部分都移出 state。\n\n4. 将组件中用到上述两条中的 this.state.XXX, 改成相应正确调用的形式。\n\n5. 同样由于前两条，很多的 componentWillReceiveProps 和 componentWillUpdate 需要移出。\n\n6. 对于 render 里面很多写 this.state.XXX 和 this.props.XXX 情况，用 ES6解构赋值 const { n1,n2 } = this.state, 这种形式。\n\n7. map 函数中的 function(){}  ( 偶尔还会给后面 加 bind( this ) ), 改成箭头函数，同时去除 bind。\n\n8. 将里面大部分的用 let 声明的常量用 const 声明。\n\n9. 哦对，我之前一直都没有初始化 props, 需要的组件额后面加上 XXX.defaultProps, XXX.propTypes。\n\n10. 将某些 class componennt 改成 function component。\n\n11. 将某些注册监听滚动的组件，在 unmount 的时候解除监听。 ( 监听事件和解除监听事件这里不是很懂 )\n\n12. 将某些组件的 React.Component 改成 React.PureComponent ( 相比于 shouldComponentUnpadte 方便多～ )\n\n嗯，大概这一次就大概改这些吧～ \n\n更多的优化留给之后啦～\n\n\n__待优化的方向，__\n\n- 组件细分\n- load transtion 之类的，优化效果\n- eslint ( 好处多多 )\n- 数据 Immutable \n- Redux 用起来！\n- CSS module \n- class 命名\n\n其中，Redux 小试了一下，Css module 和 Immutable 都没有用过。\n\n\n---\n\n标记下： 我在调试的时候，在 Chrome React 的那个调试工具，发现有时候会多出几套 组件，就是相当于把现在的组件全复制了几份，不知道是哪里出的问题。。复现不了。。。\n\n\n\n\n{% blockquote %}\n#### 更多组件优化参考\n\n[React移动web极致优化](http://dev.qq.com/topic/579083d1c9da73584b02587d)\n\n[React：创建可维护、高性能的 UI 组件](http://www.ibm.com/developerworks/cn/web/wa-react-intro/)\n\n{% endblockquote %}\n \n\n","slug":"React Review ","published":1,"updated":"2016-12-09T08:06:36.000Z","_id":"ciwfxj93o00078mra5nn0ff90","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>这两天，把自己用 React 的第一项目小小重新改了下。其实我内心是有一点小拒绝的 。。。因为，通过这三个月的练手，这个项目和之后的一个小项目，加上我对第二个小项目重写了大概 3～4 遍，(至今还对它不是很满意 ),  我对 React 的这种思维方式及代码规范收集到了更多的知识。</p>\n<p>我是大概看了两三天的 API 然后找到一个实践教程 ( 不知道这么叫对不对…), <em>Hacking With React</em> 。</p>\n<a id=\"more\"></a>\n<p>然后就直接开始做项目了，刚开始的时候，我完全不知道从哪里下手，该怎么做，那个时候甚至不知道除了 state 和 props，别的变量在组件内声明是不是一个好的做法。因此，基本上全都用 state，也不知道用 componentShouldMount 来去除避免不需要的 Mount。</p>\n<p>导致的结果就是，整个组件的结构都一团糟，全是 state, 无用代码大概有 1/2 到 2/3。</p>\n<p>其实我也并不是不想整理，而是时间的问题，我是准备之后用它练手 Redux  ( 现在也就大概能初步上手的样子 )。但是，迫于无奈，我现在必须要稍微整理下 (准备找工作 )。</p>\n<p>这次整理，不动整体的组件的结构，只是将 components 的写法规整。</p>\n<h4 id=\"整理过程\"><a href=\"#整理过程\" class=\"headerlink\" title=\"整理过程\"></a>整理过程</h4><p>首先，因为当时是跟后端对接的，我在项目的最后把本来写在组件里的实例数据全删了。这个项目中，我还不会使用 mock  之类的，在我的电脑上搭了一个 nginx 起了一个服务器来返回数据 ( 里面是后端的代码 )。然后，这两天我用的时候，重新 pull 了一下代码，然后发现，数据只有一两个网页能用，别的都不能用，貌似后端后来之后又改过代码。尝试了多次，试了一下去找后端的代码，发现看不懂，遂弃。</p>\n<p>本来想拿 superagent-mock 做一个简单的数，又考虑希望直接可以放在网上浏览，所以最后决定直接在代码里面放数据 ( 主要放在 container 组件 )，生成静态页面就好了。</p>\n<p>然后，我从每个 container 组件入手，主要根据的 fetching 成功后的数据整理，大概将数据还原，然后再一个一个的组件的确认调整。</p>\n<p>数据通了我就可以调整代码了，主要的整理的有这几个点：</p>\n<ol>\n<li><p>组件里的自定义 Function ( 方法 ) 都在 constructor 里绑定 this ( .bind(this) )</p>\n</li>\n<li><p>将大部分的变量 ( 属性 ) 移出 state，同样在 constructor 里声明 ( this.num = 0 之类 )。</p>\n</li>\n<li><p>其中还有一大部分的 state 来自 props，同样将它们大部分都移出 state。</p>\n</li>\n<li><p>将组件中用到上述两条中的 this.state.XXX, 改成相应正确调用的形式。</p>\n</li>\n<li><p>同样由于前两条，很多的 componentWillReceiveProps 和 componentWillUpdate 需要移出。</p>\n</li>\n<li><p>对于 render 里面很多写 this.state.XXX 和 this.props.XXX 情况，用 ES6解构赋值 const { n1,n2 } = this.state, 这种形式。</p>\n</li>\n<li><p>map 函数中的 function(){}  ( 偶尔还会给后面 加 bind( this ) ), 改成箭头函数，同时去除 bind。</p>\n</li>\n<li><p>将里面大部分的用 let 声明的常量用 const 声明。</p>\n</li>\n<li><p>哦对，我之前一直都没有初始化 props, 需要的组件额后面加上 XXX.defaultProps, XXX.propTypes。</p>\n</li>\n<li><p>将某些 class componennt 改成 function component。</p>\n</li>\n<li><p>将某些注册监听滚动的组件，在 unmount 的时候解除监听。 ( 监听事件和解除监听事件这里不是很懂 )</p>\n</li>\n<li><p>将某些组件的 React.Component 改成 React.PureComponent ( 相比于 shouldComponentUnpadte 方便多～ )</p>\n</li>\n</ol>\n<p>嗯，大概这一次就大概改这些吧～ </p>\n<p>更多的优化留给之后啦～</p>\n<p><strong>待优化的方向，</strong></p>\n<ul>\n<li>组件细分</li>\n<li>load transtion 之类的，优化效果</li>\n<li>eslint ( 好处多多 )</li>\n<li>数据 Immutable </li>\n<li>Redux 用起来！</li>\n<li>CSS module </li>\n<li>class 命名</li>\n</ul>\n<p>其中，Redux 小试了一下，Css module 和 Immutable 都没有用过。</p>\n<hr>\n<p>标记下： 我在调试的时候，在 Chrome React 的那个调试工具，发现有时候会多出几套 组件，就是相当于把现在的组件全复制了几份，不知道是哪里出的问题。。复现不了。。。</p>\n<blockquote><h4 id=\"更多组件优化参考\"><a href=\"#更多组件优化参考\" class=\"headerlink\" title=\"更多组件优化参考\"></a>更多组件优化参考</h4><p><a href=\"http://dev.qq.com/topic/579083d1c9da73584b02587d\" target=\"_blank\" rel=\"external\">React移动web极致优化</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/web/wa-react-intro/\" target=\"_blank\" rel=\"external\">React：创建可维护、高性能的 UI 组件</a></p>\n</blockquote>\n","excerpt":"<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>这两天，把自己用 React 的第一项目小小重新改了下。其实我内心是有一点小拒绝的 。。。因为，通过这三个月的练手，这个项目和之后的一个小项目，加上我对第二个小项目重写了大概 3～4 遍，(至今还对它不是很满意 ),  我对 React 的这种思维方式及代码规范收集到了更多的知识。</p>\n<p>我是大概看了两三天的 API 然后找到一个实践教程 ( 不知道这么叫对不对…), <em>Hacking With React</em> 。</p>","more":"<p>然后就直接开始做项目了，刚开始的时候，我完全不知道从哪里下手，该怎么做，那个时候甚至不知道除了 state 和 props，别的变量在组件内声明是不是一个好的做法。因此，基本上全都用 state，也不知道用 componentShouldMount 来去除避免不需要的 Mount。</p>\n<p>导致的结果就是，整个组件的结构都一团糟，全是 state, 无用代码大概有 1/2 到 2/3。</p>\n<p>其实我也并不是不想整理，而是时间的问题，我是准备之后用它练手 Redux  ( 现在也就大概能初步上手的样子 )。但是，迫于无奈，我现在必须要稍微整理下 (准备找工作 )。</p>\n<p>这次整理，不动整体的组件的结构，只是将 components 的写法规整。</p>\n<h4 id=\"整理过程\"><a href=\"#整理过程\" class=\"headerlink\" title=\"整理过程\"></a>整理过程</h4><p>首先，因为当时是跟后端对接的，我在项目的最后把本来写在组件里的实例数据全删了。这个项目中，我还不会使用 mock  之类的，在我的电脑上搭了一个 nginx 起了一个服务器来返回数据 ( 里面是后端的代码 )。然后，这两天我用的时候，重新 pull 了一下代码，然后发现，数据只有一两个网页能用，别的都不能用，貌似后端后来之后又改过代码。尝试了多次，试了一下去找后端的代码，发现看不懂，遂弃。</p>\n<p>本来想拿 superagent-mock 做一个简单的数，又考虑希望直接可以放在网上浏览，所以最后决定直接在代码里面放数据 ( 主要放在 container 组件 )，生成静态页面就好了。</p>\n<p>然后，我从每个 container 组件入手，主要根据的 fetching 成功后的数据整理，大概将数据还原，然后再一个一个的组件的确认调整。</p>\n<p>数据通了我就可以调整代码了，主要的整理的有这几个点：</p>\n<ol>\n<li><p>组件里的自定义 Function ( 方法 ) 都在 constructor 里绑定 this ( .bind(this) )</p>\n</li>\n<li><p>将大部分的变量 ( 属性 ) 移出 state，同样在 constructor 里声明 ( this.num = 0 之类 )。</p>\n</li>\n<li><p>其中还有一大部分的 state 来自 props，同样将它们大部分都移出 state。</p>\n</li>\n<li><p>将组件中用到上述两条中的 this.state.XXX, 改成相应正确调用的形式。</p>\n</li>\n<li><p>同样由于前两条，很多的 componentWillReceiveProps 和 componentWillUpdate 需要移出。</p>\n</li>\n<li><p>对于 render 里面很多写 this.state.XXX 和 this.props.XXX 情况，用 ES6解构赋值 const { n1,n2 } = this.state, 这种形式。</p>\n</li>\n<li><p>map 函数中的 function(){}  ( 偶尔还会给后面 加 bind( this ) ), 改成箭头函数，同时去除 bind。</p>\n</li>\n<li><p>将里面大部分的用 let 声明的常量用 const 声明。</p>\n</li>\n<li><p>哦对，我之前一直都没有初始化 props, 需要的组件额后面加上 XXX.defaultProps, XXX.propTypes。</p>\n</li>\n<li><p>将某些 class componennt 改成 function component。</p>\n</li>\n<li><p>将某些注册监听滚动的组件，在 unmount 的时候解除监听。 ( 监听事件和解除监听事件这里不是很懂 )</p>\n</li>\n<li><p>将某些组件的 React.Component 改成 React.PureComponent ( 相比于 shouldComponentUnpadte 方便多～ )</p>\n</li>\n</ol>\n<p>嗯，大概这一次就大概改这些吧～ </p>\n<p>更多的优化留给之后啦～</p>\n<p><strong>待优化的方向，</strong></p>\n<ul>\n<li>组件细分</li>\n<li>load transtion 之类的，优化效果</li>\n<li>eslint ( 好处多多 )</li>\n<li>数据 Immutable </li>\n<li>Redux 用起来！</li>\n<li>CSS module </li>\n<li>class 命名</li>\n</ul>\n<p>其中，Redux 小试了一下，Css module 和 Immutable 都没有用过。</p>\n<hr>\n<p>标记下： 我在调试的时候，在 Chrome React 的那个调试工具，发现有时候会多出几套 组件，就是相当于把现在的组件全复制了几份，不知道是哪里出的问题。。复现不了。。。</p>\n<blockquote><h4 id=\"更多组件优化参考\"><a href=\"#更多组件优化参考\" class=\"headerlink\" title=\"更多组件优化参考\"></a>更多组件优化参考</h4><p><a href=\"http://dev.qq.com/topic/579083d1c9da73584b02587d\">React移动web极致优化</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/web/wa-react-intro/\">React：创建可维护、高性能的 UI 组件</a></p>\n</blockquote>"},{"title":"从文章到网页的操作流程以及 CI 设置","_content":"\n记录一下,  才开始用的 CI 的流程，防止忘记～～\n\n现在的这个博客, github 上有两个库, 一个是源代码的库，包括写的草稿，hexo 的构建系统，各种插件，等。 另一个是发布的库，就是 hexo deploy 后的 public 的那部分。\n\n<!-- more -->\n同时本地也有对应的两个文件夹。\n\n流程：\n\n#### 本地操作\n\n1. 在本地的 源代码 库，写文章，做各种改动。然后，本地测试一下。\n\n2. 生成 public 的发布部分，然后将 public 部分，copy 到 public 文件夹下。\n\n3. 发布的库，确定一下无误， git push 到 github 上。\n\n####  CI 部分\n\n这一部分都已经配好了，不用我操作，就记录一下过程。\n\n1. 上一部分的 github 设置了一个 webhook, 当 push 了新的东西的时候, 就会给 CI 发一个 post\n\n2. CI 接收到了来自 github 的 post, 触发它开始运作，首先将这个仓库的代码 git pull 下来 ( 到服务器上的 dev 的文件夹 ), 然后在这里执行自定义命令\n\n3. 关于上一步，我是没有自定义命令，因为我不是很需要。( 我是直接跳到第 5 步 ) 一般来说这里都会有 测试，确保文件和代码在线上没有问题。\n\n4. 之后，应该还应该还有另一个 prod 的文件夹，当收到来自 dev 文件夹测试成功的消息后, 将某些文件 copy 来这个文件夹里。\n\n5. 设置 nginx 静态资源指向 prod 文件夹, 当 prod 里面的文件发生变化，网页的内容页就会变化。\n\n","source":"_posts/ci.md","raw":"---\ntitle: 从文章到网页的操作流程以及 CI 设置\ncategories:\n- 编程\ntags:\n- 记录\n- 操作\n- CI\n---\n\n记录一下,  才开始用的 CI 的流程，防止忘记～～\n\n现在的这个博客, github 上有两个库, 一个是源代码的库，包括写的草稿，hexo 的构建系统，各种插件，等。 另一个是发布的库，就是 hexo deploy 后的 public 的那部分。\n\n<!-- more -->\n同时本地也有对应的两个文件夹。\n\n流程：\n\n#### 本地操作\n\n1. 在本地的 源代码 库，写文章，做各种改动。然后，本地测试一下。\n\n2. 生成 public 的发布部分，然后将 public 部分，copy 到 public 文件夹下。\n\n3. 发布的库，确定一下无误， git push 到 github 上。\n\n####  CI 部分\n\n这一部分都已经配好了，不用我操作，就记录一下过程。\n\n1. 上一部分的 github 设置了一个 webhook, 当 push 了新的东西的时候, 就会给 CI 发一个 post\n\n2. CI 接收到了来自 github 的 post, 触发它开始运作，首先将这个仓库的代码 git pull 下来 ( 到服务器上的 dev 的文件夹 ), 然后在这里执行自定义命令\n\n3. 关于上一步，我是没有自定义命令，因为我不是很需要。( 我是直接跳到第 5 步 ) 一般来说这里都会有 测试，确保文件和代码在线上没有问题。\n\n4. 之后，应该还应该还有另一个 prod 的文件夹，当收到来自 dev 文件夹测试成功的消息后, 将某些文件 copy 来这个文件夹里。\n\n5. 设置 nginx 静态资源指向 prod 文件夹, 当 prod 里面的文件发生变化，网页的内容页就会变化。\n\n","slug":"ci","published":1,"date":"2016-12-04T13:10:01.000Z","updated":"2016-12-09T08:21:03.000Z","_id":"ciwfxj93w00098mrav765ea0k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下,  才开始用的 CI 的流程，防止忘记～～</p>\n<p>现在的这个博客, github 上有两个库, 一个是源代码的库，包括写的草稿，hexo 的构建系统，各种插件，等。 另一个是发布的库，就是 hexo deploy 后的 public 的那部分。</p>\n<a id=\"more\"></a>\n<p>同时本地也有对应的两个文件夹。</p>\n<p>流程：</p>\n<h4 id=\"本地操作\"><a href=\"#本地操作\" class=\"headerlink\" title=\"本地操作\"></a>本地操作</h4><ol>\n<li><p>在本地的 源代码 库，写文章，做各种改动。然后，本地测试一下。</p>\n</li>\n<li><p>生成 public 的发布部分，然后将 public 部分，copy 到 public 文件夹下。</p>\n</li>\n<li><p>发布的库，确定一下无误， git push 到 github 上。</p>\n</li>\n</ol>\n<h4 id=\"CI-部分\"><a href=\"#CI-部分\" class=\"headerlink\" title=\"CI 部分\"></a>CI 部分</h4><p>这一部分都已经配好了，不用我操作，就记录一下过程。</p>\n<ol>\n<li><p>上一部分的 github 设置了一个 webhook, 当 push 了新的东西的时候, 就会给 CI 发一个 post</p>\n</li>\n<li><p>CI 接收到了来自 github 的 post, 触发它开始运作，首先将这个仓库的代码 git pull 下来 ( 到服务器上的 dev 的文件夹 ), 然后在这里执行自定义命令</p>\n</li>\n<li><p>关于上一步，我是没有自定义命令，因为我不是很需要。( 我是直接跳到第 5 步 ) 一般来说这里都会有 测试，确保文件和代码在线上没有问题。</p>\n</li>\n<li><p>之后，应该还应该还有另一个 prod 的文件夹，当收到来自 dev 文件夹测试成功的消息后, 将某些文件 copy 来这个文件夹里。</p>\n</li>\n<li><p>设置 nginx 静态资源指向 prod 文件夹, 当 prod 里面的文件发生变化，网页的内容页就会变化。</p>\n</li>\n</ol>\n","excerpt":"<p>记录一下,  才开始用的 CI 的流程，防止忘记～～</p>\n<p>现在的这个博客, github 上有两个库, 一个是源代码的库，包括写的草稿，hexo 的构建系统，各种插件，等。 另一个是发布的库，就是 hexo deploy 后的 public 的那部分。</p>","more":"<p>同时本地也有对应的两个文件夹。</p>\n<p>流程：</p>\n<h4 id=\"本地操作\"><a href=\"#本地操作\" class=\"headerlink\" title=\"本地操作\"></a>本地操作</h4><ol>\n<li><p>在本地的 源代码 库，写文章，做各种改动。然后，本地测试一下。</p>\n</li>\n<li><p>生成 public 的发布部分，然后将 public 部分，copy 到 public 文件夹下。</p>\n</li>\n<li><p>发布的库，确定一下无误， git push 到 github 上。</p>\n</li>\n</ol>\n<h4 id=\"CI-部分\"><a href=\"#CI-部分\" class=\"headerlink\" title=\"CI 部分\"></a>CI 部分</h4><p>这一部分都已经配好了，不用我操作，就记录一下过程。</p>\n<ol>\n<li><p>上一部分的 github 设置了一个 webhook, 当 push 了新的东西的时候, 就会给 CI 发一个 post</p>\n</li>\n<li><p>CI 接收到了来自 github 的 post, 触发它开始运作，首先将这个仓库的代码 git pull 下来 ( 到服务器上的 dev 的文件夹 ), 然后在这里执行自定义命令</p>\n</li>\n<li><p>关于上一步，我是没有自定义命令，因为我不是很需要。( 我是直接跳到第 5 步 ) 一般来说这里都会有 测试，确保文件和代码在线上没有问题。</p>\n</li>\n<li><p>之后，应该还应该还有另一个 prod 的文件夹，当收到来自 dev 文件夹测试成功的消息后, 将某些文件 copy 来这个文件夹里。</p>\n</li>\n<li><p>设置 nginx 静态资源指向 prod 文件夹, 当 prod 里面的文件发生变化，网页的内容页就会变化。</p>\n</li>\n</ol>"},{"title":"闭包","auto_spacing":true,"_content":"\n\n### 基础知识\n\n - 闭包是指有权访问另一个函数作用域中的变量的函数。\n\n - 创建闭包的常见方式：在 一个函数内部创建另一个函数\n\n```\nfunction createComparisonFunction(propertyName) {\n    return function(obj1, obj2) {\n        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量\n        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量\n\n        if(v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\n\n```\n<!-- more -->\n如上面例子，内部函数访问了外部函数的变量，即使这个内部函数被返回了，在其他地方被调用了，依旧能访问外部变量 propertyName。\n\n - 为什么呢？\n\n   简单的说是因为内部函数的**作用域链**中包含了外部函数 createComparisonFunction 的作用域。\n\n\n#### 作用域链：\n\n  - 本质上是一个指向变量对象的指针列表。\n\n  - 当某个函数被调用的时候，会创建一个执行环境( execution context )及相应的作用域链。\n\n  - 然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象( activation object )。\n\n  - 在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位。。。。直至作用域链终点的全局执行环境。\n  - 无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。\n\n\n __为了了解调用函数后都发生了什么我们先从一个简单的例子下手：__\n\n```\nfunction compare(v1, v2) {\n    if(v1 < v2) {\n        return -1;\n    } else if (v1 > v2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nvar result = compare(5, 10);\n\n```\n\n当调用 compare() 时，会创建一个包含 arguments, v1, v2 的**活动对象**。 全局执行环境的变量对象（包含 compare() 和 result）在 compare() 执行环境的作用域链中处于第二位。\n\n\n**每个执行环境都有一个表示变量的对象 -- 变量对象**。全局执行环境的变量对象始终存在，而像 compare（） 函数这样的局部环境的变量对象，只在函数**执行过程**中存在。\n\n - 在**创建** compare() 函数时，会创建一个**预先**包含**全局变量对象**的作用域链，这个作用域链被保存在 内部的 **[[Scope]]** 属性中。\n\n - 当调用 compare() 时，会为函数创建一个执行环境，然后通过**复制 [[Scope]]** 属性中的对象**构建**起执行环境的**作用域链**。\n\n - 然后，又有一个**活动对象**（函数的变量对象）被创建并被**推入**执行环境作用域的前端。\n\n在上面的例子中，compare() 执行环境的作用域中包含两个变量对象：本地活动对象和全局变量对象。\n\n无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。\n\n##### 当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。\n\n\n在一个函数内部定义的函数将会包含（外部函数）的活动对象添加道它的作用域链中。 因此在第一个例子中，如下：\n\n```\nfunction createComparisonFunction(propertyName) {\n    return function(obj1, obj2) {\n        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量\n        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量\n\n        if(v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\n\n```\n\n在 createComparisonFunction() **内部定义**的**匿名函数**的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。\n\n在匿名函数从createComparisonFunction() 中返回后，它的作用域链被初始化为 **包含 createComparisonFunction() 函数的活动对象和全局变量对象**。\n\n这样匿名函数就可以访问在 在匿名函数从createComparisonFunction 中定义的变量了。\n\n更重要的是 createComparisonFunction 函数在执行完后，其活动对象也不会被销毁，因为\n匿名函数的作用域链仍然在引用这个活动对象。（也就是说，当createComparisonFunction 函数返回后，其执行环境的作用域链会被销毁，**==但他的活动对象留在了内存中==**，直到匿名函数被销毁。\n\n例如：\n```\n// 创建函数\nvar compareName = createComparisonFunction(\"name\");\n\n// 调用函数\nvar result = compareName({name:\"Nicholas\"}, {name: \"Greg\"});\n\n// 解除对匿名函数的引用 (以便释放内存)\ncompareName = null\n```\n**通过将 compareName = null 解除该函数的引用**，就等于通知垃圾回收例程将其清除。\n\n\n### 闭包与变量\n\n**作用域链这种机制引出一个值得注意的副作用： 闭包只能取得包含函数中任何变量的 **最后一个值**。 如下：\n\n```\nfunction createFunctions(){\n    var result = new Array();\n\n    for(var i =0; i<10; i++) {\n        result[i] = function(){\n            return i;\n        };\n    }\n\n    return result;\n}\n```\n\n这个函数会返回一个函数数组。\n\n表面上看应该返回的数组类似于 [0,1,2,3 ....] 这个样子的，但是实际上返回的是 **[10, 10, 10, 10 ...]** 这个样子的。\n\n因为**每个函数**的作用域链上都保存着createFunctions 函数的**活动对象**，所以他们都引用的是**同一个变量 i**。 当createFunctions 函数**返回**后， 变量 i 的值是 10。\n\n但是， 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：\n\n```\nfunction createFunctions(){\n    var result = new Array();\n\n    for(var i =0; i<10; i++) {\n        result[i] = (function(num){\n            return function(){\n                return num;\n            };\n        })(i);\n    }\n\n    return result;\n}\n```\n\n这样，每个函数就会返回各自不同的索引值了。\n\n在这个版本中，我们没有直接把闭包赋给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋给数组。 这个匿名函数有一个参数 num ,也就是最终函数要返回的值。\n\n在调用每个匿名函数时，我们传入了变量 i， **函数参数是按值传递的**，所以就会将变量 i 的当前值复制给 参数 num, 而在这个匿名函数的**内部**，又创建并返回了一个访问 num 的**闭包**。这样， result 数组中的**每个函数**都有自己 num 变量的一个**副本**，因此就可以返回各自不同的数值了。\n\n\n### 闭包中的 this\n\n- this 对象是在运行时基于函数的执行环境绑定的。\n- 全局函数中， this === window, 当函数被当作某个对象的方法调用时候， this 等于那个对象。\n- 匿名函数的执行环境具有全局性，因此其 this 对像，通常指向  window 。但由于编写闭包的方式不同，这一点可能不会那么明显。 如下：\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getNameFunc: function(){\n        return function(){\n          return this.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()()); // \"The Window\" 在非严格模式\n```\n- 调用 object.getNameFunc()() 会立即调用它返回的函数，结果就是返回一个字符串。 （ The Window ／ 全局 name 变量的值 )\n\n- **为什么匿名函数没有取得其外部作用域的 this ?**\n\n- 每个函数在被**调用**的时候都会**自动取得**两个特殊\n变量： **arguments 和 this**。\n\n- 内部函数在搜索这两个变量时，只会搜索到**其活动对象为止**，因此永远不可能直接访问到外部函数中的这两个变量。\n\n- 不过，如果把外部作用域中的 this 对象保存在一个闭包能够访问到的变量中，就可以让闭包访问该对象了。\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getNameFunc: function(){\n        var that = this;\n\n        return function(){\n          return that.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()()); // \"My Object\"\n```\n\n我们将  this 对象赋值给了一个名叫 that 的变量。所以在定义了闭包之后，闭包也可以访问这个变量。即使在函数返回了之后，that 也仍然引用着 object ，所以调用 object.getNameFunc()()就返回了 My Object.\n\n\n- 在几种特殊的情况下，this 的值可能会意外地改变。 比如：\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getName: function(){\n\n        return this.name;\n\n    }\n};\n\n```\n这里的 getName() 方法只简单地返回 this.name 的值。 以下是几种调用  object.getName() 的方式及各自的结果。\n\n```\nobject.getName(); // My Object\n\n(object.getName)(); // My Object\n\n(object.getName = object.getName)(); // \"The Window\" 严格模式\n\n```\n- 第一个：this.name 就是 object.name\n- 第二个：(object.name) 和 object.name 定义相同， 所以依旧返回 My Object\n- 第三个：代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不可能得到维持，所以返回 \"The Window\"\n\n### 闭包中的 内存泄漏\n\n如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。\n\n\n\n{% blockquote %}\n\n参考：\n\nJavaScript 高级程序设计\n\n[Javascript闭包——懂不懂由你，反正我是懂了](http://www.cnblogs.com/frankfang/archive/2011/08/03/2125663.html)\n\n[什么是闭包，我的理解](http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html)\n\n[什么是闭包，我的理解](http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html)\n\n[js中的闭包之我理解](http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html)\n\n[如何通俗易懂的解释javascript里面的‘闭包’？](https://www.zhihu.com/question/34547104)\n\n[高效使用 JavaScript 闭包](http://www.ibm.com/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html)\n\n{% endblockquote %}\n","source":"_posts/closure.md","raw":"---\ntitle: 闭包\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- JS 基础\nauto_spacing: true\n---\n\n\n### 基础知识\n\n - 闭包是指有权访问另一个函数作用域中的变量的函数。\n\n - 创建闭包的常见方式：在 一个函数内部创建另一个函数\n\n```\nfunction createComparisonFunction(propertyName) {\n    return function(obj1, obj2) {\n        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量\n        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量\n\n        if(v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\n\n```\n<!-- more -->\n如上面例子，内部函数访问了外部函数的变量，即使这个内部函数被返回了，在其他地方被调用了，依旧能访问外部变量 propertyName。\n\n - 为什么呢？\n\n   简单的说是因为内部函数的**作用域链**中包含了外部函数 createComparisonFunction 的作用域。\n\n\n#### 作用域链：\n\n  - 本质上是一个指向变量对象的指针列表。\n\n  - 当某个函数被调用的时候，会创建一个执行环境( execution context )及相应的作用域链。\n\n  - 然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象( activation object )。\n\n  - 在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位。。。。直至作用域链终点的全局执行环境。\n  - 无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。\n\n\n __为了了解调用函数后都发生了什么我们先从一个简单的例子下手：__\n\n```\nfunction compare(v1, v2) {\n    if(v1 < v2) {\n        return -1;\n    } else if (v1 > v2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nvar result = compare(5, 10);\n\n```\n\n当调用 compare() 时，会创建一个包含 arguments, v1, v2 的**活动对象**。 全局执行环境的变量对象（包含 compare() 和 result）在 compare() 执行环境的作用域链中处于第二位。\n\n\n**每个执行环境都有一个表示变量的对象 -- 变量对象**。全局执行环境的变量对象始终存在，而像 compare（） 函数这样的局部环境的变量对象，只在函数**执行过程**中存在。\n\n - 在**创建** compare() 函数时，会创建一个**预先**包含**全局变量对象**的作用域链，这个作用域链被保存在 内部的 **[[Scope]]** 属性中。\n\n - 当调用 compare() 时，会为函数创建一个执行环境，然后通过**复制 [[Scope]]** 属性中的对象**构建**起执行环境的**作用域链**。\n\n - 然后，又有一个**活动对象**（函数的变量对象）被创建并被**推入**执行环境作用域的前端。\n\n在上面的例子中，compare() 执行环境的作用域中包含两个变量对象：本地活动对象和全局变量对象。\n\n无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。\n\n##### 当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。\n\n\n在一个函数内部定义的函数将会包含（外部函数）的活动对象添加道它的作用域链中。 因此在第一个例子中，如下：\n\n```\nfunction createComparisonFunction(propertyName) {\n    return function(obj1, obj2) {\n        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量\n        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量\n\n        if(v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\n\n```\n\n在 createComparisonFunction() **内部定义**的**匿名函数**的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。\n\n在匿名函数从createComparisonFunction() 中返回后，它的作用域链被初始化为 **包含 createComparisonFunction() 函数的活动对象和全局变量对象**。\n\n这样匿名函数就可以访问在 在匿名函数从createComparisonFunction 中定义的变量了。\n\n更重要的是 createComparisonFunction 函数在执行完后，其活动对象也不会被销毁，因为\n匿名函数的作用域链仍然在引用这个活动对象。（也就是说，当createComparisonFunction 函数返回后，其执行环境的作用域链会被销毁，**==但他的活动对象留在了内存中==**，直到匿名函数被销毁。\n\n例如：\n```\n// 创建函数\nvar compareName = createComparisonFunction(\"name\");\n\n// 调用函数\nvar result = compareName({name:\"Nicholas\"}, {name: \"Greg\"});\n\n// 解除对匿名函数的引用 (以便释放内存)\ncompareName = null\n```\n**通过将 compareName = null 解除该函数的引用**，就等于通知垃圾回收例程将其清除。\n\n\n### 闭包与变量\n\n**作用域链这种机制引出一个值得注意的副作用： 闭包只能取得包含函数中任何变量的 **最后一个值**。 如下：\n\n```\nfunction createFunctions(){\n    var result = new Array();\n\n    for(var i =0; i<10; i++) {\n        result[i] = function(){\n            return i;\n        };\n    }\n\n    return result;\n}\n```\n\n这个函数会返回一个函数数组。\n\n表面上看应该返回的数组类似于 [0,1,2,3 ....] 这个样子的，但是实际上返回的是 **[10, 10, 10, 10 ...]** 这个样子的。\n\n因为**每个函数**的作用域链上都保存着createFunctions 函数的**活动对象**，所以他们都引用的是**同一个变量 i**。 当createFunctions 函数**返回**后， 变量 i 的值是 10。\n\n但是， 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：\n\n```\nfunction createFunctions(){\n    var result = new Array();\n\n    for(var i =0; i<10; i++) {\n        result[i] = (function(num){\n            return function(){\n                return num;\n            };\n        })(i);\n    }\n\n    return result;\n}\n```\n\n这样，每个函数就会返回各自不同的索引值了。\n\n在这个版本中，我们没有直接把闭包赋给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋给数组。 这个匿名函数有一个参数 num ,也就是最终函数要返回的值。\n\n在调用每个匿名函数时，我们传入了变量 i， **函数参数是按值传递的**，所以就会将变量 i 的当前值复制给 参数 num, 而在这个匿名函数的**内部**，又创建并返回了一个访问 num 的**闭包**。这样， result 数组中的**每个函数**都有自己 num 变量的一个**副本**，因此就可以返回各自不同的数值了。\n\n\n### 闭包中的 this\n\n- this 对象是在运行时基于函数的执行环境绑定的。\n- 全局函数中， this === window, 当函数被当作某个对象的方法调用时候， this 等于那个对象。\n- 匿名函数的执行环境具有全局性，因此其 this 对像，通常指向  window 。但由于编写闭包的方式不同，这一点可能不会那么明显。 如下：\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getNameFunc: function(){\n        return function(){\n          return this.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()()); // \"The Window\" 在非严格模式\n```\n- 调用 object.getNameFunc()() 会立即调用它返回的函数，结果就是返回一个字符串。 （ The Window ／ 全局 name 变量的值 )\n\n- **为什么匿名函数没有取得其外部作用域的 this ?**\n\n- 每个函数在被**调用**的时候都会**自动取得**两个特殊\n变量： **arguments 和 this**。\n\n- 内部函数在搜索这两个变量时，只会搜索到**其活动对象为止**，因此永远不可能直接访问到外部函数中的这两个变量。\n\n- 不过，如果把外部作用域中的 this 对象保存在一个闭包能够访问到的变量中，就可以让闭包访问该对象了。\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getNameFunc: function(){\n        var that = this;\n\n        return function(){\n          return that.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()()); // \"My Object\"\n```\n\n我们将  this 对象赋值给了一个名叫 that 的变量。所以在定义了闭包之后，闭包也可以访问这个变量。即使在函数返回了之后，that 也仍然引用着 object ，所以调用 object.getNameFunc()()就返回了 My Object.\n\n\n- 在几种特殊的情况下，this 的值可能会意外地改变。 比如：\n\n```\nvar name = \"The Window\";\n\nvar object = {\n    name: \"My Object\",\n\n    getName: function(){\n\n        return this.name;\n\n    }\n};\n\n```\n这里的 getName() 方法只简单地返回 this.name 的值。 以下是几种调用  object.getName() 的方式及各自的结果。\n\n```\nobject.getName(); // My Object\n\n(object.getName)(); // My Object\n\n(object.getName = object.getName)(); // \"The Window\" 严格模式\n\n```\n- 第一个：this.name 就是 object.name\n- 第二个：(object.name) 和 object.name 定义相同， 所以依旧返回 My Object\n- 第三个：代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不可能得到维持，所以返回 \"The Window\"\n\n### 闭包中的 内存泄漏\n\n如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。\n\n\n\n{% blockquote %}\n\n参考：\n\nJavaScript 高级程序设计\n\n[Javascript闭包——懂不懂由你，反正我是懂了](http://www.cnblogs.com/frankfang/archive/2011/08/03/2125663.html)\n\n[什么是闭包，我的理解](http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html)\n\n[什么是闭包，我的理解](http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html)\n\n[js中的闭包之我理解](http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html)\n\n[如何通俗易懂的解释javascript里面的‘闭包’？](https://www.zhihu.com/question/34547104)\n\n[高效使用 JavaScript 闭包](http://www.ibm.com/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html)\n\n{% endblockquote %}\n","slug":"closure","published":1,"date":"2016-12-05T06:17:38.000Z","updated":"2016-12-10T06:49:51.000Z","_id":"ciwfxj944000b8mraewjwm2tj","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><ul>\n<li><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</li>\n<li><p>创建闭包的常见方式：在 一个函数内部创建另一个函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createComparisonFunction(propertyName) &#123;</div><div class=\"line\">    return function(obj1, obj2) &#123;</div><div class=\"line\">        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\">        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\"></div><div class=\"line\">        if(v1 &lt; v2) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>如上面例子，内部函数访问了外部函数的变量，即使这个内部函数被返回了，在其他地方被调用了，依旧能访问外部变量 propertyName。</p>\n<ul>\n<li><p>为什么呢？</p>\n<p>简单的说是因为内部函数的<strong>作用域链</strong>中包含了外部函数 createComparisonFunction 的作用域。</p>\n</li>\n</ul>\n<h4 id=\"作用域链：\"><a href=\"#作用域链：\" class=\"headerlink\" title=\"作用域链：\"></a>作用域链：</h4><ul>\n<li><p>本质上是一个指向变量对象的指针列表。</p>\n</li>\n<li><p>当某个函数被调用的时候，会创建一个执行环境( execution context )及相应的作用域链。</p>\n</li>\n<li><p>然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象( activation object )。</p>\n</li>\n<li><p>在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位。。。。直至作用域链终点的全局执行环境。</p>\n</li>\n<li>无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。</li>\n</ul>\n<p> <strong>为了了解调用函数后都发生了什么我们先从一个简单的例子下手：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2) &#123;</div><div class=\"line\">    if(v1 &lt; v2) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var result = compare(5, 10);</div></pre></td></tr></table></figure>\n<p>当调用 compare() 时，会创建一个包含 arguments, v1, v2 的<strong>活动对象</strong>。 全局执行环境的变量对象（包含 compare() 和 result）在 compare() 执行环境的作用域链中处于第二位。</p>\n<p><strong>每个执行环境都有一个表示变量的对象 – 变量对象</strong>。全局执行环境的变量对象始终存在，而像 compare（） 函数这样的局部环境的变量对象，只在函数<strong>执行过程</strong>中存在。</p>\n<ul>\n<li><p>在<strong>创建</strong> compare() 函数时，会创建一个<strong>预先</strong>包含<strong>全局变量对象</strong>的作用域链，这个作用域链被保存在 内部的 <strong>[[Scope]]</strong> 属性中。</p>\n</li>\n<li><p>当调用 compare() 时，会为函数创建一个执行环境，然后通过<strong>复制 [[Scope]]</strong> 属性中的对象<strong>构建</strong>起执行环境的<strong>作用域链</strong>。</p>\n</li>\n<li><p>然后，又有一个<strong>活动对象</strong>（函数的变量对象）被创建并被<strong>推入</strong>执行环境作用域的前端。</p>\n</li>\n</ul>\n<p>在上面的例子中，compare() 执行环境的作用域中包含两个变量对象：本地活动对象和全局变量对象。</p>\n<p>无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。</p>\n<h5 id=\"当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。-但是，闭包不同。\"><a href=\"#当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。-但是，闭包不同。\" class=\"headerlink\" title=\"当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。\"></a>当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。</h5><p>在一个函数内部定义的函数将会包含（外部函数）的活动对象添加道它的作用域链中。 因此在第一个例子中，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createComparisonFunction(propertyName) &#123;</div><div class=\"line\">    return function(obj1, obj2) &#123;</div><div class=\"line\">        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\">        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\"></div><div class=\"line\">        if(v1 &lt; v2) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 createComparisonFunction() <strong>内部定义</strong>的<strong>匿名函数</strong>的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p>\n<p>在匿名函数从createComparisonFunction() 中返回后，它的作用域链被初始化为 <strong>包含 createComparisonFunction() 函数的活动对象和全局变量对象</strong>。</p>\n<p>这样匿名函数就可以访问在 在匿名函数从createComparisonFunction 中定义的变量了。</p>\n<p>更重要的是 createComparisonFunction 函数在执行完后，其活动对象也不会被销毁，因为<br>匿名函数的作用域链仍然在引用这个活动对象。（也就是说，当createComparisonFunction 函数返回后，其执行环境的作用域链会被销毁，<strong>==但他的活动对象留在了内存中==</strong>，直到匿名函数被销毁。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建函数</div><div class=\"line\">var compareName = createComparisonFunction(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">// 调用函数</div><div class=\"line\">var result = compareName(&#123;name:&quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div><div class=\"line\"></div><div class=\"line\">// 解除对匿名函数的引用 (以便释放内存)</div><div class=\"line\">compareName = null</div></pre></td></tr></table></figure></p>\n<p><strong>通过将 compareName = null 解除该函数的引用</strong>，就等于通知垃圾回收例程将其清除。</p>\n<h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p><strong>作用域链这种机制引出一个值得注意的副作用： 闭包只能取得包含函数中任何变量的 </strong>最后一个值**。 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\"></div><div class=\"line\">    for(var i =0; i&lt;10; i++) &#123;</div><div class=\"line\">        result[i] = function()&#123;</div><div class=\"line\">            return i;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数会返回一个函数数组。</p>\n<p>表面上看应该返回的数组类似于 [0,1,2,3 ….] 这个样子的，但是实际上返回的是 <strong>[10, 10, 10, 10 …]</strong> 这个样子的。</p>\n<p>因为<strong>每个函数</strong>的作用域链上都保存着createFunctions 函数的<strong>活动对象</strong>，所以他们都引用的是<strong>同一个变量 i</strong>。 当createFunctions 函数<strong>返回</strong>后， 变量 i 的值是 10。</p>\n<p>但是， 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\"></div><div class=\"line\">    for(var i =0; i&lt;10; i++) &#123;</div><div class=\"line\">        result[i] = (function(num)&#123;</div><div class=\"line\">            return function()&#123;</div><div class=\"line\">                return num;</div><div class=\"line\">            &#125;;</div><div class=\"line\">        &#125;)(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，每个函数就会返回各自不同的索引值了。</p>\n<p>在这个版本中，我们没有直接把闭包赋给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋给数组。 这个匿名函数有一个参数 num ,也就是最终函数要返回的值。</p>\n<p>在调用每个匿名函数时，我们传入了变量 i， <strong>函数参数是按值传递的</strong>，所以就会将变量 i 的当前值复制给 参数 num, 而在这个匿名函数的<strong>内部</strong>，又创建并返回了一个访问 num 的<strong>闭包</strong>。这样， result 数组中的<strong>每个函数</strong>都有自己 num 变量的一个<strong>副本</strong>，因此就可以返回各自不同的数值了。</p>\n<h3 id=\"闭包中的-this\"><a href=\"#闭包中的-this\" class=\"headerlink\" title=\"闭包中的 this\"></a>闭包中的 this</h3><ul>\n<li>this 对象是在运行时基于函数的执行环境绑定的。</li>\n<li>全局函数中， this === window, 当函数被当作某个对象的方法调用时候， this 等于那个对象。</li>\n<li>匿名函数的执行环境具有全局性，因此其 this 对像，通常指向  window 。但由于编写闭包的方式不同，这一点可能不会那么明显。 如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getNameFunc: function()&#123;</div><div class=\"line\">        return function()&#123;</div><div class=\"line\">          return this.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">alert(object.getNameFunc()()); // &quot;The Window&quot; 在非严格模式</div></pre></td></tr></table></figure>\n<ul>\n<li><p>调用 object.getNameFunc()() 会立即调用它返回的函数，结果就是返回一个字符串。 （ The Window ／ 全局 name 变量的值 )</p>\n</li>\n<li><p><strong>为什么匿名函数没有取得其外部作用域的 this ?</strong></p>\n</li>\n<li><p>每个函数在被<strong>调用</strong>的时候都会<strong>自动取得</strong>两个特殊<br>变量： <strong>arguments 和 this</strong>。</p>\n</li>\n<li><p>内部函数在搜索这两个变量时，只会搜索到<strong>其活动对象为止</strong>，因此永远不可能直接访问到外部函数中的这两个变量。</p>\n</li>\n<li><p>不过，如果把外部作用域中的 this 对象保存在一个闭包能够访问到的变量中，就可以让闭包访问该对象了。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getNameFunc: function()&#123;</div><div class=\"line\">        var that = this;</div><div class=\"line\"></div><div class=\"line\">        return function()&#123;</div><div class=\"line\">          return that.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">alert(object.getNameFunc()()); // &quot;My Object&quot;</div></pre></td></tr></table></figure>\n<p>我们将  this 对象赋值给了一个名叫 that 的变量。所以在定义了闭包之后，闭包也可以访问这个变量。即使在函数返回了之后，that 也仍然引用着 object ，所以调用 object.getNameFunc()()就返回了 My Object.</p>\n<ul>\n<li>在几种特殊的情况下，this 的值可能会意外地改变。 比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getName: function()&#123;</div><div class=\"line\"></div><div class=\"line\">        return this.name;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里的 getName() 方法只简单地返回 this.name 的值。 以下是几种调用  object.getName() 的方式及各自的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">object.getName(); // My Object</div><div class=\"line\"></div><div class=\"line\">(object.getName)(); // My Object</div><div class=\"line\"></div><div class=\"line\">(object.getName = object.getName)(); // &quot;The Window&quot; 严格模式</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个：this.name 就是 object.name</li>\n<li>第二个：(object.name) 和 object.name 定义相同， 所以依旧返回 My Object</li>\n<li>第三个：代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不可能得到维持，所以返回 “The Window”</li>\n</ul>\n<h3 id=\"闭包中的-内存泄漏\"><a href=\"#闭包中的-内存泄漏\" class=\"headerlink\" title=\"闭包中的 内存泄漏\"></a>闭包中的 内存泄漏</h3><p>如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。</p>\n<blockquote><p>参考：</p>\n<p>JavaScript 高级程序设计</p>\n<p><a href=\"http://www.cnblogs.com/frankfang/archive/2011/08/03/2125663.html\" target=\"_blank\" rel=\"external\">Javascript闭包——懂不懂由你，反正我是懂了</a></p>\n<p><a href=\"http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html\" target=\"_blank\" rel=\"external\">什么是闭包，我的理解</a></p>\n<p><a href=\"http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html\" target=\"_blank\" rel=\"external\">什么是闭包，我的理解</a></p>\n<p><a href=\"http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html\" target=\"_blank\" rel=\"external\">js中的闭包之我理解</a></p>\n<p><a href=\"https://www.zhihu.com/question/34547104\" target=\"_blank\" rel=\"external\">如何通俗易懂的解释javascript里面的‘闭包’？</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html\" target=\"_blank\" rel=\"external\">高效使用 JavaScript 闭包</a></p>\n</blockquote>\n","excerpt":"<h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><ul>\n<li><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n</li>\n<li><p>创建闭包的常见方式：在 一个函数内部创建另一个函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createComparisonFunction(propertyName) &#123;</div><div class=\"line\">    return function(obj1, obj2) &#123;</div><div class=\"line\">        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\">        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\"></div><div class=\"line\">        if(v1 &lt; v2) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>如上面例子，内部函数访问了外部函数的变量，即使这个内部函数被返回了，在其他地方被调用了，依旧能访问外部变量 propertyName。</p>\n<ul>\n<li><p>为什么呢？</p>\n<p>简单的说是因为内部函数的<strong>作用域链</strong>中包含了外部函数 createComparisonFunction 的作用域。</p>\n</li>\n</ul>\n<h4 id=\"作用域链：\"><a href=\"#作用域链：\" class=\"headerlink\" title=\"作用域链：\"></a>作用域链：</h4><ul>\n<li><p>本质上是一个指向变量对象的指针列表。</p>\n</li>\n<li><p>当某个函数被调用的时候，会创建一个执行环境( execution context )及相应的作用域链。</p>\n</li>\n<li><p>然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象( activation object )。</p>\n</li>\n<li><p>在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位。。。。直至作用域链终点的全局执行环境。</p>\n</li>\n<li>无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。</li>\n</ul>\n<p> <strong>为了了解调用函数后都发生了什么我们先从一个简单的例子下手：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2) &#123;</div><div class=\"line\">    if(v1 &lt; v2) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var result = compare(5, 10);</div></pre></td></tr></table></figure>\n<p>当调用 compare() 时，会创建一个包含 arguments, v1, v2 的<strong>活动对象</strong>。 全局执行环境的变量对象（包含 compare() 和 result）在 compare() 执行环境的作用域链中处于第二位。</p>\n<p><strong>每个执行环境都有一个表示变量的对象 – 变量对象</strong>。全局执行环境的变量对象始终存在，而像 compare（） 函数这样的局部环境的变量对象，只在函数<strong>执行过程</strong>中存在。</p>\n<ul>\n<li><p>在<strong>创建</strong> compare() 函数时，会创建一个<strong>预先</strong>包含<strong>全局变量对象</strong>的作用域链，这个作用域链被保存在 内部的 <strong>[[Scope]]</strong> 属性中。</p>\n</li>\n<li><p>当调用 compare() 时，会为函数创建一个执行环境，然后通过<strong>复制 [[Scope]]</strong> 属性中的对象<strong>构建</strong>起执行环境的<strong>作用域链</strong>。</p>\n</li>\n<li><p>然后，又有一个<strong>活动对象</strong>（函数的变量对象）被创建并被<strong>推入</strong>执行环境作用域的前端。</p>\n</li>\n</ul>\n<p>在上面的例子中，compare() 执行环境的作用域中包含两个变量对象：本地活动对象和全局变量对象。</p>\n<p>无论在什么时候函数访问一个变量的时候，就会从作用域链中搜索具有相应名字的变量。</p>\n<h5 id=\"当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。-但是，闭包不同。\"><a href=\"#当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。-但是，闭包不同。\" class=\"headerlink\" title=\"当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。\"></a>当函数执行完后，局部的活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。  但是，闭包不同。</h5><p>在一个函数内部定义的函数将会包含（外部函数）的活动对象添加道它的作用域链中。 因此在第一个例子中，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createComparisonFunction(propertyName) &#123;</div><div class=\"line\">    return function(obj1, obj2) &#123;</div><div class=\"line\">        var v1 = obj1[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\">        var v2 = obj2[propertyName]; // 这里两行访问了外部函数的变量</div><div class=\"line\"></div><div class=\"line\">        if(v1 &lt; v2) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125; else if (v1 &gt; v2) &#123;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 createComparisonFunction() <strong>内部定义</strong>的<strong>匿名函数</strong>的作用域链中，实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p>\n<p>在匿名函数从createComparisonFunction() 中返回后，它的作用域链被初始化为 <strong>包含 createComparisonFunction() 函数的活动对象和全局变量对象</strong>。</p>\n<p>这样匿名函数就可以访问在 在匿名函数从createComparisonFunction 中定义的变量了。</p>\n<p>更重要的是 createComparisonFunction 函数在执行完后，其活动对象也不会被销毁，因为<br>匿名函数的作用域链仍然在引用这个活动对象。（也就是说，当createComparisonFunction 函数返回后，其执行环境的作用域链会被销毁，<strong>==但他的活动对象留在了内存中==</strong>，直到匿名函数被销毁。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建函数</div><div class=\"line\">var compareName = createComparisonFunction(&quot;name&quot;);</div><div class=\"line\"></div><div class=\"line\">// 调用函数</div><div class=\"line\">var result = compareName(&#123;name:&quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div><div class=\"line\"></div><div class=\"line\">// 解除对匿名函数的引用 (以便释放内存)</div><div class=\"line\">compareName = null</div></pre></td></tr></table></figure></p>\n<p><strong>通过将 compareName = null 解除该函数的引用</strong>，就等于通知垃圾回收例程将其清除。</p>\n<h3 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h3><p><strong>作用域链这种机制引出一个值得注意的副作用： 闭包只能取得包含函数中任何变量的 </strong>最后一个值**。 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\"></div><div class=\"line\">    for(var i =0; i&lt;10; i++) &#123;</div><div class=\"line\">        result[i] = function()&#123;</div><div class=\"line\">            return i;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数会返回一个函数数组。</p>\n<p>表面上看应该返回的数组类似于 [0,1,2,3 ….] 这个样子的，但是实际上返回的是 <strong>[10, 10, 10, 10 …]</strong> 这个样子的。</p>\n<p>因为<strong>每个函数</strong>的作用域链上都保存着createFunctions 函数的<strong>活动对象</strong>，所以他们都引用的是<strong>同一个变量 i</strong>。 当createFunctions 函数<strong>返回</strong>后， 变量 i 的值是 10。</p>\n<p>但是， 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createFunctions()&#123;</div><div class=\"line\">    var result = new Array();</div><div class=\"line\"></div><div class=\"line\">    for(var i =0; i&lt;10; i++) &#123;</div><div class=\"line\">        result[i] = (function(num)&#123;</div><div class=\"line\">            return function()&#123;</div><div class=\"line\">                return num;</div><div class=\"line\">            &#125;;</div><div class=\"line\">        &#125;)(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，每个函数就会返回各自不同的索引值了。</p>\n<p>在这个版本中，我们没有直接把闭包赋给数组，而是定义了一个匿名函数，并将立即执行该函数的结果赋给数组。 这个匿名函数有一个参数 num ,也就是最终函数要返回的值。</p>\n<p>在调用每个匿名函数时，我们传入了变量 i， <strong>函数参数是按值传递的</strong>，所以就会将变量 i 的当前值复制给 参数 num, 而在这个匿名函数的<strong>内部</strong>，又创建并返回了一个访问 num 的<strong>闭包</strong>。这样， result 数组中的<strong>每个函数</strong>都有自己 num 变量的一个<strong>副本</strong>，因此就可以返回各自不同的数值了。</p>\n<h3 id=\"闭包中的-this\"><a href=\"#闭包中的-this\" class=\"headerlink\" title=\"闭包中的 this\"></a>闭包中的 this</h3><ul>\n<li>this 对象是在运行时基于函数的执行环境绑定的。</li>\n<li>全局函数中， this === window, 当函数被当作某个对象的方法调用时候， this 等于那个对象。</li>\n<li>匿名函数的执行环境具有全局性，因此其 this 对像，通常指向  window 。但由于编写闭包的方式不同，这一点可能不会那么明显。 如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getNameFunc: function()&#123;</div><div class=\"line\">        return function()&#123;</div><div class=\"line\">          return this.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">alert(object.getNameFunc()()); // &quot;The Window&quot; 在非严格模式</div></pre></td></tr></table></figure>\n<ul>\n<li><p>调用 object.getNameFunc()() 会立即调用它返回的函数，结果就是返回一个字符串。 （ The Window ／ 全局 name 变量的值 )</p>\n</li>\n<li><p><strong>为什么匿名函数没有取得其外部作用域的 this ?</strong></p>\n</li>\n<li><p>每个函数在被<strong>调用</strong>的时候都会<strong>自动取得</strong>两个特殊<br>变量： <strong>arguments 和 this</strong>。</p>\n</li>\n<li><p>内部函数在搜索这两个变量时，只会搜索到<strong>其活动对象为止</strong>，因此永远不可能直接访问到外部函数中的这两个变量。</p>\n</li>\n<li><p>不过，如果把外部作用域中的 this 对象保存在一个闭包能够访问到的变量中，就可以让闭包访问该对象了。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getNameFunc: function()&#123;</div><div class=\"line\">        var that = this;</div><div class=\"line\"></div><div class=\"line\">        return function()&#123;</div><div class=\"line\">          return that.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">alert(object.getNameFunc()()); // &quot;My Object&quot;</div></pre></td></tr></table></figure>\n<p>我们将  this 对象赋值给了一个名叫 that 的变量。所以在定义了闭包之后，闭包也可以访问这个变量。即使在函数返回了之后，that 也仍然引用着 object ，所以调用 object.getNameFunc()()就返回了 My Object.</p>\n<ul>\n<li>在几种特殊的情况下，this 的值可能会意外地改变。 比如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;</div><div class=\"line\"></div><div class=\"line\">var object = &#123;</div><div class=\"line\">    name: &quot;My Object&quot;,</div><div class=\"line\"></div><div class=\"line\">    getName: function()&#123;</div><div class=\"line\"></div><div class=\"line\">        return this.name;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里的 getName() 方法只简单地返回 this.name 的值。 以下是几种调用  object.getName() 的方式及各自的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">object.getName(); // My Object</div><div class=\"line\"></div><div class=\"line\">(object.getName)(); // My Object</div><div class=\"line\"></div><div class=\"line\">(object.getName = object.getName)(); // &quot;The Window&quot; 严格模式</div></pre></td></tr></table></figure>\n<ul>\n<li>第一个：this.name 就是 object.name</li>\n<li>第二个：(object.name) 和 object.name 定义相同， 所以依旧返回 My Object</li>\n<li>第三个：代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不可能得到维持，所以返回 “The Window”</li>\n</ul>\n<h3 id=\"闭包中的-内存泄漏\"><a href=\"#闭包中的-内存泄漏\" class=\"headerlink\" title=\"闭包中的 内存泄漏\"></a>闭包中的 内存泄漏</h3><p>如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。</p>\n<blockquote><p>参考：</p>\n<p>JavaScript 高级程序设计</p>\n<p><a href=\"http://www.cnblogs.com/frankfang/archive/2011/08/03/2125663.html\">Javascript闭包——懂不懂由你，反正我是懂了</a></p>\n<p><a href=\"http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html\">什么是闭包，我的理解</a></p>\n<p><a href=\"http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html\">什么是闭包，我的理解</a></p>\n<p><a href=\"http://www.cnblogs.com/mzwr1982/archive/2012/05/20/2509295.html\">js中的闭包之我理解</a></p>\n<p><a href=\"https://www.zhihu.com/question/34547104\">如何通俗易懂的解释javascript里面的‘闭包’？</a></p>\n<p><a href=\"http://www.ibm.com/developerworks/cn/web/wa-use-javascript-closures-efficiently/index.html\">高效使用 JavaScript 闭包</a></p>\n</blockquote>"},{"title":"执行上下文","auto_spacing":true,"_content":"#### 基础知识\n\n- 定义了变量或函数有权访问的其他数据，决定了它们各自的行为。\n\n- 每个执行环境都有一个与之关联的 **变量对象**，执行环境紫红定义的所有变量和函数都保存在这个对象中。\n\n- 全局执行环境是最外围的一个执行环境。（在 Web 浏览器中，全局环境是 window 对象，所以所有全局变量和函数都是作为 window 对象的属性和方法创建的 ）\n\n<!-- more -->\n\n- 某个执行环境中所有的代码执行完成后，该环境被销毁，其中的所有变量，函数定义也被销毁。\n\n- 每个函数都有自己的**执行环境**。当执行流进入一个函数的时候，函数的环境就会被推入到一个**环境栈**中，在函数执行完成后，栈将其环境弹出，把控制权返回给之前的执行环境。\n\n- 当代码在一个环境中执行的时候，会创建**变量对象**的一个**作用域链**。 \n\n- 作用域链的**作用**是保证对执行环境有权访问的所有变量和函数的**有序访问**。\n\n- 作用域链的**前端**，始终都是**当前执行**的代码所在的环境变量对象。\n\n- 如果这个环境是**函数**，则将其**活动对象**作为**变量对象**。\n\n- **活动对象** 最开始只包含一个变量，arguments 对象。\n\n- 作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含对象，这样，一直延续道全局执行环境。（全局执行环境的变量始终是作用域链中的最后一个对象）\n\n- 标识符解析是沿着作用域链一级一级地搜索标志符的过程。\n\n- 每个环境都可以向上搜索作用域链，查询变量和函数名，但任何环境都不能通过向下搜索作用域链而静如另一个执行环境。\n\n\n#### 延长作用域链 \n\nNOTE:! 这里不是很懂\n\n- try-catch 语句的 catch \n- with 语句\n\n这些语句可以在作用域链的前端添加一个变量对象。\n\n{% blockquote %}\n\n参考链接：\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n","source":"_posts/execution context.md","raw":"---\ntitle: 执行上下文\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- JS 基础\nauto_spacing: true\n---\n#### 基础知识\n\n- 定义了变量或函数有权访问的其他数据，决定了它们各自的行为。\n\n- 每个执行环境都有一个与之关联的 **变量对象**，执行环境紫红定义的所有变量和函数都保存在这个对象中。\n\n- 全局执行环境是最外围的一个执行环境。（在 Web 浏览器中，全局环境是 window 对象，所以所有全局变量和函数都是作为 window 对象的属性和方法创建的 ）\n\n<!-- more -->\n\n- 某个执行环境中所有的代码执行完成后，该环境被销毁，其中的所有变量，函数定义也被销毁。\n\n- 每个函数都有自己的**执行环境**。当执行流进入一个函数的时候，函数的环境就会被推入到一个**环境栈**中，在函数执行完成后，栈将其环境弹出，把控制权返回给之前的执行环境。\n\n- 当代码在一个环境中执行的时候，会创建**变量对象**的一个**作用域链**。 \n\n- 作用域链的**作用**是保证对执行环境有权访问的所有变量和函数的**有序访问**。\n\n- 作用域链的**前端**，始终都是**当前执行**的代码所在的环境变量对象。\n\n- 如果这个环境是**函数**，则将其**活动对象**作为**变量对象**。\n\n- **活动对象** 最开始只包含一个变量，arguments 对象。\n\n- 作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含对象，这样，一直延续道全局执行环境。（全局执行环境的变量始终是作用域链中的最后一个对象）\n\n- 标识符解析是沿着作用域链一级一级地搜索标志符的过程。\n\n- 每个环境都可以向上搜索作用域链，查询变量和函数名，但任何环境都不能通过向下搜索作用域链而静如另一个执行环境。\n\n\n#### 延长作用域链 \n\nNOTE:! 这里不是很懂\n\n- try-catch 语句的 catch \n- with 语句\n\n这些语句可以在作用域链的前端添加一个变量对象。\n\n{% blockquote %}\n\n参考链接：\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n","slug":"execution context","published":1,"date":"2016-12-05T06:31:38.000Z","updated":"2016-12-05T06:33:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj94b000f8mrazqqvhman","content":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><ul>\n<li><p>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>\n</li>\n<li><p>每个执行环境都有一个与之关联的 <strong>变量对象</strong>，执行环境紫红定义的所有变量和函数都保存在这个对象中。</p>\n</li>\n<li><p>全局执行环境是最外围的一个执行环境。（在 Web 浏览器中，全局环境是 window 对象，所以所有全局变量和函数都是作为 window 对象的属性和方法创建的 ）</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>某个执行环境中所有的代码执行完成后，该环境被销毁，其中的所有变量，函数定义也被销毁。</p>\n</li>\n<li><p>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数的时候，函数的环境就会被推入到一个<strong>环境栈</strong>中，在函数执行完成后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>\n</li>\n<li><p>当代码在一个环境中执行的时候，会创建<strong>变量对象</strong>的一个<strong>作用域链</strong>。 </p>\n</li>\n<li><p>作用域链的<strong>作用</strong>是保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong>。</p>\n</li>\n<li><p>作用域链的<strong>前端</strong>，始终都是<strong>当前执行</strong>的代码所在的环境变量对象。</p>\n</li>\n<li><p>如果这个环境是<strong>函数</strong>，则将其<strong>活动对象</strong>作为<strong>变量对象</strong>。</p>\n</li>\n<li><p><strong>活动对象</strong> 最开始只包含一个变量，arguments 对象。</p>\n</li>\n<li><p>作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含对象，这样，一直延续道全局执行环境。（全局执行环境的变量始终是作用域链中的最后一个对象）</p>\n</li>\n<li><p>标识符解析是沿着作用域链一级一级地搜索标志符的过程。</p>\n</li>\n<li><p>每个环境都可以向上搜索作用域链，查询变量和函数名，但任何环境都不能通过向下搜索作用域链而静如另一个执行环境。</p>\n</li>\n</ul>\n<h4 id=\"延长作用域链\"><a href=\"#延长作用域链\" class=\"headerlink\" title=\"延长作用域链\"></a>延长作用域链</h4><p>NOTE:! 这里不是很懂</p>\n<ul>\n<li>try-catch 语句的 catch </li>\n<li>with 语句</li>\n</ul>\n<p>这些语句可以在作用域链的前端添加一个变量对象。</p>\n<blockquote><p>参考链接：</p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>\n","excerpt":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><ul>\n<li><p>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>\n</li>\n<li><p>每个执行环境都有一个与之关联的 <strong>变量对象</strong>，执行环境紫红定义的所有变量和函数都保存在这个对象中。</p>\n</li>\n<li><p>全局执行环境是最外围的一个执行环境。（在 Web 浏览器中，全局环境是 window 对象，所以所有全局变量和函数都是作为 window 对象的属性和方法创建的 ）</p>\n</li>\n</ul>","more":"<ul>\n<li><p>某个执行环境中所有的代码执行完成后，该环境被销毁，其中的所有变量，函数定义也被销毁。</p>\n</li>\n<li><p>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数的时候，函数的环境就会被推入到一个<strong>环境栈</strong>中，在函数执行完成后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>\n</li>\n<li><p>当代码在一个环境中执行的时候，会创建<strong>变量对象</strong>的一个<strong>作用域链</strong>。 </p>\n</li>\n<li><p>作用域链的<strong>作用</strong>是保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong>。</p>\n</li>\n<li><p>作用域链的<strong>前端</strong>，始终都是<strong>当前执行</strong>的代码所在的环境变量对象。</p>\n</li>\n<li><p>如果这个环境是<strong>函数</strong>，则将其<strong>活动对象</strong>作为<strong>变量对象</strong>。</p>\n</li>\n<li><p><strong>活动对象</strong> 最开始只包含一个变量，arguments 对象。</p>\n</li>\n<li><p>作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含对象，这样，一直延续道全局执行环境。（全局执行环境的变量始终是作用域链中的最后一个对象）</p>\n</li>\n<li><p>标识符解析是沿着作用域链一级一级地搜索标志符的过程。</p>\n</li>\n<li><p>每个环境都可以向上搜索作用域链，查询变量和函数名，但任何环境都不能通过向下搜索作用域链而静如另一个执行环境。</p>\n</li>\n</ul>\n<h4 id=\"延长作用域链\"><a href=\"#延长作用域链\" class=\"headerlink\" title=\"延长作用域链\"></a>延长作用域链</h4><p>NOTE:! 这里不是很懂</p>\n<ul>\n<li>try-catch 语句的 catch </li>\n<li>with 语句</li>\n</ul>\n<p>这些语句可以在作用域链的前端添加一个变量对象。</p>\n<blockquote><p>参考链接：</p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>"},{"title":"应该有个开篇的","date":"2016-11-30T16:00:00.000Z","auto_spacing":true,"_content":"\n突然想起来应该有个开篇的，于是有了这篇～\n\n我一直想找个地方把一些东西记下来，一来是填补自己记忆力上的不足( 我是我们家最笨的了 )，二来是培养自己的总结能力。\n\n<!-- more -->\n\n之前有需要记得都是写在本子上的，想着好记性不如烂笔头 ( 况且我还没有好记性 ಠ_ರೃ _ )。 但是，没有一个固定的本子，所以一来二去就记得乱七八糟的。也经常一不小心就不知道把本子弄到哪里去了，于是渐渐地想要写下来的想法就越来越淡了。\n\n而且讲真，真是一直不喜欢写文章，各种文章。。。 一直以来，写作文是我最不喜欢的事，从来都是把这一类的作业放在最后来做。对于一个喜欢文学，喜欢写诗的老妈来说，我是在这一部分一点都没有继承下来。 不过对于物理，生物，数学这一类，我还是蛮喜欢。\n\n喜欢归喜欢，但是，大学后经过一些对比，我觉得有些人的思维真是特别适合做物理研究，而我，ಥ_ಥ。\n\n之前，也不太总结，所以自己的总结能力比较差，曾几次都想着要培养总结能力，后来总是没有然后。\n\n越来越知道总结是多么的重要。\n\n现在刚好开始这个博客，想借此机会把自己的总结能力提！上！去！！或许有些晚，但是至少在开始上升！而且不需要多快，稳步前进就可以了。\n\n期待我的未来会更美好～～～( ´ ▽ ` )ﾉ`)\n\n现在，从抄抄抄开始！！\n","source":"_posts/start.md","raw":"---\ntitle: 应该有个开篇的\ndate: 2016-12-01\ncategories:\n- 生活\ntags:\n- 开篇\nauto_spacing: true\n---\n\n突然想起来应该有个开篇的，于是有了这篇～\n\n我一直想找个地方把一些东西记下来，一来是填补自己记忆力上的不足( 我是我们家最笨的了 )，二来是培养自己的总结能力。\n\n<!-- more -->\n\n之前有需要记得都是写在本子上的，想着好记性不如烂笔头 ( 况且我还没有好记性 ಠ_ರೃ _ )。 但是，没有一个固定的本子，所以一来二去就记得乱七八糟的。也经常一不小心就不知道把本子弄到哪里去了，于是渐渐地想要写下来的想法就越来越淡了。\n\n而且讲真，真是一直不喜欢写文章，各种文章。。。 一直以来，写作文是我最不喜欢的事，从来都是把这一类的作业放在最后来做。对于一个喜欢文学，喜欢写诗的老妈来说，我是在这一部分一点都没有继承下来。 不过对于物理，生物，数学这一类，我还是蛮喜欢。\n\n喜欢归喜欢，但是，大学后经过一些对比，我觉得有些人的思维真是特别适合做物理研究，而我，ಥ_ಥ。\n\n之前，也不太总结，所以自己的总结能力比较差，曾几次都想着要培养总结能力，后来总是没有然后。\n\n越来越知道总结是多么的重要。\n\n现在刚好开始这个博客，想借此机会把自己的总结能力提！上！去！！或许有些晚，但是至少在开始上升！而且不需要多快，稳步前进就可以了。\n\n期待我的未来会更美好～～～( ´ ▽ ` )ﾉ`)\n\n现在，从抄抄抄开始！！\n","slug":"start","published":1,"updated":"2016-12-05T05:01:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj94e000h8mraap62291t","content":"<p>突然想起来应该有个开篇的，于是有了这篇～</p>\n<p>我一直想找个地方把一些东西记下来，一来是填补自己记忆力上的不足( 我是我们家最笨的了 )，二来是培养自己的总结能力。</p>\n<a id=\"more\"></a>\n<p>之前有需要记得都是写在本子上的，想着好记性不如烂笔头 ( 况且我还没有好记性 ಠ<em>ರೃ </em> )。 但是，没有一个固定的本子，所以一来二去就记得乱七八糟的。也经常一不小心就不知道把本子弄到哪里去了，于是渐渐地想要写下来的想法就越来越淡了。</p>\n<p>而且讲真，真是一直不喜欢写文章，各种文章。。。 一直以来，写作文是我最不喜欢的事，从来都是把这一类的作业放在最后来做。对于一个喜欢文学，喜欢写诗的老妈来说，我是在这一部分一点都没有继承下来。 不过对于物理，生物，数学这一类，我还是蛮喜欢。</p>\n<p>喜欢归喜欢，但是，大学后经过一些对比，我觉得有些人的思维真是特别适合做物理研究，而我，ಥ_ಥ。</p>\n<p>之前，也不太总结，所以自己的总结能力比较差，曾几次都想着要培养总结能力，后来总是没有然后。</p>\n<p>越来越知道总结是多么的重要。</p>\n<p>现在刚好开始这个博客，想借此机会把自己的总结能力提！上！去！！或许有些晚，但是至少在开始上升！而且不需要多快，稳步前进就可以了。</p>\n<p>期待我的未来会更美好～～～( ´ ▽ <code>)ﾉ</code>)</p>\n<p>现在，从抄抄抄开始！！</p>\n","excerpt":"<p>突然想起来应该有个开篇的，于是有了这篇～</p>\n<p>我一直想找个地方把一些东西记下来，一来是填补自己记忆力上的不足( 我是我们家最笨的了 )，二来是培养自己的总结能力。</p>","more":"<p>之前有需要记得都是写在本子上的，想着好记性不如烂笔头 ( 况且我还没有好记性 ಠ<em>ರೃ </em> )。 但是，没有一个固定的本子，所以一来二去就记得乱七八糟的。也经常一不小心就不知道把本子弄到哪里去了，于是渐渐地想要写下来的想法就越来越淡了。</p>\n<p>而且讲真，真是一直不喜欢写文章，各种文章。。。 一直以来，写作文是我最不喜欢的事，从来都是把这一类的作业放在最后来做。对于一个喜欢文学，喜欢写诗的老妈来说，我是在这一部分一点都没有继承下来。 不过对于物理，生物，数学这一类，我还是蛮喜欢。</p>\n<p>喜欢归喜欢，但是，大学后经过一些对比，我觉得有些人的思维真是特别适合做物理研究，而我，ಥ_ಥ。</p>\n<p>之前，也不太总结，所以自己的总结能力比较差，曾几次都想着要培养总结能力，后来总是没有然后。</p>\n<p>越来越知道总结是多么的重要。</p>\n<p>现在刚好开始这个博客，想借此机会把自己的总结能力提！上！去！！或许有些晚，但是至少在开始上升！而且不需要多快，稳步前进就可以了。</p>\n<p>期待我的未来会更美好～～～( ´ ▽ <code>)ﾉ</code>)</p>\n<p>现在，从抄抄抄开始！！</p>"},{"title":"nodeList","date":"2016-12-02T16:00:00.000Z","_content":"\n跟 querySelector 一块查到的 nodeList\n\n### 基本定义\n\nNodeList 对象是一个节点的集合，是由 __Node.childNodes__ 和 __document.querySelectorAll__ 返回的. (不是 Array)\n\n### 属性\n\n- length\n\n\n### 方法: item( idx )\n\n- 返回NodeList对象中指定索引的节点,如果索引越界,则返回null.等价的写法是nodeList[idx], 不过这种情况下越界访问将返回undefined.\n\n<!-- more -->\n\n### 其他\n\n- 大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。\n\n  + Node.childNodes 是实时的\n\n  + document.querySelectorAll 返回一个静态的 NodeList\n\n-  NodeList 不是数组:\n\n  + NodeList的原型链是这样的：\n\n  myNodeList --> NodeList.prototype --> Object.prototype --> null\n\n\n### 遍历一个 NodeList 对象的所有节点。\n\n +  for 循环\n\n```\nfor (var i = 0; i < myNodeList.length; ++i) {\n    var item = myNodeList[i];  // 调用 myNodeList.item(i) 是没有必要的\n}\n```\n+ 在支持 for...of 的浏览器中 for...of 循环将会正确的遍历 NodeList 对象：\n\n```\nvar list = document.querySelectorAll( 'input[type=checkbox]' );\nfor (var item of list) {\n    item.checked = true;\n}\n```\n\n+ 将 NodeList 转换为 Array ( 类数组的方式 )\n\n    ---类数组： 有length 属性\n\n```\nvar div_list = document.querySelectorAll('div'); // 返回 NodeList\nvar div_array = Array.prototype.slice.call(div_list); // 将 NodeList 转换为数组\n\n//更好的写法\n[].forEach.call(Nodelist,function(){})\n```\n\n__NOTE:__\n\n最好不要使用 for...in 或者 for each...in 。__\n\n- 它们会把 length 和 item 属性也遍历出来。\n\n- 而 for in 也不保证顺序\n\n\n{% blockquote %}\n\n参考链接:\n\n[MDN: NodeList](https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList)\n\n{% endblockquote %}\n\n","source":"_posts/nodelist.md","raw":"---\ntitle: nodeList\ncategories:\n- 编程\ntags:\n- DOM\n- 抄抄抄\ndate: 2016-12-03\n---\n\n跟 querySelector 一块查到的 nodeList\n\n### 基本定义\n\nNodeList 对象是一个节点的集合，是由 __Node.childNodes__ 和 __document.querySelectorAll__ 返回的. (不是 Array)\n\n### 属性\n\n- length\n\n\n### 方法: item( idx )\n\n- 返回NodeList对象中指定索引的节点,如果索引越界,则返回null.等价的写法是nodeList[idx], 不过这种情况下越界访问将返回undefined.\n\n<!-- more -->\n\n### 其他\n\n- 大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。\n\n  + Node.childNodes 是实时的\n\n  + document.querySelectorAll 返回一个静态的 NodeList\n\n-  NodeList 不是数组:\n\n  + NodeList的原型链是这样的：\n\n  myNodeList --> NodeList.prototype --> Object.prototype --> null\n\n\n### 遍历一个 NodeList 对象的所有节点。\n\n +  for 循环\n\n```\nfor (var i = 0; i < myNodeList.length; ++i) {\n    var item = myNodeList[i];  // 调用 myNodeList.item(i) 是没有必要的\n}\n```\n+ 在支持 for...of 的浏览器中 for...of 循环将会正确的遍历 NodeList 对象：\n\n```\nvar list = document.querySelectorAll( 'input[type=checkbox]' );\nfor (var item of list) {\n    item.checked = true;\n}\n```\n\n+ 将 NodeList 转换为 Array ( 类数组的方式 )\n\n    ---类数组： 有length 属性\n\n```\nvar div_list = document.querySelectorAll('div'); // 返回 NodeList\nvar div_array = Array.prototype.slice.call(div_list); // 将 NodeList 转换为数组\n\n//更好的写法\n[].forEach.call(Nodelist,function(){})\n```\n\n__NOTE:__\n\n最好不要使用 for...in 或者 for each...in 。__\n\n- 它们会把 length 和 item 属性也遍历出来。\n\n- 而 for in 也不保证顺序\n\n\n{% blockquote %}\n\n参考链接:\n\n[MDN: NodeList](https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList)\n\n{% endblockquote %}\n\n","slug":"nodelist","published":1,"updated":"2016-12-05T06:18:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj94j000l8mra2ubrp6s8","content":"<p>跟 querySelector 一块查到的 nodeList</p>\n<h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><p>NodeList 对象是一个节点的集合，是由 <strong>Node.childNodes</strong> 和 <strong>document.querySelectorAll</strong> 返回的. (不是 Array)</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><ul>\n<li>length</li>\n</ul>\n<h3 id=\"方法-item-idx\"><a href=\"#方法-item-idx\" class=\"headerlink\" title=\"方法: item( idx )\"></a>方法: item( idx )</h3><ul>\n<li>返回NodeList对象中指定索引的节点,如果索引越界,则返回null.等价的写法是nodeList[idx], 不过这种情况下越界访问将返回undefined.</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。</p>\n<ul>\n<li><p>Node.childNodes 是实时的</p>\n</li>\n<li><p>document.querySelectorAll 返回一个静态的 NodeList</p>\n</li>\n</ul>\n</li>\n<li><p>NodeList 不是数组:</p>\n<ul>\n<li>NodeList的原型链是这样的：</li>\n</ul>\n<p>myNodeList –&gt; NodeList.prototype –&gt; Object.prototype –&gt; null</p>\n</li>\n</ul>\n<h3 id=\"遍历一个-NodeList-对象的所有节点。\"><a href=\"#遍历一个-NodeList-对象的所有节点。\" class=\"headerlink\" title=\"遍历一个 NodeList 对象的所有节点。\"></a>遍历一个 NodeList 对象的所有节点。</h3><ul>\n<li>for 循环</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; myNodeList.length; ++i) &#123;</div><div class=\"line\">    var item = myNodeList[i];  // 调用 myNodeList.item(i) 是没有必要的</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在支持 for…of 的浏览器中 for…of 循环将会正确的遍历 NodeList 对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var list = document.querySelectorAll( &apos;input[type=checkbox]&apos; );</div><div class=\"line\">for (var item of list) &#123;</div><div class=\"line\">    item.checked = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>将 NodeList 转换为 Array ( 类数组的方式 )</p>\n<p>  —类数组： 有length 属性</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var div_list = document.querySelectorAll(&apos;div&apos;); // 返回 NodeList</div><div class=\"line\">var div_array = Array.prototype.slice.call(div_list); // 将 NodeList 转换为数组</div><div class=\"line\"></div><div class=\"line\">//更好的写法</div><div class=\"line\">[].forEach.call(Nodelist,function()&#123;&#125;)</div></pre></td></tr></table></figure>\n<p><strong>NOTE:</strong></p>\n<p>最好不要使用 for…in 或者 for each…in 。__</p>\n<ul>\n<li><p>它们会把 length 和 item 属性也遍历出来。</p>\n</li>\n<li><p>而 for in 也不保证顺序</p>\n</li>\n</ul>\n<blockquote><p>参考链接:</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\" target=\"_blank\" rel=\"external\">MDN: NodeList</a></p>\n</blockquote>\n","excerpt":"<p>跟 querySelector 一块查到的 nodeList</p>\n<h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><p>NodeList 对象是一个节点的集合，是由 <strong>Node.childNodes</strong> 和 <strong>document.querySelectorAll</strong> 返回的. (不是 Array)</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><ul>\n<li>length</li>\n</ul>\n<h3 id=\"方法-item-idx\"><a href=\"#方法-item-idx\" class=\"headerlink\" title=\"方法: item( idx )\"></a>方法: item( idx )</h3><ul>\n<li>返回NodeList对象中指定索引的节点,如果索引越界,则返回null.等价的写法是nodeList[idx], 不过这种情况下越界访问将返回undefined.</li>\n</ul>","more":"<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。</p>\n<ul>\n<li><p>Node.childNodes 是实时的</p>\n</li>\n<li><p>document.querySelectorAll 返回一个静态的 NodeList</p>\n</li>\n</ul>\n</li>\n<li><p>NodeList 不是数组:</p>\n<ul>\n<li>NodeList的原型链是这样的：</li>\n</ul>\n<p>myNodeList –&gt; NodeList.prototype –&gt; Object.prototype –&gt; null</p>\n</li>\n</ul>\n<h3 id=\"遍历一个-NodeList-对象的所有节点。\"><a href=\"#遍历一个-NodeList-对象的所有节点。\" class=\"headerlink\" title=\"遍历一个 NodeList 对象的所有节点。\"></a>遍历一个 NodeList 对象的所有节点。</h3><ul>\n<li>for 循环</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i = 0; i &lt; myNodeList.length; ++i) &#123;</div><div class=\"line\">    var item = myNodeList[i];  // 调用 myNodeList.item(i) 是没有必要的</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>在支持 for…of 的浏览器中 for…of 循环将会正确的遍历 NodeList 对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var list = document.querySelectorAll( &apos;input[type=checkbox]&apos; );</div><div class=\"line\">for (var item of list) &#123;</div><div class=\"line\">    item.checked = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>将 NodeList 转换为 Array ( 类数组的方式 )</p>\n<p>  —类数组： 有length 属性</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var div_list = document.querySelectorAll(&apos;div&apos;); // 返回 NodeList</div><div class=\"line\">var div_array = Array.prototype.slice.call(div_list); // 将 NodeList 转换为数组</div><div class=\"line\"></div><div class=\"line\">//更好的写法</div><div class=\"line\">[].forEach.call(Nodelist,function()&#123;&#125;)</div></pre></td></tr></table></figure>\n<p><strong>NOTE:</strong></p>\n<p>最好不要使用 for…in 或者 for each…in 。__</p>\n<ul>\n<li><p>它们会把 length 和 item 属性也遍历出来。</p>\n</li>\n<li><p>而 for in 也不保证顺序</p>\n</li>\n</ul>\n<blockquote><p>参考链接:</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\">MDN: NodeList</a></p>\n</blockquote>"},{"title":"querySelector","date":"2016-12-02T16:00:00.000Z","_content":"\n最近, 看到别人使用 querySelector, 而我之前根本没听过。所以找到 MDN 上的资料\n\n### 简单知识介绍\n\n- DOM 扩展\n\n它属于 DOM 扩展的部分。\n\n对 DOM 的两个主要的扩展是 Selectors API 和 HTML5，这两个扩展都源自开发社区, 而将某些常见做法及 API 标准化, 一直是众望所归。\n\n<!-- more -->\n\n此外还有一个不那么引人注目的 Element Traversal ( 元素遍历 ) 规范，为 DOM 添加了一些属性。\n\n- Selectors API\n\n是由 W3C 发起制定的一个标准, 致力于让浏览器原生支持 CSS 查询。之前所有实现着一功能的 JS 库，都会写一个基础的 CSS 解析器，然后再使用已有的 DOM 方法查询文档找到匹配的点。\n\n而把这个功能变成原生 API 之后，解析和树的查询操作可以在浏览器内部通过编译后的代码来完成，极大的改善了性能。\n\nSelectors API Level 1 的核心是两个方法：\n__querySelector()__ 和 __querySelectorAll()__， 可以通过 Document 及 ELement 类型的实例调用它们。\n\n已完全支持的浏览器 IE8+, Firefox 3.5+, Safari 3.1+, Chrome 和 Opera 10+\n\n### document.querySelector /  Element.querySelector()\n\n- 语法： element = document.querySelector( selectors )\n-  selectors: 是一个字符串，包含一个或是多个 css 选择器，多个以逗号隔开。\n\n比如: 找到 div 标签中的 input 标签。\n\n```\n<div class=\"user-panel main\">\n    <input name=\"login\"/>\n</div>\n```\n\n```\nvar el = document.querySelector(\"div.user-panel.main input[name=login]\");\n```\n- element 是 __一个__ element 对象 ( DOM 元素 )\n\n- 如果没有找到匹配的元素，则返回 null。\n\n- 找到多个，返回第一个匹配到的元素。\n\n- Css 伪类不会返回任何元素。\n\n- 如果要匹配的ID或选择器不符合 CSS 语法（比如不恰当地使用了冒号或者空格），你必须用反斜杠将这些字符转义。由于 JavaScript 中，反斜杠是转义字符，所以当你输入一个文本串时，你必须将它转义两次（一次是为 JavaScript 字符串转义，另一次是为 querySelector 转义）\n\n比如: 匹配 id 为  foo\\bar 的DOM\n\n```\ndocument.querySelector('#foo\\\\\\\\bar');\n\n```\n\n#### document.querySelectorAll ( Element.querySelectorAll() )\n\n- elementList = document.querySelectorAll(Selectors);\n\n- elementList 是一个 __non-live__ 的 NodeList 类型的对象.  ( 静态的 )\n\n- selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串.\n\n比如: 返回一个文档中所有的 class 为 \"note\" / \"alert\" 的 div 元素。\n\n```\nvar matches = document.querySelectorAll(\"div.note, div.alert\");\n```\n\n- WebKit 内核的浏览器有一个 __bug__: 如果 selectors参数中包含 CSS伪类, 返回的elementList 包含一个<html> 元素,而不是空的.\n\n---\n **NOTE!!**\n\nelement.querySelector / element.querySelectorAll\n    查找的时候都包含 element\n----\n\n{% blockquote %}\n\n参考链接：\n\n[MDN: NodeList](https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList)\n\n[MDN: Document.querySelectorAll](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll)\n\n[MDN: Document.querySelector](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector)\n\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n","source":"_posts/querySelector.md","raw":"---\ntitle: querySelector\ncategories:\n- 编程\ntags:\n- DOM\n- 抄抄抄\ndate: 2016-12-03\n---\n\n最近, 看到别人使用 querySelector, 而我之前根本没听过。所以找到 MDN 上的资料\n\n### 简单知识介绍\n\n- DOM 扩展\n\n它属于 DOM 扩展的部分。\n\n对 DOM 的两个主要的扩展是 Selectors API 和 HTML5，这两个扩展都源自开发社区, 而将某些常见做法及 API 标准化, 一直是众望所归。\n\n<!-- more -->\n\n此外还有一个不那么引人注目的 Element Traversal ( 元素遍历 ) 规范，为 DOM 添加了一些属性。\n\n- Selectors API\n\n是由 W3C 发起制定的一个标准, 致力于让浏览器原生支持 CSS 查询。之前所有实现着一功能的 JS 库，都会写一个基础的 CSS 解析器，然后再使用已有的 DOM 方法查询文档找到匹配的点。\n\n而把这个功能变成原生 API 之后，解析和树的查询操作可以在浏览器内部通过编译后的代码来完成，极大的改善了性能。\n\nSelectors API Level 1 的核心是两个方法：\n__querySelector()__ 和 __querySelectorAll()__， 可以通过 Document 及 ELement 类型的实例调用它们。\n\n已完全支持的浏览器 IE8+, Firefox 3.5+, Safari 3.1+, Chrome 和 Opera 10+\n\n### document.querySelector /  Element.querySelector()\n\n- 语法： element = document.querySelector( selectors )\n-  selectors: 是一个字符串，包含一个或是多个 css 选择器，多个以逗号隔开。\n\n比如: 找到 div 标签中的 input 标签。\n\n```\n<div class=\"user-panel main\">\n    <input name=\"login\"/>\n</div>\n```\n\n```\nvar el = document.querySelector(\"div.user-panel.main input[name=login]\");\n```\n- element 是 __一个__ element 对象 ( DOM 元素 )\n\n- 如果没有找到匹配的元素，则返回 null。\n\n- 找到多个，返回第一个匹配到的元素。\n\n- Css 伪类不会返回任何元素。\n\n- 如果要匹配的ID或选择器不符合 CSS 语法（比如不恰当地使用了冒号或者空格），你必须用反斜杠将这些字符转义。由于 JavaScript 中，反斜杠是转义字符，所以当你输入一个文本串时，你必须将它转义两次（一次是为 JavaScript 字符串转义，另一次是为 querySelector 转义）\n\n比如: 匹配 id 为  foo\\bar 的DOM\n\n```\ndocument.querySelector('#foo\\\\\\\\bar');\n\n```\n\n#### document.querySelectorAll ( Element.querySelectorAll() )\n\n- elementList = document.querySelectorAll(Selectors);\n\n- elementList 是一个 __non-live__ 的 NodeList 类型的对象.  ( 静态的 )\n\n- selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串.\n\n比如: 返回一个文档中所有的 class 为 \"note\" / \"alert\" 的 div 元素。\n\n```\nvar matches = document.querySelectorAll(\"div.note, div.alert\");\n```\n\n- WebKit 内核的浏览器有一个 __bug__: 如果 selectors参数中包含 CSS伪类, 返回的elementList 包含一个<html> 元素,而不是空的.\n\n---\n **NOTE!!**\n\nelement.querySelector / element.querySelectorAll\n    查找的时候都包含 element\n----\n\n{% blockquote %}\n\n参考链接：\n\n[MDN: NodeList](https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList)\n\n[MDN: Document.querySelectorAll](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll)\n\n[MDN: Document.querySelector](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector)\n\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n","slug":"querySelector","published":1,"updated":"2016-12-05T06:15:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj94l000n8mrad8gzvij4","content":"<p>最近, 看到别人使用 querySelector, 而我之前根本没听过。所以找到 MDN 上的资料</p>\n<h3 id=\"简单知识介绍\"><a href=\"#简单知识介绍\" class=\"headerlink\" title=\"简单知识介绍\"></a>简单知识介绍</h3><ul>\n<li>DOM 扩展</li>\n</ul>\n<p>它属于 DOM 扩展的部分。</p>\n<p>对 DOM 的两个主要的扩展是 Selectors API 和 HTML5，这两个扩展都源自开发社区, 而将某些常见做法及 API 标准化, 一直是众望所归。</p>\n<a id=\"more\"></a>\n<p>此外还有一个不那么引人注目的 Element Traversal ( 元素遍历 ) 规范，为 DOM 添加了一些属性。</p>\n<ul>\n<li>Selectors API</li>\n</ul>\n<p>是由 W3C 发起制定的一个标准, 致力于让浏览器原生支持 CSS 查询。之前所有实现着一功能的 JS 库，都会写一个基础的 CSS 解析器，然后再使用已有的 DOM 方法查询文档找到匹配的点。</p>\n<p>而把这个功能变成原生 API 之后，解析和树的查询操作可以在浏览器内部通过编译后的代码来完成，极大的改善了性能。</p>\n<p>Selectors API Level 1 的核心是两个方法：<br><strong>querySelector()</strong> 和 <strong>querySelectorAll()</strong>， 可以通过 Document 及 ELement 类型的实例调用它们。</p>\n<p>已完全支持的浏览器 IE8+, Firefox 3.5+, Safari 3.1+, Chrome 和 Opera 10+</p>\n<h3 id=\"document-querySelector-Element-querySelector\"><a href=\"#document-querySelector-Element-querySelector\" class=\"headerlink\" title=\"document.querySelector /  Element.querySelector()\"></a>document.querySelector /  Element.querySelector()</h3><ul>\n<li>语法： element = document.querySelector( selectors )</li>\n<li>selectors: 是一个字符串，包含一个或是多个 css 选择器，多个以逗号隔开。</li>\n</ul>\n<p>比如: 找到 div 标签中的 input 标签。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;user-panel main&quot;&gt;</div><div class=\"line\">    &lt;input name=&quot;login&quot;/&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var el = document.querySelector(&quot;div.user-panel.main input[name=login]&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>element 是 <strong>一个</strong> element 对象 ( DOM 元素 )</p>\n</li>\n<li><p>如果没有找到匹配的元素，则返回 null。</p>\n</li>\n<li><p>找到多个，返回第一个匹配到的元素。</p>\n</li>\n<li><p>Css 伪类不会返回任何元素。</p>\n</li>\n<li><p>如果要匹配的ID或选择器不符合 CSS 语法（比如不恰当地使用了冒号或者空格），你必须用反斜杠将这些字符转义。由于 JavaScript 中，反斜杠是转义字符，所以当你输入一个文本串时，你必须将它转义两次（一次是为 JavaScript 字符串转义，另一次是为 querySelector 转义）</p>\n</li>\n</ul>\n<p>比如: 匹配 id 为  foo\\bar 的DOM</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.querySelector(&apos;#foo\\\\\\\\bar&apos;);</div></pre></td></tr></table></figure>\n<h4 id=\"document-querySelectorAll-Element-querySelectorAll\"><a href=\"#document-querySelectorAll-Element-querySelectorAll\" class=\"headerlink\" title=\"document.querySelectorAll ( Element.querySelectorAll() )\"></a>document.querySelectorAll ( Element.querySelectorAll() )</h4><ul>\n<li><p>elementList = document.querySelectorAll(Selectors);</p>\n</li>\n<li><p>elementList 是一个 <strong>non-live</strong> 的 NodeList 类型的对象.  ( 静态的 )</p>\n</li>\n<li><p>selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串.</p>\n</li>\n</ul>\n<p>比如: 返回一个文档中所有的 class 为 “note” / “alert” 的 div 元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = document.querySelectorAll(&quot;div.note, div.alert&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li>WebKit 内核的浏览器有一个 <strong>bug</strong>: 如果 selectors参数中包含 CSS伪类, 返回的elementList 包含一个<html> 元素,而不是空的.</html></li>\n</ul>\n<hr>\n<p> <strong>NOTE!!</strong></p>\n<p>element.querySelector / element.querySelectorAll</p>\n<pre><code>查找的时候都包含 element\n</code></pre><hr>\n<blockquote><p>参考链接：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\" target=\"_blank\" rel=\"external\">MDN: NodeList</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\" target=\"_blank\" rel=\"external\">MDN: Document.querySelectorAll</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector\" target=\"_blank\" rel=\"external\">MDN: Document.querySelector</a></p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>\n","excerpt":"<p>最近, 看到别人使用 querySelector, 而我之前根本没听过。所以找到 MDN 上的资料</p>\n<h3 id=\"简单知识介绍\"><a href=\"#简单知识介绍\" class=\"headerlink\" title=\"简单知识介绍\"></a>简单知识介绍</h3><ul>\n<li>DOM 扩展</li>\n</ul>\n<p>它属于 DOM 扩展的部分。</p>\n<p>对 DOM 的两个主要的扩展是 Selectors API 和 HTML5，这两个扩展都源自开发社区, 而将某些常见做法及 API 标准化, 一直是众望所归。</p>","more":"<p>此外还有一个不那么引人注目的 Element Traversal ( 元素遍历 ) 规范，为 DOM 添加了一些属性。</p>\n<ul>\n<li>Selectors API</li>\n</ul>\n<p>是由 W3C 发起制定的一个标准, 致力于让浏览器原生支持 CSS 查询。之前所有实现着一功能的 JS 库，都会写一个基础的 CSS 解析器，然后再使用已有的 DOM 方法查询文档找到匹配的点。</p>\n<p>而把这个功能变成原生 API 之后，解析和树的查询操作可以在浏览器内部通过编译后的代码来完成，极大的改善了性能。</p>\n<p>Selectors API Level 1 的核心是两个方法：<br><strong>querySelector()</strong> 和 <strong>querySelectorAll()</strong>， 可以通过 Document 及 ELement 类型的实例调用它们。</p>\n<p>已完全支持的浏览器 IE8+, Firefox 3.5+, Safari 3.1+, Chrome 和 Opera 10+</p>\n<h3 id=\"document-querySelector-Element-querySelector\"><a href=\"#document-querySelector-Element-querySelector\" class=\"headerlink\" title=\"document.querySelector /  Element.querySelector()\"></a>document.querySelector /  Element.querySelector()</h3><ul>\n<li>语法： element = document.querySelector( selectors )</li>\n<li>selectors: 是一个字符串，包含一个或是多个 css 选择器，多个以逗号隔开。</li>\n</ul>\n<p>比如: 找到 div 标签中的 input 标签。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;user-panel main&quot;&gt;</div><div class=\"line\">    &lt;input name=&quot;login&quot;/&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var el = document.querySelector(&quot;div.user-panel.main input[name=login]&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>element 是 <strong>一个</strong> element 对象 ( DOM 元素 )</p>\n</li>\n<li><p>如果没有找到匹配的元素，则返回 null。</p>\n</li>\n<li><p>找到多个，返回第一个匹配到的元素。</p>\n</li>\n<li><p>Css 伪类不会返回任何元素。</p>\n</li>\n<li><p>如果要匹配的ID或选择器不符合 CSS 语法（比如不恰当地使用了冒号或者空格），你必须用反斜杠将这些字符转义。由于 JavaScript 中，反斜杠是转义字符，所以当你输入一个文本串时，你必须将它转义两次（一次是为 JavaScript 字符串转义，另一次是为 querySelector 转义）</p>\n</li>\n</ul>\n<p>比如: 匹配 id 为  foo\\bar 的DOM</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.querySelector(&apos;#foo\\\\\\\\bar&apos;);</div></pre></td></tr></table></figure>\n<h4 id=\"document-querySelectorAll-Element-querySelectorAll\"><a href=\"#document-querySelectorAll-Element-querySelectorAll\" class=\"headerlink\" title=\"document.querySelectorAll ( Element.querySelectorAll() )\"></a>document.querySelectorAll ( Element.querySelectorAll() )</h4><ul>\n<li><p>elementList = document.querySelectorAll(Selectors);</p>\n</li>\n<li><p>elementList 是一个 <strong>non-live</strong> 的 NodeList 类型的对象.  ( 静态的 )</p>\n</li>\n<li><p>selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串.</p>\n</li>\n</ul>\n<p>比如: 返回一个文档中所有的 class 为 “note” / “alert” 的 div 元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = document.querySelectorAll(&quot;div.note, div.alert&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li>WebKit 内核的浏览器有一个 <strong>bug</strong>: 如果 selectors参数中包含 CSS伪类, 返回的elementList 包含一个<html> 元素,而不是空的.</li>\n</ul>\n<hr>\n<p> <strong>NOTE!!</strong></p>\n<p>element.querySelector / element.querySelectorAll</p>\n<pre><code>查找的时候都包含 element\n</code></pre><hr>\n<blockquote><p>参考链接：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NodeList\">MDN: NodeList</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll\">MDN: Document.querySelectorAll</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector\">MDN: Document.querySelector</a></p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>"},{"title":"我的 hexo 搭建过程记录","auto_spacing":true,"_content":"\n#### hexo 基础搭建\n\n- 安装 hexo\n\n    $ npm install -g hexo-cli\n\n- 随便建一个目录\n\n    mkdir hexo_test\n\n- 初始化文件夹 ( 在hexo_test 外面 )\n\n    hexo init hexo_test\n\n- 进入 hexo_test\n\n    cd hexo_test\n\n- npm 初始化\n\n    npm install\n\n- 然后就可以看到有许多文件夹\n\n<!-- more -->\n\n- 生成静态页面\n\n    + hexo generate（hexo g也可以）\n\n    + 在 public 某个目录里( 默认是现在的时间) 有一个新生成的 yourpostname.html 文件。\n\n- 启动本地服务，进行文章预览调试\n\n    hexo server\n\n- 打开 http://localhost:4000\n\n- 注意 ！ 这里我有个错误提示\n\n```bash\n  {[Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n  {[Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n  {[Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n先查到用这个 npm install hexo --no-optional,\n但是对我没用\n\n__(至今还未解决)__\n\n- 新添加一篇 post\n\n    + hexo new \"Hey\"\n\n    + 在 hexo_test/source/_post 中生成 一个为 Hey.md 的文件。\n\n- 如果你没有起 server 的话，可能需要执行 hexo generate 来生成静态页面\n\n- 再去刷新一下页面，发现页面上新增了 Hey 这个 post，但是没有内容。\n\n- 进入source/_post/Hey.md 你就可以编辑这篇文章的内容了\n\n    + 然后保存， 你就可以在网页中看到你文章的内容了\n\n#### 部署到 github.io 上\n\n- 在根目录下找到 _config.yml 文件, 并打开\n\n- 找到 这部分(在最后)\n```\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type:\n```\n\n- 修改上述地方\n\n```\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type: git\n    repository: git@github.com:vivian-xu/vivian-xu.github.io.git\n    branch: master\n```\n##### 注意!\n  - repository：必须是SSH形式的url (如上)，而不能是HTTPS形式的url（https://github.com/***/***.github.io.git），\n  - 如果你使用SSH url，但是电脑没有开放SSH 端口，会致部署失败。\n  - 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 ( __看到这个，我把我的 branch 改成 gh-pages了__ )\n\n - 然后 hexo deploy\n\n    ##### 报错 ERROR Deployer not found: git\n\n    解决方法： npm install hexo-deployer-git --save\n\n  - hexo deploy  成功！\n\n  - 然后我去 github 我的 vivian-xu.github.io.git 的仓库里切换了，分支看了一下，有传进来的！\n\n  - 然后我去访问 vivian-xu.github.io.git/hexo_test/\n\n  结果 404 ....\n\n  于是我在网上搜索问题, 先是找 gh-pages 相关，但是没解决我问题。之后我又去 git 仓库看了下，确保没有什么问题，看着我的 gh-pages 分支，很是疑惑，东西都在，怎么能访问不了。\n\n  看着 gh-pages 我有些疑虑文档里所说的 gh-pages 名字是我建的 文件夹名么。。。 我的文件夹在本地，而且文件夹名没有一起更新到 github 的 vivian-xu.github.io 的 gh-pages 中，github 怎么会知道我的文件夹名。。\n\n  然后我在 hexo 的 [这个issue](https://github.com/hexojs/hexo/issues/350) 里看到回答。\n\n{% blockquote %}\n    _yourname.github.io形式的库，会解析master分支；而别的名字的库，会解析gh-pages分支，以yourname.github.io/库名的形式访问。 _\n{% endblockquote %}\n\n  这个更加让我相信是名字的问题，于是，我重新建了一个库，然后把 _config.yml 的 git 相关的文件改了\n\n  ```\n  type: git\n  repository: git@github.com:vivian-xu/hexo_test.git // 新库地址\n  branch: gh-pages\n  ```\n  - 然后重新生成，deploy，检查了下新的 git 的仓库确保文件传了进去\n\n  - 之后打开 vivian-xu.github.io/hexo_test/  已经不再是 404 了！但是。为什么没有样式。。\n\n  - 打开 chorme 的调试工具，发现 css js 的路径都不对( 类似这样的 https://vivian-xu.github.io/fancybox/jquery.fancybox.css )，应该是 https://vivian-xu.github.io/hexo_test/*** 。于是，又去看了 issue ，看到这个 https://github.com/hexojs/hexo/issues/1121\n\n   意识到自己要配 root ( 自己的网站还要配 CNAME )\n\n  于是又修改了 _config.yml\n\n   ```\n   url: http://yoursite.com\n   root: /hexo_test/\n   permalink: :year/:month/:day/:title/\n   permalink_defaults:\n   ```\n\n  - 再次 hexo g -d ，打开页面 终于成功了！！\n\n  现在是这个样子\n  ```\n  # Hexo Configuration\n  ## Docs: https://hexo.io/docs/configuration.html\n  ## Source: https://github.com/hexojs/hexo/\n\n  # Site 站点\n  title: Vivian\n  subtitle:\n  description: Vvian's blog\n  keywords:\n    - HTML\n    - JavaScript\n    - CSS\n    - React\n  author: Vivian\n  language: zh-CN #语言\n  timezone: Asia/Shanghai #时区\n\n  # URL\n  ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n  url: http://yoursite.com #用于绑定域名, 其他的不需要配置\n  root: /hexo_test/\n  permalink: :year/:month/:day/:title/\n  permalink_defaults:\n\n  # Directory\n  source_dir: source\n  public_dir: public\n  tag_dir: tags #标签\n  archive_dir: archives  #归档\n  category_dir: categories #分类\n  code_dir: downloads/code\n  i18n_dir: :lang\n  skip_render:\n\n  # Writing\n  new_post_name: :title.md # File name of new posts\n  default_layout: post #默认模板(post page photo draft)\n  titlecase: false # Transform title into titlecase  #标题转换成大写\n  external_link: true # Open external links in new tab #新标签页里打开连接\n  filename_case: 0\n  render_drafts: false\n  post_asset_folder: false\n  relative_link: false\n  future: true\n  highlight:  #语法高亮\n    enable: true\n    line_number: true #显示行号\n    auto_detect: false\n    tab_replace:\n\n  # Category & Tag\n  default_category: uncategorized #默认分类\n  category_map:\n  tag_map:\n\n  # Date / Time format\n  ## Hexo uses Moment.js to parse and display date\n  ## You can customize the date format as defined in\n  ## http://momentjs.com/docs/#/displaying/format/\n  date_format: YYYY-MM-DD\n  time_format: HH:mm:ss\n\n  # Pagination\n  ## Set per_page to 0 to disable pagination\n  per_page: 10\n  pagination_dir: page\n\n  # Extensions\n  ## Plugins: https://hexo.io/plugins/\n  ## Themes: https://hexo.io/themes/\n  theme: landscape\n  # theme: ninja\n\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type: git\n    # repository: git@github.com:vivian-xu/vivian-xu.github.io.git\n    repository: git@github.com:vivian-xu/blog.git\n    branch: gh-pages\n\n  ```\n\n#### theme 主题\n\n- 挑选一个喜欢的 theme, git clone theme/ theme_name 下\n\n- 将网站的 _config.yml 的 theme 改成你要的换的主题的名字\n\n- 根据主题的文档，修改 _config.yml ( 包括网站的和主题的 )\n\n- 生成网页并且 开启 server 调试下，然后自己不满意的地方，手动改改模版。\n\n#### 管理源代码\n经某人提醒，我的源代码没有管理，所以又开了一个库用来管理这一整套的源代码。然后想直接在主页面上展示博客首页就好了，于是将 branch 变成了 master。 再次生成，deploy。\n\n#### 部署到自己的域名上\n- 因为，如果直接将我的域名，解析道 git 的这个网页的话，要改 CNAME (  只能有一个 )，而我的邮箱还是指向原来服务器的，感觉不太好，于是就保持原来的方式了。直接将静态文件 copy 到服务器下保存。\n\n- 用了一套简单的 CI 系统，将 GitHub 设置成有新的 push 的时候发消息给 CI, CI 自动 pull 下来代码，然后测试，到服务器指定的文件夹里。\n\n到这，基本上就结束了。当然，我觉得，我会没事改改这个 theme 的代码的～～\n\n\n#### hexo 部分指令\n\n指令 | 简写 | 作用\n--|--|--\nhexo new \"postName\" | hexo n \"postName\" |  #新建文章\nhexo new page \"pageName\" | hexo n  page \"postName\"  |  #新建页面\nhexo generate | hexo g |  #生成静态页面至public目录\nhexo server | hexo s | #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy | hexo d | #将.deploy目录部署到GitHub\nhexo help | \\ | # 查看帮助\nhexo version | \\  |  #查看Hexo的版本\n\n{% blockquote %}\n\n参考 :\n\n[Hexo常见问题解决方案](https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy之后，页面长时间404)\n\n[Hexo 文档](https://hexo.io/zh-cn/docs/)\n\n[Hexo搭建Github静态博客](http://www.cnblogs.com/zhcncn/p/4097881.html)\n\n{% endblockquote %}\n","source":"_posts/start with hexo.md","raw":"---\ntitle: 我的 hexo 搭建过程记录\ncategories:\n- 编程\ntags:\n- 记录\n- Hexo\nauto_spacing: true\n---\n\n#### hexo 基础搭建\n\n- 安装 hexo\n\n    $ npm install -g hexo-cli\n\n- 随便建一个目录\n\n    mkdir hexo_test\n\n- 初始化文件夹 ( 在hexo_test 外面 )\n\n    hexo init hexo_test\n\n- 进入 hexo_test\n\n    cd hexo_test\n\n- npm 初始化\n\n    npm install\n\n- 然后就可以看到有许多文件夹\n\n<!-- more -->\n\n- 生成静态页面\n\n    + hexo generate（hexo g也可以）\n\n    + 在 public 某个目录里( 默认是现在的时间) 有一个新生成的 yourpostname.html 文件。\n\n- 启动本地服务，进行文章预览调试\n\n    hexo server\n\n- 打开 http://localhost:4000\n\n- 注意 ！ 这里我有个错误提示\n\n```bash\n  {[Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n  {[Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n  {[Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n先查到用这个 npm install hexo --no-optional,\n但是对我没用\n\n__(至今还未解决)__\n\n- 新添加一篇 post\n\n    + hexo new \"Hey\"\n\n    + 在 hexo_test/source/_post 中生成 一个为 Hey.md 的文件。\n\n- 如果你没有起 server 的话，可能需要执行 hexo generate 来生成静态页面\n\n- 再去刷新一下页面，发现页面上新增了 Hey 这个 post，但是没有内容。\n\n- 进入source/_post/Hey.md 你就可以编辑这篇文章的内容了\n\n    + 然后保存， 你就可以在网页中看到你文章的内容了\n\n#### 部署到 github.io 上\n\n- 在根目录下找到 _config.yml 文件, 并打开\n\n- 找到 这部分(在最后)\n```\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type:\n```\n\n- 修改上述地方\n\n```\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type: git\n    repository: git@github.com:vivian-xu/vivian-xu.github.io.git\n    branch: master\n```\n##### 注意!\n  - repository：必须是SSH形式的url (如上)，而不能是HTTPS形式的url（https://github.com/***/***.github.io.git），\n  - 如果你使用SSH url，但是电脑没有开放SSH 端口，会致部署失败。\n  - 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 ( __看到这个，我把我的 branch 改成 gh-pages了__ )\n\n - 然后 hexo deploy\n\n    ##### 报错 ERROR Deployer not found: git\n\n    解决方法： npm install hexo-deployer-git --save\n\n  - hexo deploy  成功！\n\n  - 然后我去 github 我的 vivian-xu.github.io.git 的仓库里切换了，分支看了一下，有传进来的！\n\n  - 然后我去访问 vivian-xu.github.io.git/hexo_test/\n\n  结果 404 ....\n\n  于是我在网上搜索问题, 先是找 gh-pages 相关，但是没解决我问题。之后我又去 git 仓库看了下，确保没有什么问题，看着我的 gh-pages 分支，很是疑惑，东西都在，怎么能访问不了。\n\n  看着 gh-pages 我有些疑虑文档里所说的 gh-pages 名字是我建的 文件夹名么。。。 我的文件夹在本地，而且文件夹名没有一起更新到 github 的 vivian-xu.github.io 的 gh-pages 中，github 怎么会知道我的文件夹名。。\n\n  然后我在 hexo 的 [这个issue](https://github.com/hexojs/hexo/issues/350) 里看到回答。\n\n{% blockquote %}\n    _yourname.github.io形式的库，会解析master分支；而别的名字的库，会解析gh-pages分支，以yourname.github.io/库名的形式访问。 _\n{% endblockquote %}\n\n  这个更加让我相信是名字的问题，于是，我重新建了一个库，然后把 _config.yml 的 git 相关的文件改了\n\n  ```\n  type: git\n  repository: git@github.com:vivian-xu/hexo_test.git // 新库地址\n  branch: gh-pages\n  ```\n  - 然后重新生成，deploy，检查了下新的 git 的仓库确保文件传了进去\n\n  - 之后打开 vivian-xu.github.io/hexo_test/  已经不再是 404 了！但是。为什么没有样式。。\n\n  - 打开 chorme 的调试工具，发现 css js 的路径都不对( 类似这样的 https://vivian-xu.github.io/fancybox/jquery.fancybox.css )，应该是 https://vivian-xu.github.io/hexo_test/*** 。于是，又去看了 issue ，看到这个 https://github.com/hexojs/hexo/issues/1121\n\n   意识到自己要配 root ( 自己的网站还要配 CNAME )\n\n  于是又修改了 _config.yml\n\n   ```\n   url: http://yoursite.com\n   root: /hexo_test/\n   permalink: :year/:month/:day/:title/\n   permalink_defaults:\n   ```\n\n  - 再次 hexo g -d ，打开页面 终于成功了！！\n\n  现在是这个样子\n  ```\n  # Hexo Configuration\n  ## Docs: https://hexo.io/docs/configuration.html\n  ## Source: https://github.com/hexojs/hexo/\n\n  # Site 站点\n  title: Vivian\n  subtitle:\n  description: Vvian's blog\n  keywords:\n    - HTML\n    - JavaScript\n    - CSS\n    - React\n  author: Vivian\n  language: zh-CN #语言\n  timezone: Asia/Shanghai #时区\n\n  # URL\n  ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n  url: http://yoursite.com #用于绑定域名, 其他的不需要配置\n  root: /hexo_test/\n  permalink: :year/:month/:day/:title/\n  permalink_defaults:\n\n  # Directory\n  source_dir: source\n  public_dir: public\n  tag_dir: tags #标签\n  archive_dir: archives  #归档\n  category_dir: categories #分类\n  code_dir: downloads/code\n  i18n_dir: :lang\n  skip_render:\n\n  # Writing\n  new_post_name: :title.md # File name of new posts\n  default_layout: post #默认模板(post page photo draft)\n  titlecase: false # Transform title into titlecase  #标题转换成大写\n  external_link: true # Open external links in new tab #新标签页里打开连接\n  filename_case: 0\n  render_drafts: false\n  post_asset_folder: false\n  relative_link: false\n  future: true\n  highlight:  #语法高亮\n    enable: true\n    line_number: true #显示行号\n    auto_detect: false\n    tab_replace:\n\n  # Category & Tag\n  default_category: uncategorized #默认分类\n  category_map:\n  tag_map:\n\n  # Date / Time format\n  ## Hexo uses Moment.js to parse and display date\n  ## You can customize the date format as defined in\n  ## http://momentjs.com/docs/#/displaying/format/\n  date_format: YYYY-MM-DD\n  time_format: HH:mm:ss\n\n  # Pagination\n  ## Set per_page to 0 to disable pagination\n  per_page: 10\n  pagination_dir: page\n\n  # Extensions\n  ## Plugins: https://hexo.io/plugins/\n  ## Themes: https://hexo.io/themes/\n  theme: landscape\n  # theme: ninja\n\n  # Deployment\n  ## Docs: https://hexo.io/docs/deployment.html\n  deploy:\n    type: git\n    # repository: git@github.com:vivian-xu/vivian-xu.github.io.git\n    repository: git@github.com:vivian-xu/blog.git\n    branch: gh-pages\n\n  ```\n\n#### theme 主题\n\n- 挑选一个喜欢的 theme, git clone theme/ theme_name 下\n\n- 将网站的 _config.yml 的 theme 改成你要的换的主题的名字\n\n- 根据主题的文档，修改 _config.yml ( 包括网站的和主题的 )\n\n- 生成网页并且 开启 server 调试下，然后自己不满意的地方，手动改改模版。\n\n#### 管理源代码\n经某人提醒，我的源代码没有管理，所以又开了一个库用来管理这一整套的源代码。然后想直接在主页面上展示博客首页就好了，于是将 branch 变成了 master。 再次生成，deploy。\n\n#### 部署到自己的域名上\n- 因为，如果直接将我的域名，解析道 git 的这个网页的话，要改 CNAME (  只能有一个 )，而我的邮箱还是指向原来服务器的，感觉不太好，于是就保持原来的方式了。直接将静态文件 copy 到服务器下保存。\n\n- 用了一套简单的 CI 系统，将 GitHub 设置成有新的 push 的时候发消息给 CI, CI 自动 pull 下来代码，然后测试，到服务器指定的文件夹里。\n\n到这，基本上就结束了。当然，我觉得，我会没事改改这个 theme 的代码的～～\n\n\n#### hexo 部分指令\n\n指令 | 简写 | 作用\n--|--|--\nhexo new \"postName\" | hexo n \"postName\" |  #新建文章\nhexo new page \"pageName\" | hexo n  page \"postName\"  |  #新建页面\nhexo generate | hexo g |  #生成静态页面至public目录\nhexo server | hexo s | #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy | hexo d | #将.deploy目录部署到GitHub\nhexo help | \\ | # 查看帮助\nhexo version | \\  |  #查看Hexo的版本\n\n{% blockquote %}\n\n参考 :\n\n[Hexo常见问题解决方案](https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy之后，页面长时间404)\n\n[Hexo 文档](https://hexo.io/zh-cn/docs/)\n\n[Hexo搭建Github静态博客](http://www.cnblogs.com/zhcncn/p/4097881.html)\n\n{% endblockquote %}\n","slug":"start with hexo","published":1,"date":"2016-12-02T15:24:51.000Z","updated":"2016-12-05T06:19:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwfxj94q000r8mrax80a7hrf","content":"<h4 id=\"hexo-基础搭建\"><a href=\"#hexo-基础搭建\" class=\"headerlink\" title=\"hexo 基础搭建\"></a>hexo 基础搭建</h4><ul>\n<li><p>安装 hexo</p>\n<p>  $ npm install -g hexo-cli</p>\n</li>\n<li><p>随便建一个目录</p>\n<p>  mkdir hexo_test</p>\n</li>\n<li><p>初始化文件夹 ( 在hexo_test 外面 )</p>\n<p>  hexo init hexo_test</p>\n</li>\n<li><p>进入 hexo_test</p>\n<p>  cd hexo_test</p>\n</li>\n<li><p>npm 初始化</p>\n<p>  npm install</p>\n</li>\n<li><p>然后就可以看到有许多文件夹</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>生成静态页面</p>\n<ul>\n<li><p>hexo generate（hexo g也可以）</p>\n</li>\n<li><p>在 public 某个目录里( 默认是现在的时间) 有一个新生成的 yourpostname.html 文件。</p>\n</li>\n</ul>\n</li>\n<li><p>启动本地服务，进行文章预览调试</p>\n<p>  hexo server</p>\n</li>\n<li><p>打开 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></p>\n</li>\n<li><p>注意 ！ 这里我有个错误提示</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/Release/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/default/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/Debug/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure>\n<p>先查到用这个 npm install hexo –no-optional,<br>但是对我没用</p>\n<p><strong>(至今还未解决)</strong></p>\n<ul>\n<li><p>新添加一篇 post</p>\n<ul>\n<li><p>hexo new “Hey”</p>\n</li>\n<li><p>在 hexo_test/source/_post 中生成 一个为 Hey.md 的文件。</p>\n</li>\n</ul>\n</li>\n<li><p>如果你没有起 server 的话，可能需要执行 hexo generate 来生成静态页面</p>\n</li>\n<li><p>再去刷新一下页面，发现页面上新增了 Hey 这个 post，但是没有内容。</p>\n</li>\n<li><p>进入source/_post/Hey.md 你就可以编辑这篇文章的内容了</p>\n<ul>\n<li>然后保存， 你就可以在网页中看到你文章的内容了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"部署到-github-io-上\"><a href=\"#部署到-github-io-上\" class=\"headerlink\" title=\"部署到 github.io 上\"></a>部署到 github.io 上</h4><ul>\n<li><p>在根目录下找到 _config.yml 文件, 并打开</p>\n</li>\n<li><p>找到 这部分(在最后)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改上述地方</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:vivian-xu/vivian-xu.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h5 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意!\"></a>注意!</h5><ul>\n<li>repository：必须是SSH形式的url (如上)，而不能是HTTPS形式的url（<a href=\"https://github.com/***/***.github.io.git），\" target=\"_blank\" rel=\"external\">https://github.com/***/***.github.io.git），</a></li>\n<li>如果你使用SSH url，但是电脑没有开放SSH 端口，会致部署失败。</li>\n<li><p>如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 ( <strong>看到这个，我把我的 branch 改成 gh-pages了</strong> )</p>\n<ul>\n<li>然后 hexo deploy</li>\n</ul>\n<h5 id=\"报错-ERROR-Deployer-not-found-git\"><a href=\"#报错-ERROR-Deployer-not-found-git\" class=\"headerlink\" title=\"报错 ERROR Deployer not found: git\"></a>报错 ERROR Deployer not found: git</h5><p>解决方法： npm install hexo-deployer-git –save</p>\n</li>\n<li><p>hexo deploy  成功！</p>\n</li>\n<li><p>然后我去 github 我的 vivian-xu.github.io.git 的仓库里切换了，分支看了一下，有传进来的！</p>\n</li>\n<li><p>然后我去访问 vivian-xu.github.io.git/hexo_test/</p>\n<p>结果 404 ….</p>\n<p>于是我在网上搜索问题, 先是找 gh-pages 相关，但是没解决我问题。之后我又去 git 仓库看了下，确保没有什么问题，看着我的 gh-pages 分支，很是疑惑，东西都在，怎么能访问不了。</p>\n<p>看着 gh-pages 我有些疑虑文档里所说的 gh-pages 名字是我建的 文件夹名么。。。 我的文件夹在本地，而且文件夹名没有一起更新到 github 的 vivian-xu.github.io 的 gh-pages 中，github 怎么会知道我的文件夹名。。</p>\n<p>然后我在 hexo 的 <a href=\"https://github.com/hexojs/hexo/issues/350\" target=\"_blank\" rel=\"external\">这个issue</a> 里看到回答。</p>\n</li>\n</ul>\n<blockquote><p><em>yourname.github.io形式的库，会解析master分支；而别的名字的库，会解析gh-pages分支，以yourname.github.io/库名的形式访问。 </em></p>\n</blockquote>\n<p>  这个更加让我相信是名字的问题，于是，我重新建了一个库，然后把 _config.yml 的 git 相关的文件改了</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">type: git</div><div class=\"line\">repository: git@github.com:vivian-xu/hexo_test.git // 新库地址</div><div class=\"line\">branch: gh-pages</div></pre></td></tr></table></figure>\n<ul>\n<li><p>然后重新生成，deploy，检查了下新的 git 的仓库确保文件传了进去</p>\n</li>\n<li><p>之后打开 vivian-xu.github.io/hexo_test/  已经不再是 404 了！但是。为什么没有样式。。</p>\n</li>\n<li><p>打开 chorme 的调试工具，发现 css js 的路径都不对( 类似这样的 <a href=\"https://vivian-xu.github.io/fancybox/jquery.fancybox.css\" target=\"_blank\" rel=\"external\">https://vivian-xu.github.io/fancybox/jquery.fancybox.css</a> )，应该是 <a href=\"https://vivian-xu.github.io/hexo_test/***\" target=\"_blank\" rel=\"external\">https://vivian-xu.github.io/hexo_test/***</a> 。于是，又去看了 issue ，看到这个 <a href=\"https://github.com/hexojs/hexo/issues/1121\" target=\"_blank\" rel=\"external\">https://github.com/hexojs/hexo/issues/1121</a></p>\n<p>意识到自己要配 root ( 自己的网站还要配 CNAME )</p>\n<p>于是又修改了 _config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /hexo_test/</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div></pre></td></tr></table></figure>\n</li>\n<li><p>再次 hexo g -d ，打开页面 终于成功了！！</p>\n<p>现在是这个样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site 站点</div><div class=\"line\">title: Vivian</div><div class=\"line\">subtitle:</div><div class=\"line\">description: Vvian&apos;s blog</div><div class=\"line\">keywords:</div><div class=\"line\">  - HTML</div><div class=\"line\">  - JavaScript</div><div class=\"line\">  - CSS</div><div class=\"line\">  - React</div><div class=\"line\">author: Vivian</div><div class=\"line\">language: zh-CN #语言</div><div class=\"line\">timezone: Asia/Shanghai #时区</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com #用于绑定域名, 其他的不需要配置</div><div class=\"line\">root: /hexo_test/</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags #标签</div><div class=\"line\">archive_dir: archives  #归档</div><div class=\"line\">category_dir: categories #分类</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post #默认模板(post page photo draft)</div><div class=\"line\">titlecase: false # Transform title into titlecase  #标题转换成大写</div><div class=\"line\">external_link: true # Open external links in new tab #新标签页里打开连接</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:  #语法高亮</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true #显示行号</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized #默认分类</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"># theme: ninja</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  # repository: git@github.com:vivian-xu/vivian-xu.github.io.git</div><div class=\"line\">  repository: git@github.com:vivian-xu/blog.git</div><div class=\"line\">  branch: gh-pages</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"theme-主题\"><a href=\"#theme-主题\" class=\"headerlink\" title=\"theme 主题\"></a>theme 主题</h4><ul>\n<li><p>挑选一个喜欢的 theme, git clone theme/ theme_name 下</p>\n</li>\n<li><p>将网站的 _config.yml 的 theme 改成你要的换的主题的名字</p>\n</li>\n<li><p>根据主题的文档，修改 _config.yml ( 包括网站的和主题的 )</p>\n</li>\n<li><p>生成网页并且 开启 server 调试下，然后自己不满意的地方，手动改改模版。</p>\n</li>\n</ul>\n<h4 id=\"管理源代码\"><a href=\"#管理源代码\" class=\"headerlink\" title=\"管理源代码\"></a>管理源代码</h4><p>经某人提醒，我的源代码没有管理，所以又开了一个库用来管理这一整套的源代码。然后想直接在主页面上展示博客首页就好了，于是将 branch 变成了 master。 再次生成，deploy。</p>\n<h4 id=\"部署到自己的域名上\"><a href=\"#部署到自己的域名上\" class=\"headerlink\" title=\"部署到自己的域名上\"></a>部署到自己的域名上</h4><ul>\n<li><p>因为，如果直接将我的域名，解析道 git 的这个网页的话，要改 CNAME (  只能有一个 )，而我的邮箱还是指向原来服务器的，感觉不太好，于是就保持原来的方式了。直接将静态文件 copy 到服务器下保存。</p>\n</li>\n<li><p>用了一套简单的 CI 系统，将 GitHub 设置成有新的 push 的时候发消息给 CI, CI 自动 pull 下来代码，然后测试，到服务器指定的文件夹里。</p>\n</li>\n</ul>\n<p>到这，基本上就结束了。当然，我觉得，我会没事改改这个 theme 的代码的～～</p>\n<h4 id=\"hexo-部分指令\"><a href=\"#hexo-部分指令\" class=\"headerlink\" title=\"hexo 部分指令\"></a>hexo 部分指令</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>简写</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hexo new “postName”</td>\n<td>hexo n “postName”</td>\n<td>#新建文章</td>\n</tr>\n<tr>\n<td>hexo new page “pageName”</td>\n<td>hexo n  page “postName”</td>\n<td>#新建页面</td>\n</tr>\n<tr>\n<td>hexo generate</td>\n<td>hexo g</td>\n<td>#生成静态页面至public目录</td>\n</tr>\n<tr>\n<td>hexo server</td>\n<td>hexo s</td>\n<td>#开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</td>\n</tr>\n<tr>\n<td>hexo deploy</td>\n<td>hexo d</td>\n<td>#将.deploy目录部署到GitHub</td>\n</tr>\n<tr>\n<td>hexo help</td>\n<td>\\</td>\n<td># 查看帮助</td>\n</tr>\n<tr>\n<td>hexo version</td>\n<td>\\</td>\n<td>#查看Hexo的版本</td>\n</tr>\n</tbody>\n</table>\n<blockquote><p>参考 :</p>\n<p><a href=\"https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy之后，页面长时间404\" target=\"_blank\" rel=\"external\">Hexo常见问题解决方案</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">Hexo 文档</a></p>\n<p><a href=\"http://www.cnblogs.com/zhcncn/p/4097881.html\" target=\"_blank\" rel=\"external\">Hexo搭建Github静态博客</a></p>\n</blockquote>\n","excerpt":"<h4 id=\"hexo-基础搭建\"><a href=\"#hexo-基础搭建\" class=\"headerlink\" title=\"hexo 基础搭建\"></a>hexo 基础搭建</h4><ul>\n<li><p>安装 hexo</p>\n<p>  $ npm install -g hexo-cli</p>\n</li>\n<li><p>随便建一个目录</p>\n<p>  mkdir hexo_test</p>\n</li>\n<li><p>初始化文件夹 ( 在hexo_test 外面 )</p>\n<p>  hexo init hexo_test</p>\n</li>\n<li><p>进入 hexo_test</p>\n<p>  cd hexo_test</p>\n</li>\n<li><p>npm 初始化</p>\n<p>  npm install</p>\n</li>\n<li><p>然后就可以看到有许多文件夹</p>\n</li>\n</ul>","more":"<ul>\n<li><p>生成静态页面</p>\n<ul>\n<li><p>hexo generate（hexo g也可以）</p>\n</li>\n<li><p>在 public 某个目录里( 默认是现在的时间) 有一个新生成的 yourpostname.html 文件。</p>\n</li>\n</ul>\n</li>\n<li><p>启动本地服务，进行文章预览调试</p>\n<p>  hexo server</p>\n</li>\n<li><p>打开 <a href=\"http://localhost:4000\">http://localhost:4000</a></p>\n</li>\n<li><p>注意 ！ 这里我有个错误提示</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/Release/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/default/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div><div class=\"line\">&#123;[Error: Cannot find module <span class=\"string\">'./build/Debug/DTraceProviderBindings'</span>] code: <span class=\"string\">'MODULE_NOT_FOUND'</span> &#125;</div></pre></td></tr></table></figure>\n<p>先查到用这个 npm install hexo –no-optional,<br>但是对我没用</p>\n<p><strong>(至今还未解决)</strong></p>\n<ul>\n<li><p>新添加一篇 post</p>\n<ul>\n<li><p>hexo new “Hey”</p>\n</li>\n<li><p>在 hexo_test/source/_post 中生成 一个为 Hey.md 的文件。</p>\n</li>\n</ul>\n</li>\n<li><p>如果你没有起 server 的话，可能需要执行 hexo generate 来生成静态页面</p>\n</li>\n<li><p>再去刷新一下页面，发现页面上新增了 Hey 这个 post，但是没有内容。</p>\n</li>\n<li><p>进入source/_post/Hey.md 你就可以编辑这篇文章的内容了</p>\n<ul>\n<li>然后保存， 你就可以在网页中看到你文章的内容了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"部署到-github-io-上\"><a href=\"#部署到-github-io-上\" class=\"headerlink\" title=\"部署到 github.io 上\"></a>部署到 github.io 上</h4><ul>\n<li><p>在根目录下找到 _config.yml 文件, 并打开</p>\n</li>\n<li><p>找到 这部分(在最后)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改上述地方</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:vivian-xu/vivian-xu.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h5 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意!\"></a>注意!</h5><ul>\n<li>repository：必须是SSH形式的url (如上)，而不能是HTTPS形式的url（<a href=\"https://github.com/***/***.github.io.git），\">https://github.com/***/***.github.io.git），</a></li>\n<li>如果你使用SSH url，但是电脑没有开放SSH 端口，会致部署失败。</li>\n<li><p>如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 ( <strong>看到这个，我把我的 branch 改成 gh-pages了</strong> )</p>\n<ul>\n<li>然后 hexo deploy</li>\n</ul>\n<h5 id=\"报错-ERROR-Deployer-not-found-git\"><a href=\"#报错-ERROR-Deployer-not-found-git\" class=\"headerlink\" title=\"报错 ERROR Deployer not found: git\"></a>报错 ERROR Deployer not found: git</h5><p>解决方法： npm install hexo-deployer-git –save</p>\n</li>\n<li><p>hexo deploy  成功！</p>\n</li>\n<li><p>然后我去 github 我的 vivian-xu.github.io.git 的仓库里切换了，分支看了一下，有传进来的！</p>\n</li>\n<li><p>然后我去访问 vivian-xu.github.io.git/hexo_test/</p>\n<p>结果 404 ….</p>\n<p>于是我在网上搜索问题, 先是找 gh-pages 相关，但是没解决我问题。之后我又去 git 仓库看了下，确保没有什么问题，看着我的 gh-pages 分支，很是疑惑，东西都在，怎么能访问不了。</p>\n<p>看着 gh-pages 我有些疑虑文档里所说的 gh-pages 名字是我建的 文件夹名么。。。 我的文件夹在本地，而且文件夹名没有一起更新到 github 的 vivian-xu.github.io 的 gh-pages 中，github 怎么会知道我的文件夹名。。</p>\n<p>然后我在 hexo 的 <a href=\"https://github.com/hexojs/hexo/issues/350\">这个issue</a> 里看到回答。</p>\n</li>\n</ul>\n<blockquote><p><em>yourname.github.io形式的库，会解析master分支；而别的名字的库，会解析gh-pages分支，以yourname.github.io/库名的形式访问。 </em></p>\n</blockquote>\n<p>  这个更加让我相信是名字的问题，于是，我重新建了一个库，然后把 _config.yml 的 git 相关的文件改了</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">type: git</div><div class=\"line\">repository: git@github.com:vivian-xu/hexo_test.git // 新库地址</div><div class=\"line\">branch: gh-pages</div></pre></td></tr></table></figure>\n<ul>\n<li><p>然后重新生成，deploy，检查了下新的 git 的仓库确保文件传了进去</p>\n</li>\n<li><p>之后打开 vivian-xu.github.io/hexo_test/  已经不再是 404 了！但是。为什么没有样式。。</p>\n</li>\n<li><p>打开 chorme 的调试工具，发现 css js 的路径都不对( 类似这样的 <a href=\"https://vivian-xu.github.io/fancybox/jquery.fancybox.css\">https://vivian-xu.github.io/fancybox/jquery.fancybox.css</a> )，应该是 <a href=\"https://vivian-xu.github.io/hexo_test/***\">https://vivian-xu.github.io/hexo_test/***</a> 。于是，又去看了 issue ，看到这个 <a href=\"https://github.com/hexojs/hexo/issues/1121\">https://github.com/hexojs/hexo/issues/1121</a></p>\n<p>意识到自己要配 root ( 自己的网站还要配 CNAME )</p>\n<p>于是又修改了 _config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /hexo_test/</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div></pre></td></tr></table></figure>\n</li>\n<li><p>再次 hexo g -d ，打开页面 终于成功了！！</p>\n<p>现在是这个样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site 站点</div><div class=\"line\">title: Vivian</div><div class=\"line\">subtitle:</div><div class=\"line\">description: Vvian&apos;s blog</div><div class=\"line\">keywords:</div><div class=\"line\">  - HTML</div><div class=\"line\">  - JavaScript</div><div class=\"line\">  - CSS</div><div class=\"line\">  - React</div><div class=\"line\">author: Vivian</div><div class=\"line\">language: zh-CN #语言</div><div class=\"line\">timezone: Asia/Shanghai #时区</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com #用于绑定域名, 其他的不需要配置</div><div class=\"line\">root: /hexo_test/</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags #标签</div><div class=\"line\">archive_dir: archives  #归档</div><div class=\"line\">category_dir: categories #分类</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post #默认模板(post page photo draft)</div><div class=\"line\">titlecase: false # Transform title into titlecase  #标题转换成大写</div><div class=\"line\">external_link: true # Open external links in new tab #新标签页里打开连接</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:  #语法高亮</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true #显示行号</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized #默认分类</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"># theme: ninja</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  # repository: git@github.com:vivian-xu/vivian-xu.github.io.git</div><div class=\"line\">  repository: git@github.com:vivian-xu/blog.git</div><div class=\"line\">  branch: gh-pages</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"theme-主题\"><a href=\"#theme-主题\" class=\"headerlink\" title=\"theme 主题\"></a>theme 主题</h4><ul>\n<li><p>挑选一个喜欢的 theme, git clone theme/ theme_name 下</p>\n</li>\n<li><p>将网站的 _config.yml 的 theme 改成你要的换的主题的名字</p>\n</li>\n<li><p>根据主题的文档，修改 _config.yml ( 包括网站的和主题的 )</p>\n</li>\n<li><p>生成网页并且 开启 server 调试下，然后自己不满意的地方，手动改改模版。</p>\n</li>\n</ul>\n<h4 id=\"管理源代码\"><a href=\"#管理源代码\" class=\"headerlink\" title=\"管理源代码\"></a>管理源代码</h4><p>经某人提醒，我的源代码没有管理，所以又开了一个库用来管理这一整套的源代码。然后想直接在主页面上展示博客首页就好了，于是将 branch 变成了 master。 再次生成，deploy。</p>\n<h4 id=\"部署到自己的域名上\"><a href=\"#部署到自己的域名上\" class=\"headerlink\" title=\"部署到自己的域名上\"></a>部署到自己的域名上</h4><ul>\n<li><p>因为，如果直接将我的域名，解析道 git 的这个网页的话，要改 CNAME (  只能有一个 )，而我的邮箱还是指向原来服务器的，感觉不太好，于是就保持原来的方式了。直接将静态文件 copy 到服务器下保存。</p>\n</li>\n<li><p>用了一套简单的 CI 系统，将 GitHub 设置成有新的 push 的时候发消息给 CI, CI 自动 pull 下来代码，然后测试，到服务器指定的文件夹里。</p>\n</li>\n</ul>\n<p>到这，基本上就结束了。当然，我觉得，我会没事改改这个 theme 的代码的～～</p>\n<h4 id=\"hexo-部分指令\"><a href=\"#hexo-部分指令\" class=\"headerlink\" title=\"hexo 部分指令\"></a>hexo 部分指令</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>简写</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hexo new “postName”</td>\n<td>hexo n “postName”</td>\n<td>#新建文章</td>\n</tr>\n<tr>\n<td>hexo new page “pageName”</td>\n<td>hexo n  page “postName”</td>\n<td>#新建页面</td>\n</tr>\n<tr>\n<td>hexo generate</td>\n<td>hexo g</td>\n<td>#生成静态页面至public目录</td>\n</tr>\n<tr>\n<td>hexo server</td>\n<td>hexo s</td>\n<td>#开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</td>\n</tr>\n<tr>\n<td>hexo deploy</td>\n<td>hexo d</td>\n<td>#将.deploy目录部署到GitHub</td>\n</tr>\n<tr>\n<td>hexo help</td>\n<td>\\</td>\n<td># 查看帮助</td>\n</tr>\n<tr>\n<td>hexo version</td>\n<td>\\</td>\n<td>#查看Hexo的版本</td>\n</tr>\n</tbody>\n</table>\n<blockquote><p>参考 :</p>\n<p><a href=\"https://xuanwo.org/2014/08/14/hexo-usual-problem/#Deploy之后，页面长时间404\">Hexo常见问题解决方案</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo 文档</a></p>\n<p><a href=\"http://www.cnblogs.com/zhcncn/p/4097881.html\">Hexo搭建Github静态博客</a></p>\n</blockquote>"},{"title":"折叠外边距 ( Collapsing margins )","auto_spacing":true,"_content":"\n大概一年前看过的知识，如今已经忘得一干二净，重新再来一遍！\n\n#### 基本定义\n\n在 CSS, __毗邻__ 的 2+ 个盒子 ( 不一定是兄弟元素 ) 的 margins 会合并成一个 Margin。Margins 的这种合并行为被称作 collapse, 产生的这个合并了的外边距被称为折叠外边距 (collapsed margin)。\n\n\n<!-- more -->\n\n#### 什么是相邻的盒子 ( 两点 )\n\n- 这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开 ( 形成间隙 )。( 一种是嵌套，一种是平行 )\n\n- 这些 margin 都处于 __普通流__中。 ( 1. 非浮动元素 2. 非绝对定位元素 )\n\n\n如下图：\n\n  - Box-1 , Box-2 嵌套，相邻\n  - Box-1 , Box-3 平行，相邻\n\n![](http://img.jackon.me/margins1.png)\n\nhtml 代码\n```\n// html 代码\n// Box-1 , Box-2 嵌套\n<div style=\"width: 150px; height: 150px; border: 5px solid red; border-top: none; margin: 40px 0; background: blue; color: #fff; font-size: 20px;\" >\n  <div style=\" width: 100px; height: 100px; background: yellow; margin-top: 15px; color: #000;\" >\n    Box-2\n  </div>\n  Box-1\n</div>\n\n// Box-1 Box-3 平行\n<div style=\"width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;\" >\n  Box-3\n</div>\n```\n\n**NOTE: clearance  ( 间隙 )**\n\n当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。\n\n--- \n\n\n\n#### 哪些会发生 margin 折叠\n\n- 元素自身的 __margin-bottom__ 和 __margin-top__ __相邻__时也会折叠\n\n- __两个或多个 毗邻的普通流中__的 __块元素垂直方向__上的 margin 会折叠\n\n  要点：\n\n  + 两个或多个 （数量必须是大于一）\n\n  + 必须是块元素\n\n  + 只能是垂直方向\n\nNOTE: 在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在父元素的 height 是 \"__auto__\" 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。\n\n#### 哪些不会发生 margin 折叠\n\n- 创建 BFC 的元素，不与其子元素发生 margin 折叠\n\n- 浮动元素，绝对定位元素不与任何元素发生 margin 折叠 ( 不在普通流，创建 BFC )\n\n- inline-block 元素，不与任何元素发生 margin 折叠  ( 不是 块级盒子  block-level box )\n\n#### 结果\n\n- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 (  __+ +__  取大)\n\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 ( __- -__  取绝对值大的 )\n\n- 两个外边距一正一负时，折叠结果是两者的相加的和。( - + 相加 )\n\n\n{% blockquote %}\n\n参考：\n\n[W3help:KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n\n[KB010: 常规流( Normal flow )](http://w3help.org/zh-cn/kb/010/)\n\n{% endblockquote %}\n","source":"_posts/margin collaspe.md","raw":"---\ntitle: 折叠外边距 ( Collapsing margins )\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- CSS 布局\n- margin\nauto_spacing: true\n---\n\n大概一年前看过的知识，如今已经忘得一干二净，重新再来一遍！\n\n#### 基本定义\n\n在 CSS, __毗邻__ 的 2+ 个盒子 ( 不一定是兄弟元素 ) 的 margins 会合并成一个 Margin。Margins 的这种合并行为被称作 collapse, 产生的这个合并了的外边距被称为折叠外边距 (collapsed margin)。\n\n\n<!-- more -->\n\n#### 什么是相邻的盒子 ( 两点 )\n\n- 这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开 ( 形成间隙 )。( 一种是嵌套，一种是平行 )\n\n- 这些 margin 都处于 __普通流__中。 ( 1. 非浮动元素 2. 非绝对定位元素 )\n\n\n如下图：\n\n  - Box-1 , Box-2 嵌套，相邻\n  - Box-1 , Box-3 平行，相邻\n\n![](http://img.jackon.me/margins1.png)\n\nhtml 代码\n```\n// html 代码\n// Box-1 , Box-2 嵌套\n<div style=\"width: 150px; height: 150px; border: 5px solid red; border-top: none; margin: 40px 0; background: blue; color: #fff; font-size: 20px;\" >\n  <div style=\" width: 100px; height: 100px; background: yellow; margin-top: 15px; color: #000;\" >\n    Box-2\n  </div>\n  Box-1\n</div>\n\n// Box-1 Box-3 平行\n<div style=\"width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;\" >\n  Box-3\n</div>\n```\n\n**NOTE: clearance  ( 间隙 )**\n\n当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。\n\n--- \n\n\n\n#### 哪些会发生 margin 折叠\n\n- 元素自身的 __margin-bottom__ 和 __margin-top__ __相邻__时也会折叠\n\n- __两个或多个 毗邻的普通流中__的 __块元素垂直方向__上的 margin 会折叠\n\n  要点：\n\n  + 两个或多个 （数量必须是大于一）\n\n  + 必须是块元素\n\n  + 只能是垂直方向\n\nNOTE: 在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在父元素的 height 是 \"__auto__\" 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。\n\n#### 哪些不会发生 margin 折叠\n\n- 创建 BFC 的元素，不与其子元素发生 margin 折叠\n\n- 浮动元素，绝对定位元素不与任何元素发生 margin 折叠 ( 不在普通流，创建 BFC )\n\n- inline-block 元素，不与任何元素发生 margin 折叠  ( 不是 块级盒子  block-level box )\n\n#### 结果\n\n- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 (  __+ +__  取大)\n\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 ( __- -__  取绝对值大的 )\n\n- 两个外边距一正一负时，折叠结果是两者的相加的和。( - + 相加 )\n\n\n{% blockquote %}\n\n参考：\n\n[W3help:KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n\n[KB010: 常规流( Normal flow )](http://w3help.org/zh-cn/kb/010/)\n\n{% endblockquote %}\n","slug":"margin collaspe","published":1,"date":"2016-12-11T07:57:56.000Z","updated":"2016-12-11T14:40:40.000Z","_id":"ciwkdsbcm0007k2ra2bdm3z67","comments":1,"layout":"post","photos":[],"link":"","content":"<p>大概一年前看过的知识，如今已经忘得一干二净，重新再来一遍！</p>\n<h4 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h4><p>在 CSS, <strong>毗邻</strong> 的 2+ 个盒子 ( 不一定是兄弟元素 ) 的 margins 会合并成一个 Margin。Margins 的这种合并行为被称作 collapse, 产生的这个合并了的外边距被称为折叠外边距 (collapsed margin)。</p>\n<a id=\"more\"></a>\n<h4 id=\"什么是相邻的盒子-两点\"><a href=\"#什么是相邻的盒子-两点\" class=\"headerlink\" title=\"什么是相邻的盒子 ( 两点 )\"></a>什么是相邻的盒子 ( 两点 )</h4><ul>\n<li><p>这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开 ( 形成间隙 )。( 一种是嵌套，一种是平行 )</p>\n</li>\n<li><p>这些 margin 都处于 <strong>普通流</strong>中。 ( 1. 非浮动元素 2. 非绝对定位元素 )</p>\n</li>\n</ul>\n<p>如下图：</p>\n<ul>\n<li>Box-1 , Box-2 嵌套，相邻</li>\n<li>Box-1 , Box-3 平行，相邻</li>\n</ul>\n<p><img src=\"http://img.jackon.me/margins1.png\" alt=\"\"></p>\n<p>html 代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// html 代码</div><div class=\"line\">// Box-1 , Box-2 嵌套</div><div class=\"line\">&lt;div style=&quot;width: 150px; height: 150px; border: 5px solid red; border-top: none; margin: 40px 0; background: blue; color: #fff; font-size: 20px;&quot; &gt;</div><div class=\"line\">  &lt;div style=&quot; width: 100px; height: 100px; background: yellow; margin-top: 15px; color: #000;&quot; &gt;</div><div class=\"line\">    Box-2</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">  Box-1</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">// Box-1 Box-3 平行</div><div class=\"line\">&lt;div style=&quot;width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;&quot; &gt;</div><div class=\"line\">  Box-3</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>NOTE: clearance  ( 间隙 )</strong></p>\n<p>当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。</p>\n<hr>\n<h4 id=\"哪些会发生-margin-折叠\"><a href=\"#哪些会发生-margin-折叠\" class=\"headerlink\" title=\"哪些会发生 margin 折叠\"></a>哪些会发生 margin 折叠</h4><ul>\n<li><p>元素自身的 <strong>margin-bottom</strong> 和 <strong>margin-top</strong> <strong>相邻</strong>时也会折叠</p>\n</li>\n<li><p><strong>两个或多个 毗邻的普通流中</strong>的 <strong>块元素垂直方向</strong>上的 margin 会折叠</p>\n<p>要点：</p>\n<ul>\n<li><p>两个或多个 （数量必须是大于一）</p>\n</li>\n<li><p>必须是块元素</p>\n</li>\n<li><p>只能是垂直方向</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>NOTE: 在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在父元素的 height 是 “<strong>auto</strong>“ 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。</p>\n<h4 id=\"哪些不会发生-margin-折叠\"><a href=\"#哪些不会发生-margin-折叠\" class=\"headerlink\" title=\"哪些不会发生 margin 折叠\"></a>哪些不会发生 margin 折叠</h4><ul>\n<li><p>创建 BFC 的元素，不与其子元素发生 margin 折叠</p>\n</li>\n<li><p>浮动元素，绝对定位元素不与任何元素发生 margin 折叠 ( 不在普通流，创建 BFC )</p>\n</li>\n<li><p>inline-block 元素，不与任何元素发生 margin 折叠  ( 不是 块级盒子  block-level box )</p>\n</li>\n</ul>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><ul>\n<li><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 (  <strong>+ +</strong>  取大)</p>\n</li>\n<li><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 ( <strong>- -</strong>  取绝对值大的 )</p>\n</li>\n<li><p>两个外边距一正一负时，折叠结果是两者的相加的和。( - + 相加 )</p>\n</li>\n</ul>\n<blockquote><p>参考：</p>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/\" target=\"_blank\" rel=\"external\">W3help:KB006: CSS 框模型( Box module )</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/010/\" target=\"_blank\" rel=\"external\">KB010: 常规流( Normal flow )</a></p>\n</blockquote>\n","excerpt":"<p>大概一年前看过的知识，如今已经忘得一干二净，重新再来一遍！</p>\n<h4 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h4><p>在 CSS, <strong>毗邻</strong> 的 2+ 个盒子 ( 不一定是兄弟元素 ) 的 margins 会合并成一个 Margin。Margins 的这种合并行为被称作 collapse, 产生的这个合并了的外边距被称为折叠外边距 (collapsed margin)。</p>","more":"<h4 id=\"什么是相邻的盒子-两点\"><a href=\"#什么是相邻的盒子-两点\" class=\"headerlink\" title=\"什么是相邻的盒子 ( 两点 )\"></a>什么是相邻的盒子 ( 两点 )</h4><ul>\n<li><p>这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开 ( 形成间隙 )。( 一种是嵌套，一种是平行 )</p>\n</li>\n<li><p>这些 margin 都处于 <strong>普通流</strong>中。 ( 1. 非浮动元素 2. 非绝对定位元素 )</p>\n</li>\n</ul>\n<p>如下图：</p>\n<ul>\n<li>Box-1 , Box-2 嵌套，相邻</li>\n<li>Box-1 , Box-3 平行，相邻</li>\n</ul>\n<p><img src=\"http://img.jackon.me/margins1.png\" alt=\"\"></p>\n<p>html 代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// html 代码</div><div class=\"line\">// Box-1 , Box-2 嵌套</div><div class=\"line\">&lt;div style=&quot;width: 150px; height: 150px; border: 5px solid red; border-top: none; margin: 40px 0; background: blue; color: #fff; font-size: 20px;&quot; &gt;</div><div class=\"line\">  &lt;div style=&quot; width: 100px; height: 100px; background: yellow; margin-top: 15px; color: #000;&quot; &gt;</div><div class=\"line\">    Box-2</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">  Box-1</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">// Box-1 Box-3 平行</div><div class=\"line\">&lt;div style=&quot;width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;&quot; &gt;</div><div class=\"line\">  Box-3</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>NOTE: clearance  ( 间隙 )</strong></p>\n<p>当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。</p>\n<hr>\n<h4 id=\"哪些会发生-margin-折叠\"><a href=\"#哪些会发生-margin-折叠\" class=\"headerlink\" title=\"哪些会发生 margin 折叠\"></a>哪些会发生 margin 折叠</h4><ul>\n<li><p>元素自身的 <strong>margin-bottom</strong> 和 <strong>margin-top</strong> <strong>相邻</strong>时也会折叠</p>\n</li>\n<li><p><strong>两个或多个 毗邻的普通流中</strong>的 <strong>块元素垂直方向</strong>上的 margin 会折叠</p>\n<p>要点：</p>\n<ul>\n<li><p>两个或多个 （数量必须是大于一）</p>\n</li>\n<li><p>必须是块元素</p>\n</li>\n<li><p>只能是垂直方向</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>NOTE: 在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻； 只有在父元素的 height 是 “<strong>auto</strong>“ 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。</p>\n<h4 id=\"哪些不会发生-margin-折叠\"><a href=\"#哪些不会发生-margin-折叠\" class=\"headerlink\" title=\"哪些不会发生 margin 折叠\"></a>哪些不会发生 margin 折叠</h4><ul>\n<li><p>创建 BFC 的元素，不与其子元素发生 margin 折叠</p>\n</li>\n<li><p>浮动元素，绝对定位元素不与任何元素发生 margin 折叠 ( 不在普通流，创建 BFC )</p>\n</li>\n<li><p>inline-block 元素，不与任何元素发生 margin 折叠  ( 不是 块级盒子  block-level box )</p>\n</li>\n</ul>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><ul>\n<li><p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 (  <strong>+ +</strong>  取大)</p>\n</li>\n<li><p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 ( <strong>- -</strong>  取绝对值大的 )</p>\n</li>\n<li><p>两个外边距一正一负时，折叠结果是两者的相加的和。( - + 相加 )</p>\n</li>\n</ul>\n<blockquote><p>参考：</p>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/\">W3help:KB006: CSS 框模型( Box module )</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/010/\">KB010: 常规流( Normal flow )</a></p>\n</blockquote>"},{"_content":"float 元素\n\n影响 inline 元素，\n不影响 block 元素\n\n![](http://img.jackon.me/float.png)\n\nfloat 阻挡了 inline 但却没有阻挡 block\n\n```\n<div style=\"float:left; width: 80px; height: 100px; background-color: lightcoral; margin: 40px 0; font-size: 20px;\">\n  float\n</div>\n\n<!--   Box-3 -->\n<div style=\"width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;\" >\n  <div style=\"background  -color: teal; width: 90px; height: 50px; color: #fff; \" > </div>\n  <span style=\"background-color: #47cf73; padding: 5px; font-size: 12px;\" >Box-3 inner inline span</span>\n</div>\n\n```\n","source":"_drafts/float.md","raw":"float 元素\n\n影响 inline 元素，\n不影响 block 元素\n\n![](http://img.jackon.me/float.png)\n\nfloat 阻挡了 inline 但却没有阻挡 block\n\n```\n<div style=\"float:left; width: 80px; height: 100px; background-color: lightcoral; margin: 40px 0; font-size: 20px;\">\n  float\n</div>\n\n<!--   Box-3 -->\n<div style=\"width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;\" >\n  <div style=\"background  -color: teal; width: 90px; height: 50px; color: #fff; \" > </div>\n  <span style=\"background-color: #47cf73; padding: 5px; font-size: 12px;\" >Box-3 inner inline span</span>\n</div>\n\n```\n","slug":"float","published":0,"date":"2016-12-11T08:39:40.000Z","updated":"2016-12-16T05:47:22.000Z","_id":"ciwkegbmh000ck2ragz3ctvkb","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>float 元素</p>\n<p>影响 inline 元素，<br>不影响 block 元素</p>\n<p><img src=\"http://img.jackon.me/float.png\" alt=\"\"></p>\n<p>float 阻挡了 inline 但却没有阻挡 block</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;float:left; width: 80px; height: 100px; background-color: lightcoral; margin: 40px 0; font-size: 20px;&quot;&gt;</div><div class=\"line\">  float</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!--   Box-3 --&gt;</div><div class=\"line\">&lt;div style=&quot;width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;&quot; &gt;</div><div class=\"line\">  &lt;div style=&quot;background  -color: teal; width: 90px; height: 50px; color: #fff; &quot; &gt; &lt;/div&gt;</div><div class=\"line\">  &lt;span style=&quot;background-color: #47cf73; padding: 5px; font-size: 12px;&quot; &gt;Box-3 inner inline span&lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>float 元素</p>\n<p>影响 inline 元素，<br>不影响 block 元素</p>\n<p><img src=\"http://img.jackon.me/float.png\" alt=\"\"></p>\n<p>float 阻挡了 inline 但却没有阻挡 block</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot;float:left; width: 80px; height: 100px; background-color: lightcoral; margin: 40px 0; font-size: 20px;&quot;&gt;</div><div class=\"line\">  float</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!--   Box-3 --&gt;</div><div class=\"line\">&lt;div style=&quot;width: 100px; height: 100px; background-color: lightblue; margin: 40px 0; font-size: 20px;&quot; &gt;</div><div class=\"line\">  &lt;div style=&quot;background  -color: teal; width: 90px; height: 50px; color: #fff; &quot; &gt; &lt;/div&gt;</div><div class=\"line\">  &lt;span style=&quot;background-color: #47cf73; padding: 5px; font-size: 12px;&quot; &gt;Box-3 inner inline span&lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n"},{"title":"this","auto_spacing":true,"_content":"\nthis 是个坑，学习一下，期待以后掉坑的几率越来越小～\n\n#### 基本知识\n\n- js中严格模式和非严格模式中的 this 会有所不同\n\n- 大部分情况下，函数的调用方式决定了 this 的值。\n\n- this在执行中不能被赋值，同一个函数会因为不同的调用而导致 this 的不同\n\n- bind 方法可以直接设置 this 而不用考虑如何被调用\n\n<!-- more  -->\n\n#### this 在全局上下文中\n\n在全局上下文中（任何函数体外），this 指代全局对象。\n\n```\nconsole.log(this.document === document); // true\n\n// 在浏览器中，全局对象为 window 对象：\nconsole.log(this === window); // true\n\nthis.a = 37;\nconsole.log(window.a); // 37\n```\n#### 函数上下文中\n\n取决于函数如何被调用\n\n- 直接调用\n\n在严格模式下，this 是在进入运行环境的时候设置的，若没有设置，则 this 维持 undefined, 同时它还能设置成任意值，比如 null, 3, 'hey'。\n\n```\nfunction f1() {\n  return this;\n}\n\nf1() === window; // true, 严格模式下为 undefined\n```\n\n- 作为方法被调用\n\n  则指向调用该函数的对象 ( 离得最近的 . 之前的对象 ）\n\n```\nvar o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\n\nconsole.log(o.f());  // 37\n```\n\n只指向直接调用它的对象\n\n```\no.b = {\n  g: independent,\n  prop: 42\n};\nconsole.log(o.b.g()); // logs 42 指向 o.b\n```\n\n无论在何处如何定义函数都不会影响到 this 的指向行为\n\n```\nvar o = {prop: 37};\nfunction independent() {\n  return this.prop;\n}\no.f = independent;\nconsole.log(o.f()); //37\n```\n\n- 原型链上的 this\n\n如果该方法存在于一个对象的原型链上，那么 this 依旧是指向 调用这个函数的 对象。\n```\nvar o = {\n  f: function() {\n    return this.a + this.b;\n  }\n}\n\nvar p = Object.create(o);\np.a = 1;\np.b = 3;\n\nconsole.log(p.f()); // 4\n```\n在这个例子里，o 是 p 的原型，p自身 是没有属于自己的 f 方法的，它的 f 方法继承于它的 原型 o, 查找的过程是从 p.f 开始的，所以，this 就指向 p\n\n- getter 和 setter 中的 this\n\n当函数做为 getter setter 调用的时候，this 会绑定到设置属性 ／ 得到属性的对象。\n\n```\nfunction modulus(){\n  return Math.sqrt(this.re * this.re + this.im * this.im);\n}\n\n\nvar o = {\n  re: 1,\n  im: -1,\n  get phase(){\n    return Math.atan2(this.im, this.re);\n  }\n};\n\nObject.definePorperty(o, 'modulus', {\nget: modulus,\nenumerable:true,\nconfigurable: true\n} )\n\nconsole.log(o.phase, o.modulus ); // logs -0.78 1.4142\n\n```\n- 构造函数中的 this\n\n当一个函数被作为构造来使用 ( 使用 new 关键字 ), this 被绑定在即将创建的新对象。\n\n__NOTE: 当构造函数里有 return 语句并且 return 一个 Object 的时候，返回这个 Object, 否则就返回 this 绑定的结果( envRec.GetThisBinding() ) __\n\n```\nfunction C(){\n  this.a = 37;\n}\n\nvar o = new C();\nconsole.log(o.a); // 37\n\nfunction C2(){\n  this.a = 37;\n  return {a:38};\n}\no = new C2();\nconsole.log(o.a); // 38\n```\n- call 和 apply\n\n当一个函数的函数体中使用了 this 关键字，用 call, 或者 apply 方法调用函数的时候，this 的值绑定到一个指定的对象\n\n```\nfunction add(c, d){\n  return this.a + this.b + c + d;\n}\n\nvar o = {a:1, b:3};\n\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n\n使用 call / apply 时，如果指定的 this 不是一个  object 类型，则会使用相应的包装类型函数 将它们包装成 object.\n\n```\nfunction bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7); // [object Number] ,  7 被 使用 new Number(7) 包装\n```\n- bind 方法\n使用 Function.prototype.bind 方法绑定 this 到第一个参数上， 无论这个函数时何处何时调用的， this 的指向不变\n\n```\nfunction f(){\n  return this.a;\n}\n\nvar g = f.bind({a:\"azerty\"}); // 将 f 的 this 绑定在 {a: \"azerty\"} 上\nconsole.log(g()); // azerty\n\nvar o = {a:37, f:f, g:g};\nconsole.log(o.f(), o.g()); // 37, azerty\n```\n\n- Dom事件处理函数中的 this\n\n当函数被作为 事件处理函数的时候 this 指向触发该事件的元素( e.currentTarget)\n\n```\n// 被调用时，将关联的元素变成蓝色\nfunction bluify(e){\n  console.log(this === e.currentTarget); // 总是 true\n\n  // 当 currentTarget 和 target 是同一个对象是为 true\n  console.log(this === e.target);\n  this.style.backgroundColor = '#A5D9F3';\n}\n\n// 获取文档中的所有元素的列表\nvar elements = document.getElementsByTagName('*');\n\n// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色\nfor(var i=0 ; i<elements.length ; i++){\n  elements[i].addEventListener('click', bluify, false);\n```\n\n- 内联事件的处理函数\n\n this 指向监听器所在的dom 元素\n ```\n <button onclick=\"alert(this.tagName.toLowerCase());\">\n   Show this\n </button>\n ```\n下面这个样子的 this 会指向全局对象\n ```\n <button onclick=\"alert((function(){return this})());\">\n   Show inner this\n </button>\n ```\n\n{% blockquote %}\n\n参考链接：\n\n[MDN: this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n\n","source":"_posts/this.md","raw":"---\ntitle: this\ncategories:\n- 编程\ntags:\n- 吵吵吵\n- JS 基础\nauto_spacing: true\n---\n\nthis 是个坑，学习一下，期待以后掉坑的几率越来越小～\n\n#### 基本知识\n\n- js中严格模式和非严格模式中的 this 会有所不同\n\n- 大部分情况下，函数的调用方式决定了 this 的值。\n\n- this在执行中不能被赋值，同一个函数会因为不同的调用而导致 this 的不同\n\n- bind 方法可以直接设置 this 而不用考虑如何被调用\n\n<!-- more  -->\n\n#### this 在全局上下文中\n\n在全局上下文中（任何函数体外），this 指代全局对象。\n\n```\nconsole.log(this.document === document); // true\n\n// 在浏览器中，全局对象为 window 对象：\nconsole.log(this === window); // true\n\nthis.a = 37;\nconsole.log(window.a); // 37\n```\n#### 函数上下文中\n\n取决于函数如何被调用\n\n- 直接调用\n\n在严格模式下，this 是在进入运行环境的时候设置的，若没有设置，则 this 维持 undefined, 同时它还能设置成任意值，比如 null, 3, 'hey'。\n\n```\nfunction f1() {\n  return this;\n}\n\nf1() === window; // true, 严格模式下为 undefined\n```\n\n- 作为方法被调用\n\n  则指向调用该函数的对象 ( 离得最近的 . 之前的对象 ）\n\n```\nvar o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\n\nconsole.log(o.f());  // 37\n```\n\n只指向直接调用它的对象\n\n```\no.b = {\n  g: independent,\n  prop: 42\n};\nconsole.log(o.b.g()); // logs 42 指向 o.b\n```\n\n无论在何处如何定义函数都不会影响到 this 的指向行为\n\n```\nvar o = {prop: 37};\nfunction independent() {\n  return this.prop;\n}\no.f = independent;\nconsole.log(o.f()); //37\n```\n\n- 原型链上的 this\n\n如果该方法存在于一个对象的原型链上，那么 this 依旧是指向 调用这个函数的 对象。\n```\nvar o = {\n  f: function() {\n    return this.a + this.b;\n  }\n}\n\nvar p = Object.create(o);\np.a = 1;\np.b = 3;\n\nconsole.log(p.f()); // 4\n```\n在这个例子里，o 是 p 的原型，p自身 是没有属于自己的 f 方法的，它的 f 方法继承于它的 原型 o, 查找的过程是从 p.f 开始的，所以，this 就指向 p\n\n- getter 和 setter 中的 this\n\n当函数做为 getter setter 调用的时候，this 会绑定到设置属性 ／ 得到属性的对象。\n\n```\nfunction modulus(){\n  return Math.sqrt(this.re * this.re + this.im * this.im);\n}\n\n\nvar o = {\n  re: 1,\n  im: -1,\n  get phase(){\n    return Math.atan2(this.im, this.re);\n  }\n};\n\nObject.definePorperty(o, 'modulus', {\nget: modulus,\nenumerable:true,\nconfigurable: true\n} )\n\nconsole.log(o.phase, o.modulus ); // logs -0.78 1.4142\n\n```\n- 构造函数中的 this\n\n当一个函数被作为构造来使用 ( 使用 new 关键字 ), this 被绑定在即将创建的新对象。\n\n__NOTE: 当构造函数里有 return 语句并且 return 一个 Object 的时候，返回这个 Object, 否则就返回 this 绑定的结果( envRec.GetThisBinding() ) __\n\n```\nfunction C(){\n  this.a = 37;\n}\n\nvar o = new C();\nconsole.log(o.a); // 37\n\nfunction C2(){\n  this.a = 37;\n  return {a:38};\n}\no = new C2();\nconsole.log(o.a); // 38\n```\n- call 和 apply\n\n当一个函数的函数体中使用了 this 关键字，用 call, 或者 apply 方法调用函数的时候，this 的值绑定到一个指定的对象\n\n```\nfunction add(c, d){\n  return this.a + this.b + c + d;\n}\n\nvar o = {a:1, b:3};\n\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n\n使用 call / apply 时，如果指定的 this 不是一个  object 类型，则会使用相应的包装类型函数 将它们包装成 object.\n\n```\nfunction bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7); // [object Number] ,  7 被 使用 new Number(7) 包装\n```\n- bind 方法\n使用 Function.prototype.bind 方法绑定 this 到第一个参数上， 无论这个函数时何处何时调用的， this 的指向不变\n\n```\nfunction f(){\n  return this.a;\n}\n\nvar g = f.bind({a:\"azerty\"}); // 将 f 的 this 绑定在 {a: \"azerty\"} 上\nconsole.log(g()); // azerty\n\nvar o = {a:37, f:f, g:g};\nconsole.log(o.f(), o.g()); // 37, azerty\n```\n\n- Dom事件处理函数中的 this\n\n当函数被作为 事件处理函数的时候 this 指向触发该事件的元素( e.currentTarget)\n\n```\n// 被调用时，将关联的元素变成蓝色\nfunction bluify(e){\n  console.log(this === e.currentTarget); // 总是 true\n\n  // 当 currentTarget 和 target 是同一个对象是为 true\n  console.log(this === e.target);\n  this.style.backgroundColor = '#A5D9F3';\n}\n\n// 获取文档中的所有元素的列表\nvar elements = document.getElementsByTagName('*');\n\n// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色\nfor(var i=0 ; i<elements.length ; i++){\n  elements[i].addEventListener('click', bluify, false);\n```\n\n- 内联事件的处理函数\n\n this 指向监听器所在的dom 元素\n ```\n <button onclick=\"alert(this.tagName.toLowerCase());\">\n   Show this\n </button>\n ```\n下面这个样子的 this 会指向全局对象\n ```\n <button onclick=\"alert((function(){return this})());\">\n   Show inner this\n </button>\n ```\n\n{% blockquote %}\n\n参考链接：\n\n[MDN: this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n\n_JS高级程序设计 ( 第3版 )_\n\n{% endblockquote %}\n\n","slug":"this","published":1,"date":"2016-12-05T08:47:24.000Z","updated":"2016-12-15T05:07:58.000Z","_id":"ciwlk309e0000fprav9dybs9x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>this 是个坑，学习一下，期待以后掉坑的几率越来越小～</p>\n<h4 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h4><ul>\n<li><p>js中严格模式和非严格模式中的 this 会有所不同</p>\n</li>\n<li><p>大部分情况下，函数的调用方式决定了 this 的值。</p>\n</li>\n<li><p>this在执行中不能被赋值，同一个函数会因为不同的调用而导致 this 的不同</p>\n</li>\n<li><p>bind 方法可以直接设置 this 而不用考虑如何被调用</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"this-在全局上下文中\"><a href=\"#this-在全局上下文中\" class=\"headerlink\" title=\"this 在全局上下文中\"></a>this 在全局上下文中</h4><p>在全局上下文中（任何函数体外），this 指代全局对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(this.document === document); // true</div><div class=\"line\"></div><div class=\"line\">// 在浏览器中，全局对象为 window 对象：</div><div class=\"line\">console.log(this === window); // true</div><div class=\"line\"></div><div class=\"line\">this.a = 37;</div><div class=\"line\">console.log(window.a); // 37</div></pre></td></tr></table></figure>\n<h4 id=\"函数上下文中\"><a href=\"#函数上下文中\" class=\"headerlink\" title=\"函数上下文中\"></a>函数上下文中</h4><p>取决于函数如何被调用</p>\n<ul>\n<li>直接调用</li>\n</ul>\n<p>在严格模式下，this 是在进入运行环境的时候设置的，若没有设置，则 this 维持 undefined, 同时它还能设置成任意值，比如 null, 3, ‘hey’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f1() &#123;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1() === window; // true, 严格模式下为 undefined</div></pre></td></tr></table></figure>\n<ul>\n<li><p>作为方法被调用</p>\n<p>则指向调用该函数的对象 ( 离得最近的 . 之前的对象 ）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  f: function() &#123;</div><div class=\"line\">    return this.prop;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(o.f());  // 37</div></pre></td></tr></table></figure>\n<p>只指向直接调用它的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">o.b = &#123;</div><div class=\"line\">  g: independent,</div><div class=\"line\">  prop: 42</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(o.b.g()); // logs 42 指向 o.b</div></pre></td></tr></table></figure>\n<p>无论在何处如何定义函数都不会影响到 this 的指向行为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;prop: 37&#125;;</div><div class=\"line\">function independent() &#123;</div><div class=\"line\">  return this.prop;</div><div class=\"line\">&#125;</div><div class=\"line\">o.f = independent;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<ul>\n<li>原型链上的 this</li>\n</ul>\n<p>如果该方法存在于一个对象的原型链上，那么 this 依旧是指向 调用这个函数的 对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;</div><div class=\"line\">  f: function() &#123;</div><div class=\"line\">    return this.a + this.b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = Object.create(o);</div><div class=\"line\">p.a = 1;</div><div class=\"line\">p.b = 3;</div><div class=\"line\"></div><div class=\"line\">console.log(p.f()); // 4</div></pre></td></tr></table></figure></p>\n<p>在这个例子里，o 是 p 的原型，p自身 是没有属于自己的 f 方法的，它的 f 方法继承于它的 原型 o, 查找的过程是从 p.f 开始的，所以，this 就指向 p</p>\n<ul>\n<li>getter 和 setter 中的 this</li>\n</ul>\n<p>当函数做为 getter setter 调用的时候，this 会绑定到设置属性 ／ 得到属性的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function modulus()&#123;</div><div class=\"line\">  return Math.sqrt(this.re * this.re + this.im * this.im);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var o = &#123;</div><div class=\"line\">  re: 1,</div><div class=\"line\">  im: -1,</div><div class=\"line\">  get phase()&#123;</div><div class=\"line\">    return Math.atan2(this.im, this.re);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Object.definePorperty(o, &apos;modulus&apos;, &#123;</div><div class=\"line\">get: modulus,</div><div class=\"line\">enumerable:true,</div><div class=\"line\">configurable: true</div><div class=\"line\">&#125; )</div><div class=\"line\"></div><div class=\"line\">console.log(o.phase, o.modulus ); // logs -0.78 1.4142</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数中的 this</li>\n</ul>\n<p>当一个函数被作为构造来使用 ( 使用 new 关键字 ), this 被绑定在即将创建的新对象。</p>\n<p><strong>NOTE: 当构造函数里有 return 语句并且 return 一个 Object 的时候，返回这个 Object, 否则就返回 this 绑定的结果( envRec.GetThisBinding() ) </strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function C()&#123;</div><div class=\"line\">  this.a = 37;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = new C();</div><div class=\"line\">console.log(o.a); // 37</div><div class=\"line\"></div><div class=\"line\">function C2()&#123;</div><div class=\"line\">  this.a = 37;</div><div class=\"line\">  return &#123;a:38&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">o = new C2();</div><div class=\"line\">console.log(o.a); // 38</div></pre></td></tr></table></figure>\n<ul>\n<li>call 和 apply</li>\n</ul>\n<p>当一个函数的函数体中使用了 this 关键字，用 call, 或者 apply 方法调用函数的时候，this 的值绑定到一个指定的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(c, d)&#123;</div><div class=\"line\">  return this.a + this.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a:1, b:3&#125;;</div><div class=\"line\"></div><div class=\"line\">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</div><div class=\"line\"></div><div class=\"line\">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</div></pre></td></tr></table></figure>\n<p>使用 call / apply 时，如果指定的 this 不是一个  object 类型，则会使用相应的包装类型函数 将它们包装成 object.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function bar() &#123;</div><div class=\"line\">  console.log(Object.prototype.toString.call(this));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar.call(7); // [object Number] ,  7 被 使用 new Number(7) 包装</div></pre></td></tr></table></figure>\n<ul>\n<li>bind 方法<br>使用 Function.prototype.bind 方法绑定 this 到第一个参数上， 无论这个函数时何处何时调用的， this 的指向不变</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f()&#123;</div><div class=\"line\">  return this.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;); // 将 f 的 this 绑定在 &#123;a: &quot;azerty&quot;&#125; 上</div><div class=\"line\">console.log(g()); // azerty</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a:37, f:f, g:g&#125;;</div><div class=\"line\">console.log(o.f(), o.g()); // 37, azerty</div></pre></td></tr></table></figure>\n<ul>\n<li>Dom事件处理函数中的 this</li>\n</ul>\n<p>当函数被作为 事件处理函数的时候 this 指向触发该事件的元素( e.currentTarget)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 被调用时，将关联的元素变成蓝色</div><div class=\"line\">function bluify(e)&#123;</div><div class=\"line\">  console.log(this === e.currentTarget); // 总是 true</div><div class=\"line\"></div><div class=\"line\">  // 当 currentTarget 和 target 是同一个对象是为 true</div><div class=\"line\">  console.log(this === e.target);</div><div class=\"line\">  this.style.backgroundColor = &apos;#A5D9F3&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 获取文档中的所有元素的列表</div><div class=\"line\">var elements = document.getElementsByTagName(&apos;*&apos;);</div><div class=\"line\"></div><div class=\"line\">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</div><div class=\"line\">for(var i=0 ; i&lt;elements.length ; i++)&#123;</div><div class=\"line\">  elements[i].addEventListener(&apos;click&apos;, bluify, false);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>内联事件的处理函数</p>\n<p>this 指向监听器所在的dom 元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt;</div><div class=\"line\">  Show this</div><div class=\"line\">&lt;/button&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面这个样子的 this 会指向全局对象<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt;</div><div class=\"line\">  Show inner this</div><div class=\"line\">&lt;/button&gt;</div></pre></td></tr></table></figure></p>\n<blockquote><p>参考链接：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">MDN: this</a></p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>\n","excerpt":"<p>this 是个坑，学习一下，期待以后掉坑的几率越来越小～</p>\n<h4 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h4><ul>\n<li><p>js中严格模式和非严格模式中的 this 会有所不同</p>\n</li>\n<li><p>大部分情况下，函数的调用方式决定了 this 的值。</p>\n</li>\n<li><p>this在执行中不能被赋值，同一个函数会因为不同的调用而导致 this 的不同</p>\n</li>\n<li><p>bind 方法可以直接设置 this 而不用考虑如何被调用</p>\n</li>\n</ul>","more":"<h4 id=\"this-在全局上下文中\"><a href=\"#this-在全局上下文中\" class=\"headerlink\" title=\"this 在全局上下文中\"></a>this 在全局上下文中</h4><p>在全局上下文中（任何函数体外），this 指代全局对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(this.document === document); // true</div><div class=\"line\"></div><div class=\"line\">// 在浏览器中，全局对象为 window 对象：</div><div class=\"line\">console.log(this === window); // true</div><div class=\"line\"></div><div class=\"line\">this.a = 37;</div><div class=\"line\">console.log(window.a); // 37</div></pre></td></tr></table></figure>\n<h4 id=\"函数上下文中\"><a href=\"#函数上下文中\" class=\"headerlink\" title=\"函数上下文中\"></a>函数上下文中</h4><p>取决于函数如何被调用</p>\n<ul>\n<li>直接调用</li>\n</ul>\n<p>在严格模式下，this 是在进入运行环境的时候设置的，若没有设置，则 this 维持 undefined, 同时它还能设置成任意值，比如 null, 3, ‘hey’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f1() &#123;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f1() === window; // true, 严格模式下为 undefined</div></pre></td></tr></table></figure>\n<ul>\n<li><p>作为方法被调用</p>\n<p>则指向调用该函数的对象 ( 离得最近的 . 之前的对象 ）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  f: function() &#123;</div><div class=\"line\">    return this.prop;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(o.f());  // 37</div></pre></td></tr></table></figure>\n<p>只指向直接调用它的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">o.b = &#123;</div><div class=\"line\">  g: independent,</div><div class=\"line\">  prop: 42</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(o.b.g()); // logs 42 指向 o.b</div></pre></td></tr></table></figure>\n<p>无论在何处如何定义函数都不会影响到 this 的指向行为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;prop: 37&#125;;</div><div class=\"line\">function independent() &#123;</div><div class=\"line\">  return this.prop;</div><div class=\"line\">&#125;</div><div class=\"line\">o.f = independent;</div><div class=\"line\">console.log(o.f()); //37</div></pre></td></tr></table></figure>\n<ul>\n<li>原型链上的 this</li>\n</ul>\n<p>如果该方法存在于一个对象的原型链上，那么 this 依旧是指向 调用这个函数的 对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o = &#123;</div><div class=\"line\">  f: function() &#123;</div><div class=\"line\">    return this.a + this.b;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = Object.create(o);</div><div class=\"line\">p.a = 1;</div><div class=\"line\">p.b = 3;</div><div class=\"line\"></div><div class=\"line\">console.log(p.f()); // 4</div></pre></td></tr></table></figure></p>\n<p>在这个例子里，o 是 p 的原型，p自身 是没有属于自己的 f 方法的，它的 f 方法继承于它的 原型 o, 查找的过程是从 p.f 开始的，所以，this 就指向 p</p>\n<ul>\n<li>getter 和 setter 中的 this</li>\n</ul>\n<p>当函数做为 getter setter 调用的时候，this 会绑定到设置属性 ／ 得到属性的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function modulus()&#123;</div><div class=\"line\">  return Math.sqrt(this.re * this.re + this.im * this.im);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var o = &#123;</div><div class=\"line\">  re: 1,</div><div class=\"line\">  im: -1,</div><div class=\"line\">  get phase()&#123;</div><div class=\"line\">    return Math.atan2(this.im, this.re);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Object.definePorperty(o, &apos;modulus&apos;, &#123;</div><div class=\"line\">get: modulus,</div><div class=\"line\">enumerable:true,</div><div class=\"line\">configurable: true</div><div class=\"line\">&#125; )</div><div class=\"line\"></div><div class=\"line\">console.log(o.phase, o.modulus ); // logs -0.78 1.4142</div></pre></td></tr></table></figure>\n<ul>\n<li>构造函数中的 this</li>\n</ul>\n<p>当一个函数被作为构造来使用 ( 使用 new 关键字 ), this 被绑定在即将创建的新对象。</p>\n<p><strong>NOTE: 当构造函数里有 return 语句并且 return 一个 Object 的时候，返回这个 Object, 否则就返回 this 绑定的结果( envRec.GetThisBinding() ) </strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function C()&#123;</div><div class=\"line\">  this.a = 37;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = new C();</div><div class=\"line\">console.log(o.a); // 37</div><div class=\"line\"></div><div class=\"line\">function C2()&#123;</div><div class=\"line\">  this.a = 37;</div><div class=\"line\">  return &#123;a:38&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">o = new C2();</div><div class=\"line\">console.log(o.a); // 38</div></pre></td></tr></table></figure>\n<ul>\n<li>call 和 apply</li>\n</ul>\n<p>当一个函数的函数体中使用了 this 关键字，用 call, 或者 apply 方法调用函数的时候，this 的值绑定到一个指定的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(c, d)&#123;</div><div class=\"line\">  return this.a + this.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a:1, b:3&#125;;</div><div class=\"line\"></div><div class=\"line\">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</div><div class=\"line\"></div><div class=\"line\">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</div></pre></td></tr></table></figure>\n<p>使用 call / apply 时，如果指定的 this 不是一个  object 类型，则会使用相应的包装类型函数 将它们包装成 object.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function bar() &#123;</div><div class=\"line\">  console.log(Object.prototype.toString.call(this));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar.call(7); // [object Number] ,  7 被 使用 new Number(7) 包装</div></pre></td></tr></table></figure>\n<ul>\n<li>bind 方法<br>使用 Function.prototype.bind 方法绑定 this 到第一个参数上， 无论这个函数时何处何时调用的， this 的指向不变</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f()&#123;</div><div class=\"line\">  return this.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;); // 将 f 的 this 绑定在 &#123;a: &quot;azerty&quot;&#125; 上</div><div class=\"line\">console.log(g()); // azerty</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a:37, f:f, g:g&#125;;</div><div class=\"line\">console.log(o.f(), o.g()); // 37, azerty</div></pre></td></tr></table></figure>\n<ul>\n<li>Dom事件处理函数中的 this</li>\n</ul>\n<p>当函数被作为 事件处理函数的时候 this 指向触发该事件的元素( e.currentTarget)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 被调用时，将关联的元素变成蓝色</div><div class=\"line\">function bluify(e)&#123;</div><div class=\"line\">  console.log(this === e.currentTarget); // 总是 true</div><div class=\"line\"></div><div class=\"line\">  // 当 currentTarget 和 target 是同一个对象是为 true</div><div class=\"line\">  console.log(this === e.target);</div><div class=\"line\">  this.style.backgroundColor = &apos;#A5D9F3&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 获取文档中的所有元素的列表</div><div class=\"line\">var elements = document.getElementsByTagName(&apos;*&apos;);</div><div class=\"line\"></div><div class=\"line\">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</div><div class=\"line\">for(var i=0 ; i&lt;elements.length ; i++)&#123;</div><div class=\"line\">  elements[i].addEventListener(&apos;click&apos;, bluify, false);</div></pre></td></tr></table></figure>\n<ul>\n<li><p>内联事件的处理函数</p>\n<p>this 指向监听器所在的dom 元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt;</div><div class=\"line\">  Show this</div><div class=\"line\">&lt;/button&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面这个样子的 this 会指向全局对象<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt;</div><div class=\"line\">  Show inner this</div><div class=\"line\">&lt;/button&gt;</div></pre></td></tr></table></figure></p>\n<blockquote><p>参考链接：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\">MDN: this</a></p>\n<p><em>JS高级程序设计 ( 第3版 )</em></p>\n</blockquote>"},{"title":"React-Router 一点一点深入","auto_spacing":true,"_content":"\n最近一直在使用 React 开发页面，所以对 React 相关的文章什么的都留意了些。在查资料的时候经常看到关于 React 服务端渲染这个话题，但是都没有去看文章，只不过心里一直有疑问，为什么需要服务端渲染，\n\n<!-- more -->\n\n#### SEO\n\n后来知道因为所有内容都是写在 React 里面，即 js 里面的，需要 js 去填充主要的内容到 index.html，而 js 加载是在 index.html 已经渲染出来了之后才执行的事。\n而爬虫们呢，一般只会爬初始的 html 页面，所以导致爬虫们什么关键的内容都爬不到，因此 SEO 不好。\n\n所以可以选择，服务器端渲染，然后将一个完整的 html 页面给 浏览器端使用。\n\n#### 路由\n\n然后，昨天知道第二个原因。\n\n就是路由相关。\n我昨天再浏览自己做的 demo 网页的时候，突然发现我一刷新返回了 404，本来以为是网络什么的问题，分别拿电脑，别人的手机，别的网页都试了几次，发现的确一直是这个样子的，于是我疑惑为什么？\n\n刚开始稍微想了下，单页应用，就是只有一个页面，具体的 url 匹配操作应该是 react-router 在做的事。想起来刚开始配 webpack-dev-server 的时候，就是只有主页面能请求到东西，后来把 server 的 historyApiFallback 设置为 true，就可以了。\n\n然后在 google 上找相关资料，找到了 stackoverflow  的这个 [React-router urls don't work when refreshing or writting manually](http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually)\n\n然后这个最赞的回复我觉得讲得挺清楚的：\n\n##### 原因\n\n出现的原因就是过去只有 server 来解析 url , 而现在有 2 个了。\n\n当用户通过 http://example.com/about 来访问页面的时候，\n过去的请求一个 url 的时候，直接是发给 server 端的，由 Server 来解析 URL 中的路径 /about，然后判断该返回哪个页面给 用户，之后将页面返回。\n\n现在由 React-router 给提供的客户端渲染，事情简单了很多。\n\n- 第一步：刚开始的时候，客户端没有任何 JS 代码，所以第一个请求 ( http://example.com )一定是发给 __Server__ 的，然后 Server 返回一个页面，页面中含有__请求 React 和 React-router__ 的 script 标签。\n然后，当请求到了 React /React-router 时候就开始了第二步。\n\n- 第二步：假设用户点击了 '__About us__' 这个链接 ，只改变了__本地 URL__到 http://example.com/about ( 利用 __History API __), 而__没有__向 服务器端发任何请求，而是 __React-router __替代Server这个工作，它解析了 URL 中的路径，判断哪个 Resct view 去 渲染, 然后渲染它。假设 about 页面不需要任何 rest 调用，你已经完成了。 这样 不需要任何 的 服务端调用， 页面从 Home 到  About us。\n\n所以当你__点击__一个链接的时候，运行的 JS 操纵地址栏中的 URL, 它不会让页面__重新刷新__，而是让 __React-router__ 去执行客户端的页面转换。\n\n现在考虑一下，当你复制这个 URL ( http://example.com/about ) 给你朋友 ，她粘贴 URL 到地址栏上的时候。\n\n这个时候她相当于还在__第一步__，因为没有下载网页，也没有 React-Router 运行。所以会向 __Server__ 发送请求访问。\n\n这里就是问题所在。现在，你只是放了一个静态 HTML 在你 server 的网站根目录中，但是当请求访问其他 URLs 的时候 server 会返回 404。\n\n同样的 URLs 访问正常是因为 React-router 做了这些路由的工作，但是 Server 肯定失败，除非__你能让 Server 端也能解析这些 URL__。\n\n\n##### 解决方法\n\n主要是这几种:\n\n- 完全绕开这个问题 ( Hash History )\n\n- 设置 Server 端所有 URL ( /* ) 都返回 相同的 index.html ( 通过使用 Browser History并且设置 Server 返回 index.html ),\n\n- 在特定的路由上增加一些脚本，( 用简单的 PHP 返回一些 有内容的重要的页面。。__这个不懂__  )( Hybrid 混合方式？ )\n\n- 在 Server 端 ( Node.js ) 和客户端运行同样的 JS ( Isomorphic )\n\n#### 我的解决方法\n\n因为，我们 Server 端是 __nginx__ ，所以选择了第二种方法。\n\n本来是想让 男票搞定的，但是，我们两对 nginx 的语法都不是很熟，所以我搜了一个发现这个 [react-router/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server)。\n然后照着那个一设置，OK 了！\n---\n##### 牛逼闪闪的男票补充：\n\n但是，所有的都返回 index.html 能用，但是不太安全，也不太合理。\n\n只有用户刷新／直接打开其他页面的时候，才会出问题。大部分页面，用户不会直接输入url 打开的。\n\n所以，只把用户会输入 url 直接打开的页面，配一下就好了。\n\n也就是在这几个特定的路由上增加一些脚本，让他们直接返回 index.html, 而这个特定的路由的概念，又可以扩展为 所有有效的 URL\n\n而URL ( /* )  匹配的时候，有效无效的，都会匹配上，这是不合理的。\n\n我怎么就没有想到呢···· (￣∇￣)\n\n---\n虽然，这个问题解决了，但是还是对 SEO 不好的。以后肯定会用上 __Isomorphic__ 的方案的，嗯，我就先占个坑吧，毕竟，Node.js 还没有学会。。。。\n\n\n{% blockquote %}\n参考：\n\n[React-router urls don't work when refreshing or writting manually](http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually)\n\n[react-router/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server)\n\n[从 React Router 谈谈路由的那些事](http://stylechen.com/react-router.html)\n{% endblockquote %}\n\n\n","source":"_posts/router.md","raw":"---\ntitle: React-Router 一点一点深入\ncategories:\n- 编程\ntags:\n- React\n- 总结\nauto_spacing: true\n---\n\n最近一直在使用 React 开发页面，所以对 React 相关的文章什么的都留意了些。在查资料的时候经常看到关于 React 服务端渲染这个话题，但是都没有去看文章，只不过心里一直有疑问，为什么需要服务端渲染，\n\n<!-- more -->\n\n#### SEO\n\n后来知道因为所有内容都是写在 React 里面，即 js 里面的，需要 js 去填充主要的内容到 index.html，而 js 加载是在 index.html 已经渲染出来了之后才执行的事。\n而爬虫们呢，一般只会爬初始的 html 页面，所以导致爬虫们什么关键的内容都爬不到，因此 SEO 不好。\n\n所以可以选择，服务器端渲染，然后将一个完整的 html 页面给 浏览器端使用。\n\n#### 路由\n\n然后，昨天知道第二个原因。\n\n就是路由相关。\n我昨天再浏览自己做的 demo 网页的时候，突然发现我一刷新返回了 404，本来以为是网络什么的问题，分别拿电脑，别人的手机，别的网页都试了几次，发现的确一直是这个样子的，于是我疑惑为什么？\n\n刚开始稍微想了下，单页应用，就是只有一个页面，具体的 url 匹配操作应该是 react-router 在做的事。想起来刚开始配 webpack-dev-server 的时候，就是只有主页面能请求到东西，后来把 server 的 historyApiFallback 设置为 true，就可以了。\n\n然后在 google 上找相关资料，找到了 stackoverflow  的这个 [React-router urls don't work when refreshing or writting manually](http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually)\n\n然后这个最赞的回复我觉得讲得挺清楚的：\n\n##### 原因\n\n出现的原因就是过去只有 server 来解析 url , 而现在有 2 个了。\n\n当用户通过 http://example.com/about 来访问页面的时候，\n过去的请求一个 url 的时候，直接是发给 server 端的，由 Server 来解析 URL 中的路径 /about，然后判断该返回哪个页面给 用户，之后将页面返回。\n\n现在由 React-router 给提供的客户端渲染，事情简单了很多。\n\n- 第一步：刚开始的时候，客户端没有任何 JS 代码，所以第一个请求 ( http://example.com )一定是发给 __Server__ 的，然后 Server 返回一个页面，页面中含有__请求 React 和 React-router__ 的 script 标签。\n然后，当请求到了 React /React-router 时候就开始了第二步。\n\n- 第二步：假设用户点击了 '__About us__' 这个链接 ，只改变了__本地 URL__到 http://example.com/about ( 利用 __History API __), 而__没有__向 服务器端发任何请求，而是 __React-router __替代Server这个工作，它解析了 URL 中的路径，判断哪个 Resct view 去 渲染, 然后渲染它。假设 about 页面不需要任何 rest 调用，你已经完成了。 这样 不需要任何 的 服务端调用， 页面从 Home 到  About us。\n\n所以当你__点击__一个链接的时候，运行的 JS 操纵地址栏中的 URL, 它不会让页面__重新刷新__，而是让 __React-router__ 去执行客户端的页面转换。\n\n现在考虑一下，当你复制这个 URL ( http://example.com/about ) 给你朋友 ，她粘贴 URL 到地址栏上的时候。\n\n这个时候她相当于还在__第一步__，因为没有下载网页，也没有 React-Router 运行。所以会向 __Server__ 发送请求访问。\n\n这里就是问题所在。现在，你只是放了一个静态 HTML 在你 server 的网站根目录中，但是当请求访问其他 URLs 的时候 server 会返回 404。\n\n同样的 URLs 访问正常是因为 React-router 做了这些路由的工作，但是 Server 肯定失败，除非__你能让 Server 端也能解析这些 URL__。\n\n\n##### 解决方法\n\n主要是这几种:\n\n- 完全绕开这个问题 ( Hash History )\n\n- 设置 Server 端所有 URL ( /* ) 都返回 相同的 index.html ( 通过使用 Browser History并且设置 Server 返回 index.html ),\n\n- 在特定的路由上增加一些脚本，( 用简单的 PHP 返回一些 有内容的重要的页面。。__这个不懂__  )( Hybrid 混合方式？ )\n\n- 在 Server 端 ( Node.js ) 和客户端运行同样的 JS ( Isomorphic )\n\n#### 我的解决方法\n\n因为，我们 Server 端是 __nginx__ ，所以选择了第二种方法。\n\n本来是想让 男票搞定的，但是，我们两对 nginx 的语法都不是很熟，所以我搜了一个发现这个 [react-router/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server)。\n然后照着那个一设置，OK 了！\n---\n##### 牛逼闪闪的男票补充：\n\n但是，所有的都返回 index.html 能用，但是不太安全，也不太合理。\n\n只有用户刷新／直接打开其他页面的时候，才会出问题。大部分页面，用户不会直接输入url 打开的。\n\n所以，只把用户会输入 url 直接打开的页面，配一下就好了。\n\n也就是在这几个特定的路由上增加一些脚本，让他们直接返回 index.html, 而这个特定的路由的概念，又可以扩展为 所有有效的 URL\n\n而URL ( /* )  匹配的时候，有效无效的，都会匹配上，这是不合理的。\n\n我怎么就没有想到呢···· (￣∇￣)\n\n---\n虽然，这个问题解决了，但是还是对 SEO 不好的。以后肯定会用上 __Isomorphic__ 的方案的，嗯，我就先占个坑吧，毕竟，Node.js 还没有学会。。。。\n\n\n{% blockquote %}\n参考：\n\n[React-router urls don't work when refreshing or writting manually](http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually)\n\n[react-router/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server)\n\n[从 React Router 谈谈路由的那些事](http://stylechen.com/react-router.html)\n{% endblockquote %}\n\n\n","slug":"router","published":1,"date":"2016-12-11T14:47:26.000Z","updated":"2016-12-15T05:07:43.000Z","_id":"ciwlk309n0001fpragy4bd5q9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近一直在使用 React 开发页面，所以对 React 相关的文章什么的都留意了些。在查资料的时候经常看到关于 React 服务端渲染这个话题，但是都没有去看文章，只不过心里一直有疑问，为什么需要服务端渲染，</p>\n<a id=\"more\"></a>\n<h4 id=\"SEO\"><a href=\"#SEO\" class=\"headerlink\" title=\"SEO\"></a>SEO</h4><p>后来知道因为所有内容都是写在 React 里面，即 js 里面的，需要 js 去填充主要的内容到 index.html，而 js 加载是在 index.html 已经渲染出来了之后才执行的事。<br>而爬虫们呢，一般只会爬初始的 html 页面，所以导致爬虫们什么关键的内容都爬不到，因此 SEO 不好。</p>\n<p>所以可以选择，服务器端渲染，然后将一个完整的 html 页面给 浏览器端使用。</p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>然后，昨天知道第二个原因。</p>\n<p>就是路由相关。<br>我昨天再浏览自己做的 demo 网页的时候，突然发现我一刷新返回了 404，本来以为是网络什么的问题，分别拿电脑，别人的手机，别的网页都试了几次，发现的确一直是这个样子的，于是我疑惑为什么？</p>\n<p>刚开始稍微想了下，单页应用，就是只有一个页面，具体的 url 匹配操作应该是 react-router 在做的事。想起来刚开始配 webpack-dev-server 的时候，就是只有主页面能请求到东西，后来把 server 的 historyApiFallback 设置为 true，就可以了。</p>\n<p>然后在 google 上找相关资料，找到了 stackoverflow  的这个 <a href=\"http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually\" target=\"_blank\" rel=\"external\">React-router urls don’t work when refreshing or writting manually</a></p>\n<p>然后这个最赞的回复我觉得讲得挺清楚的：</p>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>出现的原因就是过去只有 server 来解析 url , 而现在有 2 个了。</p>\n<p>当用户通过 <a href=\"http://example.com/about\" target=\"_blank\" rel=\"external\">http://example.com/about</a> 来访问页面的时候，<br>过去的请求一个 url 的时候，直接是发给 server 端的，由 Server 来解析 URL 中的路径 /about，然后判断该返回哪个页面给 用户，之后将页面返回。</p>\n<p>现在由 React-router 给提供的客户端渲染，事情简单了很多。</p>\n<ul>\n<li><p>第一步：刚开始的时候，客户端没有任何 JS 代码，所以第一个请求 ( <a href=\"http://example.com\" target=\"_blank\" rel=\"external\">http://example.com</a> )一定是发给 <strong>Server</strong> 的，然后 Server 返回一个页面，页面中含有<strong>请求 React 和 React-router</strong> 的 script 标签。<br>然后，当请求到了 React /React-router 时候就开始了第二步。</p>\n</li>\n<li><p>第二步：假设用户点击了 ‘<strong>About us</strong>‘ 这个链接 ，只改变了<strong>本地 URL</strong>到 <a href=\"http://example.com/about\" target=\"_blank\" rel=\"external\">http://example.com/about</a> ( 利用 <strong>History API </strong>), 而<strong>没有</strong>向 服务器端发任何请求，而是 <strong>React-router </strong>替代Server这个工作，它解析了 URL 中的路径，判断哪个 Resct view 去 渲染, 然后渲染它。假设 about 页面不需要任何 rest 调用，你已经完成了。 这样 不需要任何 的 服务端调用， 页面从 Home 到  About us。</p>\n</li>\n</ul>\n<p>所以当你<strong>点击</strong>一个链接的时候，运行的 JS 操纵地址栏中的 URL, 它不会让页面<strong>重新刷新</strong>，而是让 <strong>React-router</strong> 去执行客户端的页面转换。</p>\n<p>现在考虑一下，当你复制这个 URL ( <a href=\"http://example.com/about\" target=\"_blank\" rel=\"external\">http://example.com/about</a> ) 给你朋友 ，她粘贴 URL 到地址栏上的时候。</p>\n<p>这个时候她相当于还在<strong>第一步</strong>，因为没有下载网页，也没有 React-Router 运行。所以会向 <strong>Server</strong> 发送请求访问。</p>\n<p>这里就是问题所在。现在，你只是放了一个静态 HTML 在你 server 的网站根目录中，但是当请求访问其他 URLs 的时候 server 会返回 404。</p>\n<p>同样的 URLs 访问正常是因为 React-router 做了这些路由的工作，但是 Server 肯定失败，除非<strong>你能让 Server 端也能解析这些 URL</strong>。</p>\n<h5 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h5><p>主要是这几种:</p>\n<ul>\n<li><p>完全绕开这个问题 ( Hash History )</p>\n</li>\n<li><p>设置 Server 端所有 URL ( /* ) 都返回 相同的 index.html ( 通过使用 Browser History并且设置 Server 返回 index.html ),</p>\n</li>\n<li><p>在特定的路由上增加一些脚本，( 用简单的 PHP 返回一些 有内容的重要的页面。。<strong>这个不懂</strong>  )( Hybrid 混合方式？ )</p>\n</li>\n<li><p>在 Server 端 ( Node.js ) 和客户端运行同样的 JS ( Isomorphic )</p>\n</li>\n</ul>\n<h4 id=\"我的解决方法\"><a href=\"#我的解决方法\" class=\"headerlink\" title=\"我的解决方法\"></a>我的解决方法</h4><p>因为，我们 Server 端是 <strong>nginx</strong> ，所以选择了第二种方法。</p>\n<p>本来是想让 男票搞定的，但是，我们两对 nginx 的语法都不是很熟，所以我搜了一个发现这个 <a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server\" target=\"_blank\" rel=\"external\">react-router/docs/guides/Histories.md</a>。</p>\n<h2 id=\"然后照着那个一设置，OK-了！\"><a href=\"#然后照着那个一设置，OK-了！\" class=\"headerlink\" title=\"然后照着那个一设置，OK 了！\"></a>然后照着那个一设置，OK 了！</h2><h5 id=\"牛逼闪闪的男票补充：\"><a href=\"#牛逼闪闪的男票补充：\" class=\"headerlink\" title=\"牛逼闪闪的男票补充：\"></a>牛逼闪闪的男票补充：</h5><p>但是，所有的都返回 index.html 能用，但是不太安全，也不太合理。</p>\n<p>只有用户刷新／直接打开其他页面的时候，才会出问题。大部分页面，用户不会直接输入url 打开的。</p>\n<p>所以，只把用户会输入 url 直接打开的页面，配一下就好了。</p>\n<p>也就是在这几个特定的路由上增加一些脚本，让他们直接返回 index.html, 而这个特定的路由的概念，又可以扩展为 所有有效的 URL</p>\n<p>而URL ( /* )  匹配的时候，有效无效的，都会匹配上，这是不合理的。</p>\n<p>我怎么就没有想到呢···· (￣∇￣)</p>\n<hr>\n<p>虽然，这个问题解决了，但是还是对 SEO 不好的。以后肯定会用上 <strong>Isomorphic</strong> 的方案的，嗯，我就先占个坑吧，毕竟，Node.js 还没有学会。。。。</p>\n<blockquote><p>参考：</p>\n<p><a href=\"http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually\" target=\"_blank\" rel=\"external\">React-router urls don’t work when refreshing or writting manually</a></p>\n<p><a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server\" target=\"_blank\" rel=\"external\">react-router/docs/guides/Histories.md</a></p>\n<p><a href=\"http://stylechen.com/react-router.html\" target=\"_blank\" rel=\"external\">从 React Router 谈谈路由的那些事</a></p>\n</blockquote>\n","excerpt":"<p>最近一直在使用 React 开发页面，所以对 React 相关的文章什么的都留意了些。在查资料的时候经常看到关于 React 服务端渲染这个话题，但是都没有去看文章，只不过心里一直有疑问，为什么需要服务端渲染，</p>","more":"<h4 id=\"SEO\"><a href=\"#SEO\" class=\"headerlink\" title=\"SEO\"></a>SEO</h4><p>后来知道因为所有内容都是写在 React 里面，即 js 里面的，需要 js 去填充主要的内容到 index.html，而 js 加载是在 index.html 已经渲染出来了之后才执行的事。<br>而爬虫们呢，一般只会爬初始的 html 页面，所以导致爬虫们什么关键的内容都爬不到，因此 SEO 不好。</p>\n<p>所以可以选择，服务器端渲染，然后将一个完整的 html 页面给 浏览器端使用。</p>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><p>然后，昨天知道第二个原因。</p>\n<p>就是路由相关。<br>我昨天再浏览自己做的 demo 网页的时候，突然发现我一刷新返回了 404，本来以为是网络什么的问题，分别拿电脑，别人的手机，别的网页都试了几次，发现的确一直是这个样子的，于是我疑惑为什么？</p>\n<p>刚开始稍微想了下，单页应用，就是只有一个页面，具体的 url 匹配操作应该是 react-router 在做的事。想起来刚开始配 webpack-dev-server 的时候，就是只有主页面能请求到东西，后来把 server 的 historyApiFallback 设置为 true，就可以了。</p>\n<p>然后在 google 上找相关资料，找到了 stackoverflow  的这个 <a href=\"http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually\">React-router urls don’t work when refreshing or writting manually</a></p>\n<p>然后这个最赞的回复我觉得讲得挺清楚的：</p>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><p>出现的原因就是过去只有 server 来解析 url , 而现在有 2 个了。</p>\n<p>当用户通过 <a href=\"http://example.com/about\">http://example.com/about</a> 来访问页面的时候，<br>过去的请求一个 url 的时候，直接是发给 server 端的，由 Server 来解析 URL 中的路径 /about，然后判断该返回哪个页面给 用户，之后将页面返回。</p>\n<p>现在由 React-router 给提供的客户端渲染，事情简单了很多。</p>\n<ul>\n<li><p>第一步：刚开始的时候，客户端没有任何 JS 代码，所以第一个请求 ( <a href=\"http://example.com\">http://example.com</a> )一定是发给 <strong>Server</strong> 的，然后 Server 返回一个页面，页面中含有<strong>请求 React 和 React-router</strong> 的 script 标签。<br>然后，当请求到了 React /React-router 时候就开始了第二步。</p>\n</li>\n<li><p>第二步：假设用户点击了 ‘<strong>About us</strong>‘ 这个链接 ，只改变了<strong>本地 URL</strong>到 <a href=\"http://example.com/about\">http://example.com/about</a> ( 利用 <strong>History API </strong>), 而<strong>没有</strong>向 服务器端发任何请求，而是 <strong>React-router </strong>替代Server这个工作，它解析了 URL 中的路径，判断哪个 Resct view 去 渲染, 然后渲染它。假设 about 页面不需要任何 rest 调用，你已经完成了。 这样 不需要任何 的 服务端调用， 页面从 Home 到  About us。</p>\n</li>\n</ul>\n<p>所以当你<strong>点击</strong>一个链接的时候，运行的 JS 操纵地址栏中的 URL, 它不会让页面<strong>重新刷新</strong>，而是让 <strong>React-router</strong> 去执行客户端的页面转换。</p>\n<p>现在考虑一下，当你复制这个 URL ( <a href=\"http://example.com/about\">http://example.com/about</a> ) 给你朋友 ，她粘贴 URL 到地址栏上的时候。</p>\n<p>这个时候她相当于还在<strong>第一步</strong>，因为没有下载网页，也没有 React-Router 运行。所以会向 <strong>Server</strong> 发送请求访问。</p>\n<p>这里就是问题所在。现在，你只是放了一个静态 HTML 在你 server 的网站根目录中，但是当请求访问其他 URLs 的时候 server 会返回 404。</p>\n<p>同样的 URLs 访问正常是因为 React-router 做了这些路由的工作，但是 Server 肯定失败，除非<strong>你能让 Server 端也能解析这些 URL</strong>。</p>\n<h5 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h5><p>主要是这几种:</p>\n<ul>\n<li><p>完全绕开这个问题 ( Hash History )</p>\n</li>\n<li><p>设置 Server 端所有 URL ( /* ) 都返回 相同的 index.html ( 通过使用 Browser History并且设置 Server 返回 index.html ),</p>\n</li>\n<li><p>在特定的路由上增加一些脚本，( 用简单的 PHP 返回一些 有内容的重要的页面。。<strong>这个不懂</strong>  )( Hybrid 混合方式？ )</p>\n</li>\n<li><p>在 Server 端 ( Node.js ) 和客户端运行同样的 JS ( Isomorphic )</p>\n</li>\n</ul>\n<h4 id=\"我的解决方法\"><a href=\"#我的解决方法\" class=\"headerlink\" title=\"我的解决方法\"></a>我的解决方法</h4><p>因为，我们 Server 端是 <strong>nginx</strong> ，所以选择了第二种方法。</p>\n<p>本来是想让 男票搞定的，但是，我们两对 nginx 的语法都不是很熟，所以我搜了一个发现这个 <a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server\">react-router/docs/guides/Histories.md</a>。</p>\n<h2 id=\"然后照着那个一设置，OK-了！\"><a href=\"#然后照着那个一设置，OK-了！\" class=\"headerlink\" title=\"然后照着那个一设置，OK 了！\"></a>然后照着那个一设置，OK 了！</h2><h5 id=\"牛逼闪闪的男票补充：\"><a href=\"#牛逼闪闪的男票补充：\" class=\"headerlink\" title=\"牛逼闪闪的男票补充：\"></a>牛逼闪闪的男票补充：</h5><p>但是，所有的都返回 index.html 能用，但是不太安全，也不太合理。</p>\n<p>只有用户刷新／直接打开其他页面的时候，才会出问题。大部分页面，用户不会直接输入url 打开的。</p>\n<p>所以，只把用户会输入 url 直接打开的页面，配一下就好了。</p>\n<p>也就是在这几个特定的路由上增加一些脚本，让他们直接返回 index.html, 而这个特定的路由的概念，又可以扩展为 所有有效的 URL</p>\n<p>而URL ( /* )  匹配的时候，有效无效的，都会匹配上，这是不合理的。</p>\n<p>我怎么就没有想到呢···· (￣∇￣)</p>\n<hr>\n<p>虽然，这个问题解决了，但是还是对 SEO 不好的。以后肯定会用上 <strong>Isomorphic</strong> 的方案的，嗯，我就先占个坑吧，毕竟，Node.js 还没有学会。。。。</p>\n<blockquote><p>参考：</p>\n<p><a href=\"http://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writting-manually\">React-router urls don’t work when refreshing or writting manually</a></p>\n<p><a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/guides/Histories.md#configuring-your-server\">react-router/docs/guides/Histories.md</a></p>\n<p><a href=\"http://stylechen.com/react-router.html\">从 React Router 谈谈路由的那些事</a></p>\n</blockquote>"},{"_content":"\n热腾腾的面试经验积累！\n\n cloud\n\n\n今天，被虐得死去活来的。\n\n刚开始，问得都稍微基础一些。\n\n我记得有这几个，\n\nreact 和 vue 区别\n\n- webpack, 跨域 相关\n\n问：我怎么布置 __webpack__ 的。\n答：这个我说到了 __proxy__, 于是问了这个实现 __跨域请求__ 的原理，\n问：跨域请求原理\n答：刚开始不知道 proxy 时候，用 nginx 搭的 serve,  serve 可以自由配置 url ( 协议，域名，端口 ), 这样的话，就避免跨域了。\n\n- promise 相关\n问：你知道 promise 么？\n答：大概了解，但基本上没有用过。\n  也是异步调用，可以把多层嵌套的异步调用，不过把那个回调函数拿出来了，就像写 scss 那样把里面的那层给拿出来，放到外面去了，然后把它变成链式的了。（答得不好。。）\n\n- 项目题（算法）\n\n面试官：大概实现百度搜索的那个联想功能，要用 XMLHttpRequest 和 promise 实现。\n\n我：我。。。方了。。好难。。\n\n面试官看我有些困难，提示我说 可以分成两个问题，先解决怎么用 XMLHttpRequest 请求。\n\n我： 😢（心里：天呢！ 基本没怎么用过啊）\n我就想起来要先 new 一个 XMLHttpRequest, 于是说了下，然后把输入的字符传进去，然后发送请求！\n\n面试：那怎么拿到数据呢？\n\n我：啊！怎么拿到数据。。 难道有个回调函数？\n\n面试： 是的。\n\n我：那就再将回调函数一块发过去！\n\n面试：之后要用 promise 实现。\n\n我： promise 。。。？\n\n面试：给你 提示 把他们分装到一个函数，函数的参数是 (url, callback )\n\n我：哦～ 好像跟闭包很像。。。（我此刻只能想到，要用promise 拿到数据 然后和方法一组合，没有想起来怎么用 promise ）\n\n面试：怎么用 promise\n\n我： 先 new 一个\n\n面试： 有两个参数，\n\n\n判断类型\n\n数组重复最多的部分\n\n\n\n\n尤其后面的实际操作题，很不好。\n promise 太不熟\n\n 类型判断\n妈妈虎虎。。。我记得 Object.prototype.toString.call() 应该可以全判的。。而且忘了 call...\n\n数组重复最多的部分，\n\n对数组操作不是很了解\n\n\n我觉得。。我要重新学一遍了\n\n### reflow与repaint：\nreflow(回流):\n  涉及到部分页面的布局\n\n  页面中向服务器请求的次数多会影响到打开速度,\n\n  重新渲染局部的次数也会影响页面打开速度,对于这种来回渲染,叫做reflow,\n\n  一个元素的回流导致了其所有子元素以及DOM中紧随其后的祖先元素的随后的回流,reflow几乎是无法避免的,我们不能因为害怕reflow就丢掉一些页面效果,但是reflow是可以优化的,\n  (比如图片在.css样式文件中就定义好图片的高度,这会减少页面重新渲染的次数);\n\n  - 导致reflow的一些因素:\n\n    调整窗口大小;\n\n    改变字体;\n\n    增加或者移除样式表;\n\n    内容变化，比如用户在input框中输入文字;\n\n    激活CSS伪类，比如 :hover (IE 中为兄弟结点伪类的激活);\n\n    操作class属性;\n\n    脚本操作DOM;\n\n    计算offsetWidth和offsetHeight属性;\n\n    设置style属性的值;\n\n  - 合理的优化:\n\n    如果想设定元素的样式，通过改变元素的class名(尽可能在DOM树的最里层);\n    [可以限制了回流的范围，使其影响尽可能少的节点]\n\n    避免设置多项内联样式;\n\n    应用元素的动画，使用position属性的fixed值或absolute值\n\n    [它们不影响其他元素的布局(BFC?),所它他们只会导致重新绘制,而不是一个完整回流]\n\n    权衡平滑和速度;\n\n    避免使用table布局;\n\n    避免使用CSS的JavaScript表达式(仅IE浏览器);\n\n### repaint(重绘):\n\n  重绘：对某个区域、对象的重新渲染表现\n\n  回流：对某个区域、对象进行重绘，根据条件影响到它的祖先对象进入重绘（并可能无限递归直到顶级祖先对象）\n\n  浏览器必须验证DOM树上其他节点元素的可见性\n\n  重绘如何出现：\n\n  改变对象的形状、坐标、表现以及内容都会引发该对象被重新渲染，这种现象即为重绘。\n\n  回流如何出现：\n\n  当该对象即将重绘时，浏览器会根据条件判断该对象的重绘结果是否会依赖该对象的祖先元素。如果有则将该对象祖先元素也加入本次重绘。并一直向上寻找，直到条件不匹配。此现象即为回流。\n\n  最后总结：\n\n  1、重绘可能引发回流\n  2、回流必定引发重绘\n\n\npromise\narray\nXMLHttpRequest\n类型判断\n是否相等\n\nconst\n","source":"_drafts/interview_doc_1.md","raw":"\n热腾腾的面试经验积累！\n\n cloud\n\n\n今天，被虐得死去活来的。\n\n刚开始，问得都稍微基础一些。\n\n我记得有这几个，\n\nreact 和 vue 区别\n\n- webpack, 跨域 相关\n\n问：我怎么布置 __webpack__ 的。\n答：这个我说到了 __proxy__, 于是问了这个实现 __跨域请求__ 的原理，\n问：跨域请求原理\n答：刚开始不知道 proxy 时候，用 nginx 搭的 serve,  serve 可以自由配置 url ( 协议，域名，端口 ), 这样的话，就避免跨域了。\n\n- promise 相关\n问：你知道 promise 么？\n答：大概了解，但基本上没有用过。\n  也是异步调用，可以把多层嵌套的异步调用，不过把那个回调函数拿出来了，就像写 scss 那样把里面的那层给拿出来，放到外面去了，然后把它变成链式的了。（答得不好。。）\n\n- 项目题（算法）\n\n面试官：大概实现百度搜索的那个联想功能，要用 XMLHttpRequest 和 promise 实现。\n\n我：我。。。方了。。好难。。\n\n面试官看我有些困难，提示我说 可以分成两个问题，先解决怎么用 XMLHttpRequest 请求。\n\n我： 😢（心里：天呢！ 基本没怎么用过啊）\n我就想起来要先 new 一个 XMLHttpRequest, 于是说了下，然后把输入的字符传进去，然后发送请求！\n\n面试：那怎么拿到数据呢？\n\n我：啊！怎么拿到数据。。 难道有个回调函数？\n\n面试： 是的。\n\n我：那就再将回调函数一块发过去！\n\n面试：之后要用 promise 实现。\n\n我： promise 。。。？\n\n面试：给你 提示 把他们分装到一个函数，函数的参数是 (url, callback )\n\n我：哦～ 好像跟闭包很像。。。（我此刻只能想到，要用promise 拿到数据 然后和方法一组合，没有想起来怎么用 promise ）\n\n面试：怎么用 promise\n\n我： 先 new 一个\n\n面试： 有两个参数，\n\n\n判断类型\n\n数组重复最多的部分\n\n\n\n\n尤其后面的实际操作题，很不好。\n promise 太不熟\n\n 类型判断\n妈妈虎虎。。。我记得 Object.prototype.toString.call() 应该可以全判的。。而且忘了 call...\n\n数组重复最多的部分，\n\n对数组操作不是很了解\n\n\n我觉得。。我要重新学一遍了\n\n### reflow与repaint：\nreflow(回流):\n  涉及到部分页面的布局\n\n  页面中向服务器请求的次数多会影响到打开速度,\n\n  重新渲染局部的次数也会影响页面打开速度,对于这种来回渲染,叫做reflow,\n\n  一个元素的回流导致了其所有子元素以及DOM中紧随其后的祖先元素的随后的回流,reflow几乎是无法避免的,我们不能因为害怕reflow就丢掉一些页面效果,但是reflow是可以优化的,\n  (比如图片在.css样式文件中就定义好图片的高度,这会减少页面重新渲染的次数);\n\n  - 导致reflow的一些因素:\n\n    调整窗口大小;\n\n    改变字体;\n\n    增加或者移除样式表;\n\n    内容变化，比如用户在input框中输入文字;\n\n    激活CSS伪类，比如 :hover (IE 中为兄弟结点伪类的激活);\n\n    操作class属性;\n\n    脚本操作DOM;\n\n    计算offsetWidth和offsetHeight属性;\n\n    设置style属性的值;\n\n  - 合理的优化:\n\n    如果想设定元素的样式，通过改变元素的class名(尽可能在DOM树的最里层);\n    [可以限制了回流的范围，使其影响尽可能少的节点]\n\n    避免设置多项内联样式;\n\n    应用元素的动画，使用position属性的fixed值或absolute值\n\n    [它们不影响其他元素的布局(BFC?),所它他们只会导致重新绘制,而不是一个完整回流]\n\n    权衡平滑和速度;\n\n    避免使用table布局;\n\n    避免使用CSS的JavaScript表达式(仅IE浏览器);\n\n### repaint(重绘):\n\n  重绘：对某个区域、对象的重新渲染表现\n\n  回流：对某个区域、对象进行重绘，根据条件影响到它的祖先对象进入重绘（并可能无限递归直到顶级祖先对象）\n\n  浏览器必须验证DOM树上其他节点元素的可见性\n\n  重绘如何出现：\n\n  改变对象的形状、坐标、表现以及内容都会引发该对象被重新渲染，这种现象即为重绘。\n\n  回流如何出现：\n\n  当该对象即将重绘时，浏览器会根据条件判断该对象的重绘结果是否会依赖该对象的祖先元素。如果有则将该对象祖先元素也加入本次重绘。并一直向上寻找，直到条件不匹配。此现象即为回流。\n\n  最后总结：\n\n  1、重绘可能引发回流\n  2、回流必定引发重绘\n\n\npromise\narray\nXMLHttpRequest\n类型判断\n是否相等\n\nconst\n","slug":"interview_doc_1","published":0,"date":"2016-12-14T10:04:45.000Z","updated":"2016-12-16T08:06:00.000Z","_id":"ciwpvzd4n0000lcra3sn7b0ao","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>热腾腾的面试经验积累！</p>\n<p> cloud</p>\n<p>今天，被虐得死去活来的。</p>\n<p>刚开始，问得都稍微基础一些。</p>\n<p>我记得有这几个，</p>\n<p>react 和 vue 区别</p>\n<ul>\n<li>webpack, 跨域 相关</li>\n</ul>\n<p>问：我怎么布置 <strong>webpack</strong> 的。<br>答：这个我说到了 <strong>proxy</strong>, 于是问了这个实现 <strong>跨域请求</strong> 的原理，<br>问：跨域请求原理<br>答：刚开始不知道 proxy 时候，用 nginx 搭的 serve,  serve 可以自由配置 url ( 协议，域名，端口 ), 这样的话，就避免跨域了。</p>\n<ul>\n<li><p>promise 相关<br>问：你知道 promise 么？<br>答：大概了解，但基本上没有用过。<br>也是异步调用，可以把多层嵌套的异步调用，不过把那个回调函数拿出来了，就像写 scss 那样把里面的那层给拿出来，放到外面去了，然后把它变成链式的了。（答得不好。。）</p>\n</li>\n<li><p>项目题（算法）</p>\n</li>\n</ul>\n<p>面试官：大概实现百度搜索的那个联想功能，要用 XMLHttpRequest 和 promise 实现。</p>\n<p>我：我。。。方了。。好难。。</p>\n<p>面试官看我有些困难，提示我说 可以分成两个问题，先解决怎么用 XMLHttpRequest 请求。</p>\n<p>我： 😢（心里：天呢！ 基本没怎么用过啊）<br>我就想起来要先 new 一个 XMLHttpRequest, 于是说了下，然后把输入的字符传进去，然后发送请求！</p>\n<p>面试：那怎么拿到数据呢？</p>\n<p>我：啊！怎么拿到数据。。 难道有个回调函数？</p>\n<p>面试： 是的。</p>\n<p>我：那就再将回调函数一块发过去！</p>\n<p>面试：之后要用 promise 实现。</p>\n<p>我： promise 。。。？</p>\n<p>面试：给你 提示 把他们分装到一个函数，函数的参数是 (url, callback )</p>\n<p>我：哦～ 好像跟闭包很像。。。（我此刻只能想到，要用promise 拿到数据 然后和方法一组合，没有想起来怎么用 promise ）</p>\n<p>面试：怎么用 promise</p>\n<p>我： 先 new 一个</p>\n<p>面试： 有两个参数，</p>\n<p>判断类型</p>\n<p>数组重复最多的部分</p>\n<p>尤其后面的实际操作题，很不好。<br> promise 太不熟</p>\n<p> 类型判断<br>妈妈虎虎。。。我记得 Object.prototype.toString.call() 应该可以全判的。。而且忘了 call…</p>\n<p>数组重复最多的部分，</p>\n<p>对数组操作不是很了解</p>\n<p>我觉得。。我要重新学一遍了</p>\n<h3 id=\"reflow与repaint：\"><a href=\"#reflow与repaint：\" class=\"headerlink\" title=\"reflow与repaint：\"></a>reflow与repaint：</h3><p>reflow(回流):<br>  涉及到部分页面的布局</p>\n<p>  页面中向服务器请求的次数多会影响到打开速度,</p>\n<p>  重新渲染局部的次数也会影响页面打开速度,对于这种来回渲染,叫做reflow,</p>\n<p>  一个元素的回流导致了其所有子元素以及DOM中紧随其后的祖先元素的随后的回流,reflow几乎是无法避免的,我们不能因为害怕reflow就丢掉一些页面效果,但是reflow是可以优化的,<br>  (比如图片在.css样式文件中就定义好图片的高度,这会减少页面重新渲染的次数);</p>\n<ul>\n<li><p>导致reflow的一些因素:</p>\n<p>调整窗口大小;</p>\n<p>改变字体;</p>\n<p>增加或者移除样式表;</p>\n<p>内容变化，比如用户在input框中输入文字;</p>\n<p>激活CSS伪类，比如 :hover (IE 中为兄弟结点伪类的激活);</p>\n<p>操作class属性;</p>\n<p>脚本操作DOM;</p>\n<p>计算offsetWidth和offsetHeight属性;</p>\n<p>设置style属性的值;</p>\n</li>\n<li><p>合理的优化:</p>\n<p>如果想设定元素的样式，通过改变元素的class名(尽可能在DOM树的最里层);<br>[可以限制了回流的范围，使其影响尽可能少的节点]</p>\n<p>避免设置多项内联样式;</p>\n<p>应用元素的动画，使用position属性的fixed值或absolute值</p>\n<p>[它们不影响其他元素的布局(BFC?),所它他们只会导致重新绘制,而不是一个完整回流]</p>\n<p>权衡平滑和速度;</p>\n<p>避免使用table布局;</p>\n<p>避免使用CSS的JavaScript表达式(仅IE浏览器);</p>\n</li>\n</ul>\n<h3 id=\"repaint-重绘\"><a href=\"#repaint-重绘\" class=\"headerlink\" title=\"repaint(重绘):\"></a>repaint(重绘):</h3><p>  重绘：对某个区域、对象的重新渲染表现</p>\n<p>  回流：对某个区域、对象进行重绘，根据条件影响到它的祖先对象进入重绘（并可能无限递归直到顶级祖先对象）</p>\n<p>  浏览器必须验证DOM树上其他节点元素的可见性</p>\n<p>  重绘如何出现：</p>\n<p>  改变对象的形状、坐标、表现以及内容都会引发该对象被重新渲染，这种现象即为重绘。</p>\n<p>  回流如何出现：</p>\n<p>  当该对象即将重绘时，浏览器会根据条件判断该对象的重绘结果是否会依赖该对象的祖先元素。如果有则将该对象祖先元素也加入本次重绘。并一直向上寻找，直到条件不匹配。此现象即为回流。</p>\n<p>  最后总结：</p>\n<p>  1、重绘可能引发回流<br>  2、回流必定引发重绘</p>\n<p>promise<br>array<br>XMLHttpRequest<br>类型判断<br>是否相等</p>\n<p>const</p>\n","excerpt":"","more":"<p>热腾腾的面试经验积累！</p>\n<p> cloud</p>\n<p>今天，被虐得死去活来的。</p>\n<p>刚开始，问得都稍微基础一些。</p>\n<p>我记得有这几个，</p>\n<p>react 和 vue 区别</p>\n<ul>\n<li>webpack, 跨域 相关</li>\n</ul>\n<p>问：我怎么布置 <strong>webpack</strong> 的。<br>答：这个我说到了 <strong>proxy</strong>, 于是问了这个实现 <strong>跨域请求</strong> 的原理，<br>问：跨域请求原理<br>答：刚开始不知道 proxy 时候，用 nginx 搭的 serve,  serve 可以自由配置 url ( 协议，域名，端口 ), 这样的话，就避免跨域了。</p>\n<ul>\n<li><p>promise 相关<br>问：你知道 promise 么？<br>答：大概了解，但基本上没有用过。<br>也是异步调用，可以把多层嵌套的异步调用，不过把那个回调函数拿出来了，就像写 scss 那样把里面的那层给拿出来，放到外面去了，然后把它变成链式的了。（答得不好。。）</p>\n</li>\n<li><p>项目题（算法）</p>\n</li>\n</ul>\n<p>面试官：大概实现百度搜索的那个联想功能，要用 XMLHttpRequest 和 promise 实现。</p>\n<p>我：我。。。方了。。好难。。</p>\n<p>面试官看我有些困难，提示我说 可以分成两个问题，先解决怎么用 XMLHttpRequest 请求。</p>\n<p>我： 😢（心里：天呢！ 基本没怎么用过啊）<br>我就想起来要先 new 一个 XMLHttpRequest, 于是说了下，然后把输入的字符传进去，然后发送请求！</p>\n<p>面试：那怎么拿到数据呢？</p>\n<p>我：啊！怎么拿到数据。。 难道有个回调函数？</p>\n<p>面试： 是的。</p>\n<p>我：那就再将回调函数一块发过去！</p>\n<p>面试：之后要用 promise 实现。</p>\n<p>我： promise 。。。？</p>\n<p>面试：给你 提示 把他们分装到一个函数，函数的参数是 (url, callback )</p>\n<p>我：哦～ 好像跟闭包很像。。。（我此刻只能想到，要用promise 拿到数据 然后和方法一组合，没有想起来怎么用 promise ）</p>\n<p>面试：怎么用 promise</p>\n<p>我： 先 new 一个</p>\n<p>面试： 有两个参数，</p>\n<p>判断类型</p>\n<p>数组重复最多的部分</p>\n<p>尤其后面的实际操作题，很不好。<br> promise 太不熟</p>\n<p> 类型判断<br>妈妈虎虎。。。我记得 Object.prototype.toString.call() 应该可以全判的。。而且忘了 call…</p>\n<p>数组重复最多的部分，</p>\n<p>对数组操作不是很了解</p>\n<p>我觉得。。我要重新学一遍了</p>\n<h3 id=\"reflow与repaint：\"><a href=\"#reflow与repaint：\" class=\"headerlink\" title=\"reflow与repaint：\"></a>reflow与repaint：</h3><p>reflow(回流):<br>  涉及到部分页面的布局</p>\n<p>  页面中向服务器请求的次数多会影响到打开速度,</p>\n<p>  重新渲染局部的次数也会影响页面打开速度,对于这种来回渲染,叫做reflow,</p>\n<p>  一个元素的回流导致了其所有子元素以及DOM中紧随其后的祖先元素的随后的回流,reflow几乎是无法避免的,我们不能因为害怕reflow就丢掉一些页面效果,但是reflow是可以优化的,<br>  (比如图片在.css样式文件中就定义好图片的高度,这会减少页面重新渲染的次数);</p>\n<ul>\n<li><p>导致reflow的一些因素:</p>\n<p>调整窗口大小;</p>\n<p>改变字体;</p>\n<p>增加或者移除样式表;</p>\n<p>内容变化，比如用户在input框中输入文字;</p>\n<p>激活CSS伪类，比如 :hover (IE 中为兄弟结点伪类的激活);</p>\n<p>操作class属性;</p>\n<p>脚本操作DOM;</p>\n<p>计算offsetWidth和offsetHeight属性;</p>\n<p>设置style属性的值;</p>\n</li>\n<li><p>合理的优化:</p>\n<p>如果想设定元素的样式，通过改变元素的class名(尽可能在DOM树的最里层);<br>[可以限制了回流的范围，使其影响尽可能少的节点]</p>\n<p>避免设置多项内联样式;</p>\n<p>应用元素的动画，使用position属性的fixed值或absolute值</p>\n<p>[它们不影响其他元素的布局(BFC?),所它他们只会导致重新绘制,而不是一个完整回流]</p>\n<p>权衡平滑和速度;</p>\n<p>避免使用table布局;</p>\n<p>避免使用CSS的JavaScript表达式(仅IE浏览器);</p>\n</li>\n</ul>\n<h3 id=\"repaint-重绘\"><a href=\"#repaint-重绘\" class=\"headerlink\" title=\"repaint(重绘):\"></a>repaint(重绘):</h3><p>  重绘：对某个区域、对象的重新渲染表现</p>\n<p>  回流：对某个区域、对象进行重绘，根据条件影响到它的祖先对象进入重绘（并可能无限递归直到顶级祖先对象）</p>\n<p>  浏览器必须验证DOM树上其他节点元素的可见性</p>\n<p>  重绘如何出现：</p>\n<p>  改变对象的形状、坐标、表现以及内容都会引发该对象被重新渲染，这种现象即为重绘。</p>\n<p>  回流如何出现：</p>\n<p>  当该对象即将重绘时，浏览器会根据条件判断该对象的重绘结果是否会依赖该对象的祖先元素。如果有则将该对象祖先元素也加入本次重绘。并一直向上寻找，直到条件不匹配。此现象即为回流。</p>\n<p>  最后总结：</p>\n<p>  1、重绘可能引发回流<br>  2、回流必定引发重绘</p>\n<p>promise<br>array<br>XMLHttpRequest<br>类型判断<br>是否相等</p>\n<p>const</p>\n"},{"_content":"\n### 一面\n\n一. html语义化\n\n语义：能够让你更恰当地描述你的内容是什么。\n\n二. h5新标签\n\nHyper Text Markup Language，即超文本标记语言\n其主要的目标是将互联网语义化。以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。\n\n- 语义：\n\n  + 节段和提纲\n\n```\n<section>, <article>, <nav>, <header>, <footer>, <aside> 和<hgroup>.\n```\n  + 音频和视频\n\n```\n<audio> 和 <video>\n```\n\n  + 表单\n\n```\n<input> 属性type 的一些新值 ，新的 <output> 元素。\n```\n\n  + 新的语义元素\n\n```\n<mark>， <figure>， <figcaption>， <data>， <time>， <output>， <progress>，<meter>和<main>\n```\n\n```\n  + <iframe> 的改进\n使用 sandbox， seamless， 和 srcdoc 属性，作者们现在可以精确控制 <iframe>元素的安全级别以及期望的渲染。\n```\n\n  + MathML\n\n允许直接嵌入数学公式。\n\n- 通信\n\n  + Web Sockets\n\n允许在页面和服务器之间建立持久连接并通过这种方法来交换非 HTML 数据。\n\n  + Server-sent events\n\n允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。\n\n  + WebRTC\n\n这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。\n\n  + 离线 & 存储\n\n\n 存储： Web Storage\n\n- sessionStorage 为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用 ( __浏览器打开状态，包括页面重新加载和恢复__ )( 只能在一个网页！ )\n\n- localStorage 在浏览器关闭，然后重新打开__仍存在__。(同源网站)\n\n- cookie ( 同源 )\n-\n服务器设置的set-cookies ，浏览器保存下来，每一次请求的时候都带着它。\n\n\n- 多媒体\n\n```\n   <audio> 和 <video>\n```\n元素嵌入并支持新的多媒体内容的操作\n\n  + 使用 Camera API\n\n允许使用，操作计算机摄像头，并从中存储图像。\n\n  + 图像 & 效果\n```\n <canvas>  绘制图像和其他对象\n```\n__SVG__ 一个基于 XML 的可以直接嵌入到 HTML 中的矢量图像格式\n\n  + WebGL\n```\nWebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 HTML5 <canvas>元素中的 API 给 Web 带来了 3D 图像功能。\n```\n- 性能 & 集成\n\n  + Web Workers\n\n能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。\n\n  + XMLHttpRequest Level 2\n---\n允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax背后的技术。\n\n  + History API\n\n允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。\n\nhistory.pushState()\n  会在当前的文档内创建和 __激活新的历史记录条目__， 不会触发 __hashchange__ 事件\n\nhistory.replaceState()\n  __会修改当前历史记录 ( 不是创建 )__\n\n\n- 样式 CSS3\n\n  + 新的背景样式特性\n\n现在可以使用 box-shadow 给逻辑框设置一个阴影，而且还可以设置 多背景\n\n  + 更精美的边框\n\n    border-image,\n    border-radius\n\n  + CSS Transitions 在不同的__状态间__设置动画\n\n  + CSS Animations 在页面的某些部分设置动画而__不需要一个触发事件__\n\n  + 你现在可以在页面中控制移动元素了\n\n  + 排版方面的改进\n\n  还可以给它设置一个 阴影 或者更精细地控制它的 decorations。\n\n    - Word-wrap\n    - Text-overflow\n    - hyphenation\n    - @font-face\n\n  + 布局\n\n    - CSS 多栏布局\n    - CSS 灵活方框布局。\n\n  + Canvas\n\n三. es6\n\n\n\n四. promise\n\n对异步操作的封装，在异步操作执行成功或者失败时指定方法。\n\npromise 对象具备三种生命状态： pending, fulfilled，rejected。\n\n只能从最初的 __pending -> fulfilled / rejected__, 而且状态的改变不可逆。\n\nresolve -> fulfilled 状态, 并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数\nreject -> rejected ， catch\n\nPromise 大致的工作流程：\n- 创建 Promise 对象 => 进入等待处理阶段 Pending\n- 处理完成后，切换到  Fulfilled / Rejected\n- 根据状态，执行 then / catch 方法 内的回调\n- then 方法返回新的 Promise , 此时支持链式调用\n\n\n五. promise解决了你什么问题\n--\n异步操作时的嵌套太多。\n\n比如读\n\n六. 跨域的方法\n\n源： 协议，端口，域名\n同源策略限制了一个源中加载文本或者脚本如何与来自另一个源的资源进行交互。\n\n1. jsonp ( json with padding ), 一种包含在函数调用中的 json\n\n- 服务器端返回 jsonp 格式:\n\n```\n  callback(  // callback 是浏览器传过去的回调函数\n    {\n      'name': 'innle'\n    }\n  )\n```\n\n如何使用？\n\n__浏览器端__\n\n- 设置 dataType: jsonp\n\n- 全局注册 回调函数 callbackName( data )，\n\n  函数的参数是服务器端返回数据，\n  函数的内容就是处理这个数据\n\n- 动态生成一个 script 标签如下\n\n```\nfunction callbackName( result ) {\n  console.log(result.name );\n}\nvar jsonpScript = document.createElement(\"script\");\njsonpScript.type = \"text/javascript\";\njsonpScript.src = \"https://www.xxx.com?callbackName=\" + callbackName ;\ndocument.querySelector('head').appendChild(jsonpScript);\n\n```\n\n__服务器端__\n\n- 服务器接收到 script 请求后，从 url 的 query 的 callbackName 获取到回调函数名字，如: _callbackName_\n\n然后动态生成一段 js 片段去给这个函数传入参数执行这个函数，如：\n\n```\ncallbackName({name: 'VIVI'});\n```\n__执行__\n\n服务器返回这个 script 之后，浏览器端获取到这个 script 资源之后，会立即执行这个 javascript .\n\n- Jquery 里的 $.getJSON\n\n- 回调函数名称可以在 请求 url 中追加 __?callback=?__\n\n- 也可以定义这个名称；\n\n ```\n dataType: 'jsonp',\n jsonp: 'callbackName'\n ```\n\n\n__缺点__：\n\n  - 不仅需要 浏览器端 js 进行配置，也需要 __服务器端__ 返回数据格式的配置\n  - 只支持 __get__ 请求\n\n2. CORS  ( cross-origin resource sharing ) 跨域资源共享\n\n它允许浏览器向跨域服务器发出 XMLHttpRequest 请求\n\n使用和普通的 ajax 过程是一样的，只是 __浏览器__ 在发现这是一个跨域请求的时候会 __自动__ 帮我们处理一些事，比如验证\n\nCORS 请求分两种\n- 简单请求\n\n  条件：\n\n  浏览器做什么？\n\n  自动在请求的头文件信息加上 '__Origin__: https//zhangxiaoxu.com ' 字段，表明自己来自哪个源。服务器获取这个值后，会判断是否同意这个请求并返回\n\n  。。。  太多了\n\n- 非简单请求\n\n一般是对服务器有特殊要求的请求，比如： PUT ， DELETE，或者 Content-type: application/json\n\n比如：\n\n\n__缺点__：\n\n  - 需要浏览器端和服务端同时支持，\n  -  ie10+\n\n3. window.postMessage(message, targetOrigin )\nhtml5 特性，可以使用它向其他的 window 对象发送消息，无论这个 window 对象是不是同源\n\n- window 对象 是接受消息的那一个 window 对象\n- message  要发送的消息，类型只能为 字符串\n- targetOrigin 限定接收信息的哪个 window 对象所在的域，如果不想限制域，可使用通配符 *\n..太多\n\n4. document.domain\n5. window.name\n6. CSS Text Transformation\n\n\n3. React 中 superagent\n\n  使用 superagent-jsonp\n\n\n七. jsonp怎么用\n\n八. 用过什么库\n\nsuperagent ,superagent-mock\nechart,\n\n\n九. gulp的插件用过啥\n\n\n十. webpack\n\n  - 是什么？\n\n  webpack是一个模块打包器。webpack把模块(s)连同它的依赖一起打包生成包含这些模块的静态资源。\n\n  - 为什么用它？\n\n  一个体量庞大的代码库需要好好组织。\n  模块系统提供代码库划分成模块的选项。\n\n  模块系统风格，目前有多个标准定义依赖和输出：\n\n1. script标签（不要模块系统）\n\n  下面这种就是不用模块系统，你会怎么去管理你的代码。\n\n```\n<script src=\"module1.js\"></script>\n<script src=\"module2.js\"></script>\n<script src=\"libraryA.js\"></script>\n<script src=\"module3.js\"></script>\n```\n\n模块接口导出到全局对象,即window对象。模块的接口可以访问全局对象的依赖关系\n\n__常见问题__\n\n  - 全局冲突\n  - __严重依赖加载的顺序__\n  - 开发人员必须人工解决模块/库的依赖关系\n  - 大型项目，script一溜下来可以很长,难以管理\n\n2. CommonJS :同步加载\n\n这种风格用 __同步 require__ 的方法去加载 __一个__ 依赖并用__暴露一个接口__。\n一个模块可以通过给 __export__  对象添加 __属性__ 或给 __module.exports__设 置值 来指定导出\n\n```\nrequire(\"module\");\nrequire(\"../file.js\");\nexports.doStuff = function() {};\nmodule.exports = someValue;\n```\n\n劣势 :\n1. __阻塞调用__不适用网络。__网络请求是异步的__。\n2. 没有__并行加载__机制。\n\n3. AMD和它的一些变种: 异步加载\n\n其它模块系统（例如 浏览器） 同步加载有困难(CommonJS) 而引入的一个异步版本（和定义模块和输出值的一种方法 ）。\n\n```\nrequire([\"module\", \"../file\"], function(module, file) { /* ... */ });\n\ndefine(\"mymodule\", [\"dep1\", \"dep2\"], function(d1, d2) {\n  return someExportedValue;\n});\n```\n\n优点:\n1. 适合网络的__异步请求__的风格\n2. __并行加载__多个模块。\n劣势\n1. 编码费力，更难读和写\n2. 看起来只是权宜之计。\n\n4. ES 6\n\nimport语法\n\n```\nimport \"jquery\";\nexport function doStuff() {}\nmodule \"localModule\" {}\n```\n\n优点:\n1. 静态分析很容易。\n2. 不会过时的ES标准 。\n\n劣势\n1. 浏览器支持需要时间。（迟早的事）\n2. 很少有模块用这种风格。生态圈\n2. 很少有模块用这种风格。生态圈\n\n---\n__传输：__\n\n模块应该在 __浏览器__ 执行，所以必须从 __服务器传输到浏览器__\n\n传输模块有两个极端：\n\n1. 一个一个传\n优点: 只有确实需要的模块才会传过去\n缺点: 请求多，开销大\n缺点: __请求延迟，应用程序启动缓慢__\n\n2. 全部打包在一个传\n优点: 请求的开销少，延迟少\n缺点: 很多暂时不需要的模块给传输过去了\n\n---\n_**分块传输：**_\n\n上面两种情况的折中。\n\n在 __编译__ 所有模块的时候，把 __模块切成小块__。(chunks )\n这样允许多个 __更快__, __更小__ 的请求。\n\n有些模块不是一开始就需要的，含有这些模块的分块在需要的时候可以加载到。\n这样 __加快了初始化速度__, 但是 在 __需要__ 用那些模块的时候 仍然让你去__抓更多的代码__\n\n开发者怎么做 \"切分点\"，可以根据情况自由抉择。\n\n---\n\n十一. 为什么要打包 (我说了http请求那点事)\n\n\n十三. 组件化是啥 -->  模块化\n\n组件化原则: __内聚性和低耦合性__\n\n就像要解决一个复杂的问题，需要把问题分割，变成一个个小的问题来做，比较好做，而且也比较容易多个人合作来做，一个人的问题没有做完，也不会影响到其他人。\n\n组件化，感觉更偏向 UI 方面，就像 React 里面的  Component 一样，比如说一个一般的文章列表的页面，就大致可以分成 footer ，header，文章列表，单个文章 这几个组件开发，每个组件都具有独立性。 页面就相当于一个组件的容器，然后组件一组合，就成了一个页面。\n\n然后，模块化，更偏向于功能 ( js )一些, 比如说一个 时间格式化处理的模块，一个 网络请求数据的模块。。完成某一个特定的功能。\n\n然后每个组件也可以引入多个模块，完成一个有功能的组件。\n\n\n总的来说，两个都是为了方便大家合作开发，解决代码复用的问题。而且这样维护起来也比较容易，能很快的定位问题，也能很快的统一解决问题。\n\n\n十二. 介绍一下react\n\n所谓组件，就是状态机器\n\n\nReact 是用来构建 UI 的 JavaScript 库。\n它的核心概念：\n1. 组件和基于组件的设计流程， 每个组件都只处理自己的 UI 和逻辑\n2. 单向数据流动\n3. 虚拟 DOM 取代物理  DOM 作为操作对象\n4. 用 JSX 语法取代  HTML 模版，在 JS 里声明式地描述 UI\n\n一般我们在开发的时候，会利用对 DOM 的操作，将变化的数据实时的反应到 UI 上。但是 复杂频繁的 DOM 操作一般是性能瓶颈产生的原因。 所以， REact 引入了 虚拟 DOM 的机制，在浏览器端用 Javascript 实现的一套 DOM API。\n基于 React 进行开发时，所有的 DOM 构造都是通过虚拟  DOM 进行的，当数据变化的时候， React 会重新构建整个  DOM 树，然后 React 将当前整个 DOM 树和上一次的  DOM 树对比，得到 DOM 结构的区别，然后把需要变化的部分进行实际的浏览器的 DOM 更新。\n\n而且 React 能够批处理拟 DOM 的刷新，在一个事件循环内的 两次数据变化会被合并，\n例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化。\n\n虽然每次都要构造完整的虚拟 DOM 树，但是因为 虚拟 DOM 时内存数据，性能极高，而对实际  DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。\n\n这样，在保证性能的同时，开发者将不再 需要 关注 __某个数据的变化__ 如何更新到一个或者多个具体的 __DOM元素__，只需要关心在任意一个数据状态下，整个界面是如何 Render的。\n\n以前，服务器端所要做的就是根据数据 Render 出 HTML 送到浏览器端。过去哪怕只是一个文字的颜色改变都要通过刷新整个页面来完成的。\n\n而 React 做的 就是进行局部更新以保证性能。\n\n十四. 你觉的react的优点\n\n- 开发：\n\n上面，组件化，模块化，把复杂的逻辑，交互，分解的简单。\n\n生态圈好，用得人多，有很多的最佳实践总结参考。\n\n久经考验的最佳实践总结了组件构建知识，使大型 JavaScript 代码库变得可维护、可管理。\n\nReact 适合大多数加载器和工具集 — AMD、CommonJS 或全局变量；gulp、bower、npm、browserify、webpack、grunt — 迎合现代 JavaScript 开发人员的每个奇思妙想\n\nReact 的设计是异步后端架构的完美搭档，能够适应未来的技术。\n\nReact 运行时对性能的专注可扩展至其他目标平台，包括（通过 React Native）iOS 和 Android。\n\n不用直接 操作 DOM，虚拟 DOM,\n\nReact 使用了 VirtualDOM 的技术，在改变状态的时候会去 diff 一下原状态和新状态来进行一些改变。\n\n- 维护：\n\n定位问题容易，\n增加新的需求容易\n\n十五. 为什么没有选择学习AngularJS\n\n\n\n十六. flex\n弹性布局。\n容器默认存在两根轴： 水平的主轴，垂直的交叉轴。\nitem 默认沿主轴排列，单个项目占据主轴空间叫做 main size\n\njustify-content属性定义了项目在主轴上的对齐方式\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n__item__\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n\n十七. 响应式布局是啥\n\n响应式布局是为了适配不同的终端。\n要能根据不同终端设备（不同的屏幕宽度，分辨率）实现不同的页面布局，\n\n响应式布局：\nCSS 媒体查询，Media Queries\n流体布局，\n自适应图片／视频等\n\n自适应：\nCSS 媒体查询，\n用 JS 操作 HTML 内容，\n服务器端\n\n- media queries\n\n用法：\n在 web 页面头部放入\n\n```\n<link rel=\"stylesheet\" href=\"XXX.css\" __media='all'__ / >\n<link rel=\"stylesheet\" href=\"XXXnormal.css\" __media='screen and (max-width: 1024px) '__ / >\n<link rel=\"stylesheet\" href=\"XXXwidthl.css\" __media='screen and (min-width: 1024px) '__ / >\n\n``\n\n\n步骤：\n- 基本布局\n- meta 标签设置 屏幕 1:1显示，智能手机浏览器提供全视图， 禁止用户缩放\n- 媒体查询 设置样式\nCSS\n@media screen and (max-width: 980px) {\n\n}\n\n- 设置多视图宽度\n\nmax-device-width 分辨率\n```\n// ipad\n@ media only screen and (min-width: 768px ) and (max-width: 1024px) {}\n// iphone\n@ media only screen and (min-width: 320px ) and (max-width: 768px) {}\n```\n\n- rem\n- 图片百分比\n- 图片 background-size ( cover 等比扩展图片来填满元素，contain 等比缩小图片适应元素的尺寸 )\n\n\n十八. 响应式布局是根据什么进行响应\n\n十九. css中用什么进行屏幕的判定\n--\n分辨率。\n\n二十. css中实现阴影的有什么\n\n- box-shadow\n- text-shadow\n-\n\n###二面\n\n点击a标签发生了啥\n- URL\n- 浏览器 通过 DNS 获取 IP ( 有缓存，先缓存 )\n- 浏览器发送 http 请求 ( 请求报头， 请求主体 )\n- 传输层 TCP 传输报文 ( TCP 协议，三次握手 )\n- 网络层 IP 协议查询 物理地址\n- 数据达到数据链层\n- 服务器接收数据\n- 服务器响应清求\n- 服务器返回响应文件\n- 页面渲染： 解析 HTML -> 构建 DOM 树 -> 解析Css -> 构建渲染树 -> 布局渲染树 -> 绘制渲染树\n\nTCP 三次握手，\n\n\nhttp :\n\n100 消息\n200 成功\n300 重定向\n400 客户端错 404 not found 403 forbidden\n500 服务器端错误\n\n\n\n对象： __proto__ 属性，一般是 constructor.prototype\nfunction: prototype\n\n__proto__ 指向\n\n字面量 : var a={}  --> Function.prototype\n\n构造器方式 :\nvar A = function (){};\nvar a = new A()\n; var a={}  -->  A.prototype\n\nObject.create\nvar a1 = {}\nvar a2 = Object.create(a1); --> a1\n\n__proto__ 连起来，递归访问到头是 null\n\n\n\nhttp2您说说\n\n说说各种框架\n\n聊聊AngularJS（说了我的理解，但不怎么了解）\n\n那你熟悉哪个框架（正在玩React，vue也懂一点）\n\n聊聊项目\n\n聊聊模块化吧\n\nsass你怎么用\n\ngulp用过啥\n\ngulp-autoprefixer\ngulp-sass\ngulp-ruby-sass\ngulp-concat\ngulp-connect\ngulp-if\ngulp-rename\ngulp-uglify\ngulp-imagemin\nimagemin-pngquant\nhttp-server\n\n\n介绍一下webpack\n\n实现sum(2,3);sum(2,3,4);sum(2,3,4,5);(我用了比较原始的方法，if来判断)\n\n那如果sum里面的参数不确定呢（提取arguments的长度，用for循环）\n\n\n\n你知道伪数组吗？\n-\n不是数组，有 length 并且值的类型为 number\n\n\n原型链\n\n\n那你重新设计一下这个函数，让它直接拥有数组的方法吧（var arg = Array.prototype.call(arguments)）\n\nok， 再来一个数组去重吧（这太经典了吧）\n","source":"_drafts/面试 DaoClound.md","raw":"\n### 一面\n\n一. html语义化\n\n语义：能够让你更恰当地描述你的内容是什么。\n\n二. h5新标签\n\nHyper Text Markup Language，即超文本标记语言\n其主要的目标是将互联网语义化。以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。\n\n- 语义：\n\n  + 节段和提纲\n\n```\n<section>, <article>, <nav>, <header>, <footer>, <aside> 和<hgroup>.\n```\n  + 音频和视频\n\n```\n<audio> 和 <video>\n```\n\n  + 表单\n\n```\n<input> 属性type 的一些新值 ，新的 <output> 元素。\n```\n\n  + 新的语义元素\n\n```\n<mark>， <figure>， <figcaption>， <data>， <time>， <output>， <progress>，<meter>和<main>\n```\n\n```\n  + <iframe> 的改进\n使用 sandbox， seamless， 和 srcdoc 属性，作者们现在可以精确控制 <iframe>元素的安全级别以及期望的渲染。\n```\n\n  + MathML\n\n允许直接嵌入数学公式。\n\n- 通信\n\n  + Web Sockets\n\n允许在页面和服务器之间建立持久连接并通过这种方法来交换非 HTML 数据。\n\n  + Server-sent events\n\n允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。\n\n  + WebRTC\n\n这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。\n\n  + 离线 & 存储\n\n\n 存储： Web Storage\n\n- sessionStorage 为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用 ( __浏览器打开状态，包括页面重新加载和恢复__ )( 只能在一个网页！ )\n\n- localStorage 在浏览器关闭，然后重新打开__仍存在__。(同源网站)\n\n- cookie ( 同源 )\n-\n服务器设置的set-cookies ，浏览器保存下来，每一次请求的时候都带着它。\n\n\n- 多媒体\n\n```\n   <audio> 和 <video>\n```\n元素嵌入并支持新的多媒体内容的操作\n\n  + 使用 Camera API\n\n允许使用，操作计算机摄像头，并从中存储图像。\n\n  + 图像 & 效果\n```\n <canvas>  绘制图像和其他对象\n```\n__SVG__ 一个基于 XML 的可以直接嵌入到 HTML 中的矢量图像格式\n\n  + WebGL\n```\nWebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 HTML5 <canvas>元素中的 API 给 Web 带来了 3D 图像功能。\n```\n- 性能 & 集成\n\n  + Web Workers\n\n能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。\n\n  + XMLHttpRequest Level 2\n---\n允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax背后的技术。\n\n  + History API\n\n允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。\n\nhistory.pushState()\n  会在当前的文档内创建和 __激活新的历史记录条目__， 不会触发 __hashchange__ 事件\n\nhistory.replaceState()\n  __会修改当前历史记录 ( 不是创建 )__\n\n\n- 样式 CSS3\n\n  + 新的背景样式特性\n\n现在可以使用 box-shadow 给逻辑框设置一个阴影，而且还可以设置 多背景\n\n  + 更精美的边框\n\n    border-image,\n    border-radius\n\n  + CSS Transitions 在不同的__状态间__设置动画\n\n  + CSS Animations 在页面的某些部分设置动画而__不需要一个触发事件__\n\n  + 你现在可以在页面中控制移动元素了\n\n  + 排版方面的改进\n\n  还可以给它设置一个 阴影 或者更精细地控制它的 decorations。\n\n    - Word-wrap\n    - Text-overflow\n    - hyphenation\n    - @font-face\n\n  + 布局\n\n    - CSS 多栏布局\n    - CSS 灵活方框布局。\n\n  + Canvas\n\n三. es6\n\n\n\n四. promise\n\n对异步操作的封装，在异步操作执行成功或者失败时指定方法。\n\npromise 对象具备三种生命状态： pending, fulfilled，rejected。\n\n只能从最初的 __pending -> fulfilled / rejected__, 而且状态的改变不可逆。\n\nresolve -> fulfilled 状态, 并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数\nreject -> rejected ， catch\n\nPromise 大致的工作流程：\n- 创建 Promise 对象 => 进入等待处理阶段 Pending\n- 处理完成后，切换到  Fulfilled / Rejected\n- 根据状态，执行 then / catch 方法 内的回调\n- then 方法返回新的 Promise , 此时支持链式调用\n\n\n五. promise解决了你什么问题\n--\n异步操作时的嵌套太多。\n\n比如读\n\n六. 跨域的方法\n\n源： 协议，端口，域名\n同源策略限制了一个源中加载文本或者脚本如何与来自另一个源的资源进行交互。\n\n1. jsonp ( json with padding ), 一种包含在函数调用中的 json\n\n- 服务器端返回 jsonp 格式:\n\n```\n  callback(  // callback 是浏览器传过去的回调函数\n    {\n      'name': 'innle'\n    }\n  )\n```\n\n如何使用？\n\n__浏览器端__\n\n- 设置 dataType: jsonp\n\n- 全局注册 回调函数 callbackName( data )，\n\n  函数的参数是服务器端返回数据，\n  函数的内容就是处理这个数据\n\n- 动态生成一个 script 标签如下\n\n```\nfunction callbackName( result ) {\n  console.log(result.name );\n}\nvar jsonpScript = document.createElement(\"script\");\njsonpScript.type = \"text/javascript\";\njsonpScript.src = \"https://www.xxx.com?callbackName=\" + callbackName ;\ndocument.querySelector('head').appendChild(jsonpScript);\n\n```\n\n__服务器端__\n\n- 服务器接收到 script 请求后，从 url 的 query 的 callbackName 获取到回调函数名字，如: _callbackName_\n\n然后动态生成一段 js 片段去给这个函数传入参数执行这个函数，如：\n\n```\ncallbackName({name: 'VIVI'});\n```\n__执行__\n\n服务器返回这个 script 之后，浏览器端获取到这个 script 资源之后，会立即执行这个 javascript .\n\n- Jquery 里的 $.getJSON\n\n- 回调函数名称可以在 请求 url 中追加 __?callback=?__\n\n- 也可以定义这个名称；\n\n ```\n dataType: 'jsonp',\n jsonp: 'callbackName'\n ```\n\n\n__缺点__：\n\n  - 不仅需要 浏览器端 js 进行配置，也需要 __服务器端__ 返回数据格式的配置\n  - 只支持 __get__ 请求\n\n2. CORS  ( cross-origin resource sharing ) 跨域资源共享\n\n它允许浏览器向跨域服务器发出 XMLHttpRequest 请求\n\n使用和普通的 ajax 过程是一样的，只是 __浏览器__ 在发现这是一个跨域请求的时候会 __自动__ 帮我们处理一些事，比如验证\n\nCORS 请求分两种\n- 简单请求\n\n  条件：\n\n  浏览器做什么？\n\n  自动在请求的头文件信息加上 '__Origin__: https//zhangxiaoxu.com ' 字段，表明自己来自哪个源。服务器获取这个值后，会判断是否同意这个请求并返回\n\n  。。。  太多了\n\n- 非简单请求\n\n一般是对服务器有特殊要求的请求，比如： PUT ， DELETE，或者 Content-type: application/json\n\n比如：\n\n\n__缺点__：\n\n  - 需要浏览器端和服务端同时支持，\n  -  ie10+\n\n3. window.postMessage(message, targetOrigin )\nhtml5 特性，可以使用它向其他的 window 对象发送消息，无论这个 window 对象是不是同源\n\n- window 对象 是接受消息的那一个 window 对象\n- message  要发送的消息，类型只能为 字符串\n- targetOrigin 限定接收信息的哪个 window 对象所在的域，如果不想限制域，可使用通配符 *\n..太多\n\n4. document.domain\n5. window.name\n6. CSS Text Transformation\n\n\n3. React 中 superagent\n\n  使用 superagent-jsonp\n\n\n七. jsonp怎么用\n\n八. 用过什么库\n\nsuperagent ,superagent-mock\nechart,\n\n\n九. gulp的插件用过啥\n\n\n十. webpack\n\n  - 是什么？\n\n  webpack是一个模块打包器。webpack把模块(s)连同它的依赖一起打包生成包含这些模块的静态资源。\n\n  - 为什么用它？\n\n  一个体量庞大的代码库需要好好组织。\n  模块系统提供代码库划分成模块的选项。\n\n  模块系统风格，目前有多个标准定义依赖和输出：\n\n1. script标签（不要模块系统）\n\n  下面这种就是不用模块系统，你会怎么去管理你的代码。\n\n```\n<script src=\"module1.js\"></script>\n<script src=\"module2.js\"></script>\n<script src=\"libraryA.js\"></script>\n<script src=\"module3.js\"></script>\n```\n\n模块接口导出到全局对象,即window对象。模块的接口可以访问全局对象的依赖关系\n\n__常见问题__\n\n  - 全局冲突\n  - __严重依赖加载的顺序__\n  - 开发人员必须人工解决模块/库的依赖关系\n  - 大型项目，script一溜下来可以很长,难以管理\n\n2. CommonJS :同步加载\n\n这种风格用 __同步 require__ 的方法去加载 __一个__ 依赖并用__暴露一个接口__。\n一个模块可以通过给 __export__  对象添加 __属性__ 或给 __module.exports__设 置值 来指定导出\n\n```\nrequire(\"module\");\nrequire(\"../file.js\");\nexports.doStuff = function() {};\nmodule.exports = someValue;\n```\n\n劣势 :\n1. __阻塞调用__不适用网络。__网络请求是异步的__。\n2. 没有__并行加载__机制。\n\n3. AMD和它的一些变种: 异步加载\n\n其它模块系统（例如 浏览器） 同步加载有困难(CommonJS) 而引入的一个异步版本（和定义模块和输出值的一种方法 ）。\n\n```\nrequire([\"module\", \"../file\"], function(module, file) { /* ... */ });\n\ndefine(\"mymodule\", [\"dep1\", \"dep2\"], function(d1, d2) {\n  return someExportedValue;\n});\n```\n\n优点:\n1. 适合网络的__异步请求__的风格\n2. __并行加载__多个模块。\n劣势\n1. 编码费力，更难读和写\n2. 看起来只是权宜之计。\n\n4. ES 6\n\nimport语法\n\n```\nimport \"jquery\";\nexport function doStuff() {}\nmodule \"localModule\" {}\n```\n\n优点:\n1. 静态分析很容易。\n2. 不会过时的ES标准 。\n\n劣势\n1. 浏览器支持需要时间。（迟早的事）\n2. 很少有模块用这种风格。生态圈\n2. 很少有模块用这种风格。生态圈\n\n---\n__传输：__\n\n模块应该在 __浏览器__ 执行，所以必须从 __服务器传输到浏览器__\n\n传输模块有两个极端：\n\n1. 一个一个传\n优点: 只有确实需要的模块才会传过去\n缺点: 请求多，开销大\n缺点: __请求延迟，应用程序启动缓慢__\n\n2. 全部打包在一个传\n优点: 请求的开销少，延迟少\n缺点: 很多暂时不需要的模块给传输过去了\n\n---\n_**分块传输：**_\n\n上面两种情况的折中。\n\n在 __编译__ 所有模块的时候，把 __模块切成小块__。(chunks )\n这样允许多个 __更快__, __更小__ 的请求。\n\n有些模块不是一开始就需要的，含有这些模块的分块在需要的时候可以加载到。\n这样 __加快了初始化速度__, 但是 在 __需要__ 用那些模块的时候 仍然让你去__抓更多的代码__\n\n开发者怎么做 \"切分点\"，可以根据情况自由抉择。\n\n---\n\n十一. 为什么要打包 (我说了http请求那点事)\n\n\n十三. 组件化是啥 -->  模块化\n\n组件化原则: __内聚性和低耦合性__\n\n就像要解决一个复杂的问题，需要把问题分割，变成一个个小的问题来做，比较好做，而且也比较容易多个人合作来做，一个人的问题没有做完，也不会影响到其他人。\n\n组件化，感觉更偏向 UI 方面，就像 React 里面的  Component 一样，比如说一个一般的文章列表的页面，就大致可以分成 footer ，header，文章列表，单个文章 这几个组件开发，每个组件都具有独立性。 页面就相当于一个组件的容器，然后组件一组合，就成了一个页面。\n\n然后，模块化，更偏向于功能 ( js )一些, 比如说一个 时间格式化处理的模块，一个 网络请求数据的模块。。完成某一个特定的功能。\n\n然后每个组件也可以引入多个模块，完成一个有功能的组件。\n\n\n总的来说，两个都是为了方便大家合作开发，解决代码复用的问题。而且这样维护起来也比较容易，能很快的定位问题，也能很快的统一解决问题。\n\n\n十二. 介绍一下react\n\n所谓组件，就是状态机器\n\n\nReact 是用来构建 UI 的 JavaScript 库。\n它的核心概念：\n1. 组件和基于组件的设计流程， 每个组件都只处理自己的 UI 和逻辑\n2. 单向数据流动\n3. 虚拟 DOM 取代物理  DOM 作为操作对象\n4. 用 JSX 语法取代  HTML 模版，在 JS 里声明式地描述 UI\n\n一般我们在开发的时候，会利用对 DOM 的操作，将变化的数据实时的反应到 UI 上。但是 复杂频繁的 DOM 操作一般是性能瓶颈产生的原因。 所以， REact 引入了 虚拟 DOM 的机制，在浏览器端用 Javascript 实现的一套 DOM API。\n基于 React 进行开发时，所有的 DOM 构造都是通过虚拟  DOM 进行的，当数据变化的时候， React 会重新构建整个  DOM 树，然后 React 将当前整个 DOM 树和上一次的  DOM 树对比，得到 DOM 结构的区别，然后把需要变化的部分进行实际的浏览器的 DOM 更新。\n\n而且 React 能够批处理拟 DOM 的刷新，在一个事件循环内的 两次数据变化会被合并，\n例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化。\n\n虽然每次都要构造完整的虚拟 DOM 树，但是因为 虚拟 DOM 时内存数据，性能极高，而对实际  DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。\n\n这样，在保证性能的同时，开发者将不再 需要 关注 __某个数据的变化__ 如何更新到一个或者多个具体的 __DOM元素__，只需要关心在任意一个数据状态下，整个界面是如何 Render的。\n\n以前，服务器端所要做的就是根据数据 Render 出 HTML 送到浏览器端。过去哪怕只是一个文字的颜色改变都要通过刷新整个页面来完成的。\n\n而 React 做的 就是进行局部更新以保证性能。\n\n十四. 你觉的react的优点\n\n- 开发：\n\n上面，组件化，模块化，把复杂的逻辑，交互，分解的简单。\n\n生态圈好，用得人多，有很多的最佳实践总结参考。\n\n久经考验的最佳实践总结了组件构建知识，使大型 JavaScript 代码库变得可维护、可管理。\n\nReact 适合大多数加载器和工具集 — AMD、CommonJS 或全局变量；gulp、bower、npm、browserify、webpack、grunt — 迎合现代 JavaScript 开发人员的每个奇思妙想\n\nReact 的设计是异步后端架构的完美搭档，能够适应未来的技术。\n\nReact 运行时对性能的专注可扩展至其他目标平台，包括（通过 React Native）iOS 和 Android。\n\n不用直接 操作 DOM，虚拟 DOM,\n\nReact 使用了 VirtualDOM 的技术，在改变状态的时候会去 diff 一下原状态和新状态来进行一些改变。\n\n- 维护：\n\n定位问题容易，\n增加新的需求容易\n\n十五. 为什么没有选择学习AngularJS\n\n\n\n十六. flex\n弹性布局。\n容器默认存在两根轴： 水平的主轴，垂直的交叉轴。\nitem 默认沿主轴排列，单个项目占据主轴空间叫做 main size\n\njustify-content属性定义了项目在主轴上的对齐方式\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n__item__\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n\n十七. 响应式布局是啥\n\n响应式布局是为了适配不同的终端。\n要能根据不同终端设备（不同的屏幕宽度，分辨率）实现不同的页面布局，\n\n响应式布局：\nCSS 媒体查询，Media Queries\n流体布局，\n自适应图片／视频等\n\n自适应：\nCSS 媒体查询，\n用 JS 操作 HTML 内容，\n服务器端\n\n- media queries\n\n用法：\n在 web 页面头部放入\n\n```\n<link rel=\"stylesheet\" href=\"XXX.css\" __media='all'__ / >\n<link rel=\"stylesheet\" href=\"XXXnormal.css\" __media='screen and (max-width: 1024px) '__ / >\n<link rel=\"stylesheet\" href=\"XXXwidthl.css\" __media='screen and (min-width: 1024px) '__ / >\n\n``\n\n\n步骤：\n- 基本布局\n- meta 标签设置 屏幕 1:1显示，智能手机浏览器提供全视图， 禁止用户缩放\n- 媒体查询 设置样式\nCSS\n@media screen and (max-width: 980px) {\n\n}\n\n- 设置多视图宽度\n\nmax-device-width 分辨率\n```\n// ipad\n@ media only screen and (min-width: 768px ) and (max-width: 1024px) {}\n// iphone\n@ media only screen and (min-width: 320px ) and (max-width: 768px) {}\n```\n\n- rem\n- 图片百分比\n- 图片 background-size ( cover 等比扩展图片来填满元素，contain 等比缩小图片适应元素的尺寸 )\n\n\n十八. 响应式布局是根据什么进行响应\n\n十九. css中用什么进行屏幕的判定\n--\n分辨率。\n\n二十. css中实现阴影的有什么\n\n- box-shadow\n- text-shadow\n-\n\n###二面\n\n点击a标签发生了啥\n- URL\n- 浏览器 通过 DNS 获取 IP ( 有缓存，先缓存 )\n- 浏览器发送 http 请求 ( 请求报头， 请求主体 )\n- 传输层 TCP 传输报文 ( TCP 协议，三次握手 )\n- 网络层 IP 协议查询 物理地址\n- 数据达到数据链层\n- 服务器接收数据\n- 服务器响应清求\n- 服务器返回响应文件\n- 页面渲染： 解析 HTML -> 构建 DOM 树 -> 解析Css -> 构建渲染树 -> 布局渲染树 -> 绘制渲染树\n\nTCP 三次握手，\n\n\nhttp :\n\n100 消息\n200 成功\n300 重定向\n400 客户端错 404 not found 403 forbidden\n500 服务器端错误\n\n\n\n对象： __proto__ 属性，一般是 constructor.prototype\nfunction: prototype\n\n__proto__ 指向\n\n字面量 : var a={}  --> Function.prototype\n\n构造器方式 :\nvar A = function (){};\nvar a = new A()\n; var a={}  -->  A.prototype\n\nObject.create\nvar a1 = {}\nvar a2 = Object.create(a1); --> a1\n\n__proto__ 连起来，递归访问到头是 null\n\n\n\nhttp2您说说\n\n说说各种框架\n\n聊聊AngularJS（说了我的理解，但不怎么了解）\n\n那你熟悉哪个框架（正在玩React，vue也懂一点）\n\n聊聊项目\n\n聊聊模块化吧\n\nsass你怎么用\n\ngulp用过啥\n\ngulp-autoprefixer\ngulp-sass\ngulp-ruby-sass\ngulp-concat\ngulp-connect\ngulp-if\ngulp-rename\ngulp-uglify\ngulp-imagemin\nimagemin-pngquant\nhttp-server\n\n\n介绍一下webpack\n\n实现sum(2,3);sum(2,3,4);sum(2,3,4,5);(我用了比较原始的方法，if来判断)\n\n那如果sum里面的参数不确定呢（提取arguments的长度，用for循环）\n\n\n\n你知道伪数组吗？\n-\n不是数组，有 length 并且值的类型为 number\n\n\n原型链\n\n\n那你重新设计一下这个函数，让它直接拥有数组的方法吧（var arg = Array.prototype.call(arguments)）\n\nok， 再来一个数组去重吧（这太经典了吧）\n","slug":"面试 DaoClound","published":0,"date":"2016-12-13T08:03:06.000Z","updated":"2016-12-19T03:22:39.000Z","_id":"ciwpvzd530001lcra24lg1dxx","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>一. html语义化</p>\n<p>语义：能够让你更恰当地描述你的内容是什么。</p>\n<p>二. h5新标签</p>\n<p>Hyper Text Markup Language，即超文本标记语言<br>其主要的目标是将互联网语义化。以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。</p>\n<ul>\n<li><p>语义：</p>\n<ul>\n<li>节段和提纲</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;section&gt;, &lt;article&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;aside&gt; 和&lt;hgroup&gt;.</div></pre></td></tr></table></figure>\n<ul>\n<li>音频和视频</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio&gt; 和 &lt;video&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>表单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input&gt; 属性type 的一些新值 ，新的 &lt;output&gt; 元素。</div></pre></td></tr></table></figure>\n<ul>\n<li>新的语义元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mark&gt;， &lt;figure&gt;， &lt;figcaption&gt;， &lt;data&gt;， &lt;time&gt;， &lt;output&gt;， &lt;progress&gt;，&lt;meter&gt;和&lt;main&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">  + &lt;iframe&gt; 的改进</div><div class=\"line\">使用 sandbox， seamless， 和 srcdoc 属性，作者们现在可以精确控制 &lt;iframe&gt;元素的安全级别以及期望的渲染。</div></pre></td></tr></table></figure>\n<ul>\n<li>MathML</li>\n</ul>\n<p>允许直接嵌入数学公式。</p>\n<ul>\n<li><p>通信</p>\n<ul>\n<li>Web Sockets</li>\n</ul>\n</li>\n</ul>\n<p>允许在页面和服务器之间建立持久连接并通过这种方法来交换非 HTML 数据。</p>\n<ul>\n<li>Server-sent events</li>\n</ul>\n<p>允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。</p>\n<ul>\n<li>WebRTC</li>\n</ul>\n<p>这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。</p>\n<ul>\n<li>离线 &amp; 存储</li>\n</ul>\n<p> 存储： Web Storage</p>\n<ul>\n<li><p>sessionStorage 为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用 ( <strong>浏览器打开状态，包括页面重新加载和恢复</strong> )( 只能在一个网页！ )</p>\n</li>\n<li><p>localStorage 在浏览器关闭，然后重新打开<strong>仍存在</strong>。(同源网站)</p>\n</li>\n<li><p>cookie ( 同源 )<br>-<br>服务器设置的set-cookies ，浏览器保存下来，每一次请求的时候都带着它。</p>\n</li>\n</ul>\n<ul>\n<li>多媒体</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio&gt; 和 &lt;video&gt;</div></pre></td></tr></table></figure>\n<p>元素嵌入并支持新的多媒体内容的操作</p>\n<ul>\n<li>使用 Camera API</li>\n</ul>\n<p>允许使用，操作计算机摄像头，并从中存储图像。</p>\n<ul>\n<li>图像 &amp; 效果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;canvas&gt;  绘制图像和其他对象</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>SVG</strong> 一个基于 XML 的可以直接嵌入到 HTML 中的矢量图像格式</p>\n<ul>\n<li>WebGL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 HTML5 &lt;canvas&gt;元素中的 API 给 Web 带来了 3D 图像功能。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>性能 &amp; 集成</p>\n<ul>\n<li>Web Workers</li>\n</ul>\n</li>\n</ul>\n<p>能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。</p>\n<h2 id=\"XMLHttpRequest-Level-2\"><a href=\"#XMLHttpRequest-Level-2\" class=\"headerlink\" title=\"  + XMLHttpRequest Level 2\"></a>  + XMLHttpRequest Level 2</h2><p>允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax背后的技术。</p>\n<ul>\n<li>History API</li>\n</ul>\n<p>允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。</p>\n<p>history.pushState()<br>  会在当前的文档内创建和 <strong>激活新的历史记录条目</strong>， 不会触发 <strong>hashchange</strong> 事件</p>\n<p>history.replaceState()<br>  <strong>会修改当前历史记录 ( 不是创建 )</strong></p>\n<ul>\n<li><p>样式 CSS3</p>\n<ul>\n<li>新的背景样式特性</li>\n</ul>\n</li>\n</ul>\n<p>现在可以使用 box-shadow 给逻辑框设置一个阴影，而且还可以设置 多背景</p>\n<ul>\n<li><p>更精美的边框</p>\n<p>border-image,<br>border-radius</p>\n</li>\n<li><p>CSS Transitions 在不同的<strong>状态间</strong>设置动画</p>\n</li>\n<li><p>CSS Animations 在页面的某些部分设置动画而<strong>不需要一个触发事件</strong></p>\n</li>\n<li><p>你现在可以在页面中控制移动元素了</p>\n</li>\n<li><p>排版方面的改进</p>\n<p>还可以给它设置一个 阴影 或者更精细地控制它的 decorations。</p>\n<ul>\n<li>Word-wrap</li>\n<li>Text-overflow</li>\n<li>hyphenation</li>\n<li>@font-face</li>\n</ul>\n</li>\n<li><p>布局</p>\n<ul>\n<li>CSS 多栏布局</li>\n<li>CSS 灵活方框布局。</li>\n</ul>\n</li>\n<li><p>Canvas</p>\n</li>\n</ul>\n<p>三. es6</p>\n<p>四. promise</p>\n<p>对异步操作的封装，在异步操作执行成功或者失败时指定方法。</p>\n<p>promise 对象具备三种生命状态： pending, fulfilled，rejected。</p>\n<p>只能从最初的 <strong>pending -&gt; fulfilled / rejected</strong>, 而且状态的改变不可逆。</p>\n<p>resolve -&gt; fulfilled 状态, 并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数<br>reject -&gt; rejected ， catch</p>\n<p>Promise 大致的工作流程：</p>\n<ul>\n<li>创建 Promise 对象 =&gt; 进入等待处理阶段 Pending</li>\n<li>处理完成后，切换到  Fulfilled / Rejected</li>\n<li>根据状态，执行 then / catch 方法 内的回调</li>\n<li>then 方法返回新的 Promise , 此时支持链式调用</li>\n</ul>\n<h2 id=\"五-promise解决了你什么问题\"><a href=\"#五-promise解决了你什么问题\" class=\"headerlink\" title=\"五. promise解决了你什么问题\"></a>五. promise解决了你什么问题</h2><p>异步操作时的嵌套太多。</p>\n<p>比如读</p>\n<p>六. 跨域的方法</p>\n<p>源： 协议，端口，域名<br>同源策略限制了一个源中加载文本或者脚本如何与来自另一个源的资源进行交互。</p>\n<ol>\n<li>jsonp ( json with padding ), 一种包含在函数调用中的 json</li>\n</ol>\n<ul>\n<li>服务器端返回 jsonp 格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback(  // callback 是浏览器传过去的回调函数</div><div class=\"line\">  &#123;</div><div class=\"line\">    &apos;name&apos;: &apos;innle&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>如何使用？</p>\n<p><strong>浏览器端</strong></p>\n<ul>\n<li><p>设置 dataType: jsonp</p>\n</li>\n<li><p>全局注册 回调函数 callbackName( data )，</p>\n<p>函数的参数是服务器端返回数据，<br>函数的内容就是处理这个数据</p>\n</li>\n<li><p>动态生成一个 script 标签如下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function callbackName( result ) &#123;</div><div class=\"line\">  console.log(result.name );</div><div class=\"line\">&#125;</div><div class=\"line\">var jsonpScript = document.createElement(&quot;script&quot;);</div><div class=\"line\">jsonpScript.type = &quot;text/javascript&quot;;</div><div class=\"line\">jsonpScript.src = &quot;https://www.xxx.com?callbackName=&quot; + callbackName ;</div><div class=\"line\">document.querySelector(&apos;head&apos;).appendChild(jsonpScript);</div></pre></td></tr></table></figure>\n<p><strong>服务器端</strong></p>\n<ul>\n<li>服务器接收到 script 请求后，从 url 的 query 的 callbackName 获取到回调函数名字，如: <em>callbackName</em></li>\n</ul>\n<p>然后动态生成一段 js 片段去给这个函数传入参数执行这个函数，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">callbackName(&#123;name: &apos;VIVI&apos;&#125;);</div></pre></td></tr></table></figure>\n<p><strong>执行</strong></p>\n<p>服务器返回这个 script 之后，浏览器端获取到这个 script 资源之后，会立即执行这个 javascript .</p>\n<ul>\n<li><p>Jquery 里的 $.getJSON</p>\n</li>\n<li><p>回调函数名称可以在 请求 url 中追加 <strong>?callback=?</strong></p>\n</li>\n<li><p>也可以定义这个名称；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">dataType: &apos;jsonp&apos;,</div><div class=\"line\">jsonp: &apos;callbackName&apos;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>不仅需要 浏览器端 js 进行配置，也需要 <strong>服务器端</strong> 返回数据格式的配置</li>\n<li>只支持 <strong>get</strong> 请求</li>\n</ul>\n<ol>\n<li>CORS  ( cross-origin resource sharing ) 跨域资源共享</li>\n</ol>\n<p>它允许浏览器向跨域服务器发出 XMLHttpRequest 请求</p>\n<p>使用和普通的 ajax 过程是一样的，只是 <strong>浏览器</strong> 在发现这是一个跨域请求的时候会 <strong>自动</strong> 帮我们处理一些事，比如验证</p>\n<p>CORS 请求分两种</p>\n<ul>\n<li><p>简单请求</p>\n<p>条件：</p>\n<p>浏览器做什么？</p>\n<p>自动在请求的头文件信息加上 ‘<strong>Origin</strong>: https//zhangxiaoxu.com ‘ 字段，表明自己来自哪个源。服务器获取这个值后，会判断是否同意这个请求并返回</p>\n<p>。。。  太多了</p>\n</li>\n<li><p>非简单请求</p>\n</li>\n</ul>\n<p>一般是对服务器有特殊要求的请求，比如： PUT ， DELETE，或者 Content-type: application/json</p>\n<p>比如：</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要浏览器端和服务端同时支持，</li>\n<li>ie10+</li>\n</ul>\n<ol>\n<li>window.postMessage(message, targetOrigin )<br>html5 特性，可以使用它向其他的 window 对象发送消息，无论这个 window 对象是不是同源</li>\n</ol>\n<ul>\n<li>window 对象 是接受消息的那一个 window 对象</li>\n<li>message  要发送的消息，类型只能为 字符串</li>\n<li>targetOrigin 限定接收信息的哪个 window 对象所在的域，如果不想限制域，可使用通配符 *<br>..太多</li>\n</ul>\n<ol>\n<li>document.domain</li>\n<li>window.name</li>\n<li>CSS Text Transformation</li>\n</ol>\n<ol>\n<li><p>React 中 superagent</p>\n<p>使用 superagent-jsonp</p>\n</li>\n</ol>\n<p>七. jsonp怎么用</p>\n<p>八. 用过什么库</p>\n<p>superagent ,superagent-mock<br>echart,</p>\n<p>九. gulp的插件用过啥</p>\n<p>十. webpack</p>\n<ul>\n<li><p>是什么？</p>\n<p>webpack是一个模块打包器。webpack把模块(s)连同它的依赖一起打包生成包含这些模块的静态资源。</p>\n</li>\n<li><p>为什么用它？</p>\n<p>一个体量庞大的代码库需要好好组织。<br>模块系统提供代码库划分成模块的选项。</p>\n<p>模块系统风格，目前有多个标准定义依赖和输出：</p>\n</li>\n</ul>\n<ol>\n<li><p>script标签（不要模块系统）</p>\n<p>下面这种就是不用模块系统，你会怎么去管理你的代码。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>模块接口导出到全局对象,即window对象。模块的接口可以访问全局对象的依赖关系</p>\n<p><strong>常见问题</strong></p>\n<ul>\n<li>全局冲突</li>\n<li><strong>严重依赖加载的顺序</strong></li>\n<li>开发人员必须人工解决模块/库的依赖关系</li>\n<li>大型项目，script一溜下来可以很长,难以管理</li>\n</ul>\n<ol>\n<li>CommonJS :同步加载</li>\n</ol>\n<p>这种风格用 <strong>同步 require</strong> 的方法去加载 <strong>一个</strong> 依赖并用<strong>暴露一个接口</strong>。<br>一个模块可以通过给 <strong>export</strong>  对象添加 <strong>属性</strong> 或给 <strong>module.exports</strong>设 置值 来指定导出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">require(&quot;module&quot;);</div><div class=\"line\">require(&quot;../file.js&quot;);</div><div class=\"line\">exports.doStuff = function() &#123;&#125;;</div><div class=\"line\">module.exports = someValue;</div></pre></td></tr></table></figure>\n<p>劣势 :</p>\n<ol>\n<li><strong>阻塞调用</strong>不适用网络。<strong>网络请求是异步的</strong>。</li>\n<li><p>没有<strong>并行加载</strong>机制。</p>\n</li>\n<li><p>AMD和它的一些变种: 异步加载</p>\n</li>\n</ol>\n<p>其它模块系统（例如 浏览器） 同步加载有困难(CommonJS) 而引入的一个异步版本（和定义模块和输出值的一种方法 ）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;);</div><div class=\"line\"></div><div class=\"line\">define(&quot;mymodule&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</div><div class=\"line\">  return someExportedValue;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>优点:</p>\n<ol>\n<li>适合网络的<strong>异步请求</strong>的风格</li>\n<li><strong>并行加载</strong>多个模块。<br>劣势</li>\n<li>编码费力，更难读和写</li>\n<li><p>看起来只是权宜之计。</p>\n</li>\n<li><p>ES 6</p>\n</li>\n</ol>\n<p>import语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &quot;jquery&quot;;</div><div class=\"line\">export function doStuff() &#123;&#125;</div><div class=\"line\">module &quot;localModule&quot; &#123;&#125;</div></pre></td></tr></table></figure>\n<p>优点:</p>\n<ol>\n<li>静态分析很容易。</li>\n<li>不会过时的ES标准 。</li>\n</ol>\n<p>劣势</p>\n<ol>\n<li>浏览器支持需要时间。（迟早的事）</li>\n<li>很少有模块用这种风格。生态圈</li>\n<li>很少有模块用这种风格。生态圈</li>\n</ol>\n<hr>\n<p><strong>传输：</strong></p>\n<p>模块应该在 <strong>浏览器</strong> 执行，所以必须从 <strong>服务器传输到浏览器</strong></p>\n<p>传输模块有两个极端：</p>\n<ol>\n<li><p>一个一个传<br>优点: 只有确实需要的模块才会传过去<br>缺点: 请求多，开销大<br>缺点: <strong>请求延迟，应用程序启动缓慢</strong></p>\n</li>\n<li><p>全部打包在一个传<br>优点: 请求的开销少，延迟少<br>缺点: 很多暂时不需要的模块给传输过去了</p>\n</li>\n</ol>\n<hr>\n<p><em><strong>分块传输：</strong></em></p>\n<p>上面两种情况的折中。</p>\n<p>在 <strong>编译</strong> 所有模块的时候，把 <strong>模块切成小块</strong>。(chunks )<br>这样允许多个 <strong>更快</strong>, <strong>更小</strong> 的请求。</p>\n<p>有些模块不是一开始就需要的，含有这些模块的分块在需要的时候可以加载到。<br>这样 <strong>加快了初始化速度</strong>, 但是 在 <strong>需要</strong> 用那些模块的时候 仍然让你去<strong>抓更多的代码</strong></p>\n<p>开发者怎么做 “切分点”，可以根据情况自由抉择。</p>\n<hr>\n<p>十一. 为什么要打包 (我说了http请求那点事)</p>\n<p>十三. 组件化是啥 –&gt;  模块化</p>\n<p>组件化原则: <strong>内聚性和低耦合性</strong></p>\n<p>就像要解决一个复杂的问题，需要把问题分割，变成一个个小的问题来做，比较好做，而且也比较容易多个人合作来做，一个人的问题没有做完，也不会影响到其他人。</p>\n<p>组件化，感觉更偏向 UI 方面，就像 React 里面的  Component 一样，比如说一个一般的文章列表的页面，就大致可以分成 footer ，header，文章列表，单个文章 这几个组件开发，每个组件都具有独立性。 页面就相当于一个组件的容器，然后组件一组合，就成了一个页面。</p>\n<p>然后，模块化，更偏向于功能 ( js )一些, 比如说一个 时间格式化处理的模块，一个 网络请求数据的模块。。完成某一个特定的功能。</p>\n<p>然后每个组件也可以引入多个模块，完成一个有功能的组件。</p>\n<p>总的来说，两个都是为了方便大家合作开发，解决代码复用的问题。而且这样维护起来也比较容易，能很快的定位问题，也能很快的统一解决问题。</p>\n<p>十二. 介绍一下react</p>\n<p>所谓组件，就是状态机器</p>\n<p>React 是用来构建 UI 的 JavaScript 库。<br>它的核心概念：</p>\n<ol>\n<li>组件和基于组件的设计流程， 每个组件都只处理自己的 UI 和逻辑</li>\n<li>单向数据流动</li>\n<li>虚拟 DOM 取代物理  DOM 作为操作对象</li>\n<li>用 JSX 语法取代  HTML 模版，在 JS 里声明式地描述 UI</li>\n</ol>\n<p>一般我们在开发的时候，会利用对 DOM 的操作，将变化的数据实时的反应到 UI 上。但是 复杂频繁的 DOM 操作一般是性能瓶颈产生的原因。 所以， REact 引入了 虚拟 DOM 的机制，在浏览器端用 Javascript 实现的一套 DOM API。<br>基于 React 进行开发时，所有的 DOM 构造都是通过虚拟  DOM 进行的，当数据变化的时候， React 会重新构建整个  DOM 树，然后 React 将当前整个 DOM 树和上一次的  DOM 树对比，得到 DOM 结构的区别，然后把需要变化的部分进行实际的浏览器的 DOM 更新。</p>\n<p>而且 React 能够批处理拟 DOM 的刷新，在一个事件循环内的 两次数据变化会被合并，<br>例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化。</p>\n<p>虽然每次都要构造完整的虚拟 DOM 树，但是因为 虚拟 DOM 时内存数据，性能极高，而对实际  DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。</p>\n<p>这样，在保证性能的同时，开发者将不再 需要 关注 <strong>某个数据的变化</strong> 如何更新到一个或者多个具体的 <strong>DOM元素</strong>，只需要关心在任意一个数据状态下，整个界面是如何 Render的。</p>\n<p>以前，服务器端所要做的就是根据数据 Render 出 HTML 送到浏览器端。过去哪怕只是一个文字的颜色改变都要通过刷新整个页面来完成的。</p>\n<p>而 React 做的 就是进行局部更新以保证性能。</p>\n<p>十四. 你觉的react的优点</p>\n<ul>\n<li>开发：</li>\n</ul>\n<p>上面，组件化，模块化，把复杂的逻辑，交互，分解的简单。</p>\n<p>生态圈好，用得人多，有很多的最佳实践总结参考。</p>\n<p>久经考验的最佳实践总结了组件构建知识，使大型 JavaScript 代码库变得可维护、可管理。</p>\n<p>React 适合大多数加载器和工具集 — AMD、CommonJS 或全局变量；gulp、bower、npm、browserify、webpack、grunt — 迎合现代 JavaScript 开发人员的每个奇思妙想</p>\n<p>React 的设计是异步后端架构的完美搭档，能够适应未来的技术。</p>\n<p>React 运行时对性能的专注可扩展至其他目标平台，包括（通过 React Native）iOS 和 Android。</p>\n<p>不用直接 操作 DOM，虚拟 DOM,</p>\n<p>React 使用了 VirtualDOM 的技术，在改变状态的时候会去 diff 一下原状态和新状态来进行一些改变。</p>\n<ul>\n<li>维护：</li>\n</ul>\n<p>定位问题容易，<br>增加新的需求容易</p>\n<p>十五. 为什么没有选择学习AngularJS</p>\n<p>十六. flex<br>弹性布局。<br>容器默认存在两根轴： 水平的主轴，垂直的交叉轴。<br>item 默认沿主轴排列，单个项目占据主轴空间叫做 main size</p>\n<p>justify-content属性定义了项目在主轴上的对齐方式<br>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>\n<p><strong>item</strong><br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>\n<p>十七. 响应式布局是啥</p>\n<p>响应式布局是为了适配不同的终端。<br>要能根据不同终端设备（不同的屏幕宽度，分辨率）实现不同的页面布局，</p>\n<p>响应式布局：<br>CSS 媒体查询，Media Queries<br>流体布局，<br>自适应图片／视频等</p>\n<p>自适应：<br>CSS 媒体查询，<br>用 JS 操作 HTML 内容，<br>服务器端</p>\n<ul>\n<li>media queries</li>\n</ul>\n<p>用法：<br>在 web 页面头部放入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXX.css&quot; __media=&apos;all&apos;__ / &gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXXnormal.css&quot; __media=&apos;screen and (max-width: 1024px) &apos;__ / &gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXXwidthl.css&quot; __media=&apos;screen and (min-width: 1024px) &apos;__ / &gt;</div><div class=\"line\"></div><div class=\"line\">``</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">步骤：</div><div class=\"line\">- 基本布局</div><div class=\"line\">- meta 标签设置 屏幕 1:1显示，智能手机浏览器提供全视图， 禁止用户缩放</div><div class=\"line\">- 媒体查询 设置样式</div><div class=\"line\">CSS</div><div class=\"line\">@media screen and (max-width: 980px) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- 设置多视图宽度</div><div class=\"line\"></div><div class=\"line\">max-device-width 分辨率</div></pre></td></tr></table></figure>\n<p>// ipad<br>@ media only screen and (min-width: 768px ) and (max-width: 1024px) {}<br>// iphone<br>@ media only screen and (min-width: 320px ) and (max-width: 768px) {}<br>```</p>\n<ul>\n<li>rem</li>\n<li>图片百分比</li>\n<li>图片 background-size ( cover 等比扩展图片来填满元素，contain 等比缩小图片适应元素的尺寸 )</li>\n</ul>\n<p>十八. 响应式布局是根据什么进行响应</p>\n<h2 id=\"十九-css中用什么进行屏幕的判定\"><a href=\"#十九-css中用什么进行屏幕的判定\" class=\"headerlink\" title=\"十九. css中用什么进行屏幕的判定\"></a>十九. css中用什么进行屏幕的判定</h2><p>分辨率。</p>\n<p>二十. css中实现阴影的有什么</p>\n<ul>\n<li>box-shadow</li>\n<li>text-shadow<br>-</li>\n</ul>\n<p>###二面</p>\n<p>点击a标签发生了啥</p>\n<ul>\n<li>URL</li>\n<li>浏览器 通过 DNS 获取 IP ( 有缓存，先缓存 )</li>\n<li>浏览器发送 http 请求 ( 请求报头， 请求主体 )</li>\n<li>传输层 TCP 传输报文 ( TCP 协议，三次握手 )</li>\n<li>网络层 IP 协议查询 物理地址</li>\n<li>数据达到数据链层</li>\n<li>服务器接收数据</li>\n<li>服务器响应清求</li>\n<li>服务器返回响应文件</li>\n<li>页面渲染： 解析 HTML -&gt; 构建 DOM 树 -&gt; 解析Css -&gt; 构建渲染树 -&gt; 布局渲染树 -&gt; 绘制渲染树</li>\n</ul>\n<p>TCP 三次握手，</p>\n<p>http :</p>\n<p>100 消息<br>200 成功<br>300 重定向<br>400 客户端错 404 not found 403 forbidden<br>500 服务器端错误</p>\n<p>对象： <strong>proto</strong> 属性，一般是 constructor.prototype<br>function: prototype</p>\n<p><strong>proto</strong> 指向</p>\n<p>字面量 : var a={}  –&gt; Function.prototype</p>\n<p>构造器方式 :<br>var A = function (){};<br>var a = new A()<br>; var a={}  –&gt;  A.prototype</p>\n<p>Object.create<br>var a1 = {}<br>var a2 = Object.create(a1); –&gt; a1</p>\n<p><strong>proto</strong> 连起来，递归访问到头是 null</p>\n<p>http2您说说</p>\n<p>说说各种框架</p>\n<p>聊聊AngularJS（说了我的理解，但不怎么了解）</p>\n<p>那你熟悉哪个框架（正在玩React，vue也懂一点）</p>\n<p>聊聊项目</p>\n<p>聊聊模块化吧</p>\n<p>sass你怎么用</p>\n<p>gulp用过啥</p>\n<p>gulp-autoprefixer<br>gulp-sass<br>gulp-ruby-sass<br>gulp-concat<br>gulp-connect<br>gulp-if<br>gulp-rename<br>gulp-uglify<br>gulp-imagemin<br>imagemin-pngquant<br>http-server</p>\n<p>介绍一下webpack</p>\n<p>实现sum(2,3);sum(2,3,4);sum(2,3,4,5);(我用了比较原始的方法，if来判断)</p>\n<p>那如果sum里面的参数不确定呢（提取arguments的长度，用for循环）</p>\n<p>你知道伪数组吗？<br>-<br>不是数组，有 length 并且值的类型为 number</p>\n<p>原型链</p>\n<p>那你重新设计一下这个函数，让它直接拥有数组的方法吧（var arg = Array.prototype.call(arguments)）</p>\n<p>ok， 再来一个数组去重吧（这太经典了吧）</p>\n","excerpt":"","more":"<h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>一. html语义化</p>\n<p>语义：能够让你更恰当地描述你的内容是什么。</p>\n<p>二. h5新标签</p>\n<p>Hyper Text Markup Language，即超文本标记语言<br>其主要的目标是将互联网语义化。以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。</p>\n<ul>\n<li><p>语义：</p>\n<ul>\n<li>节段和提纲</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;section&gt;, &lt;article&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;aside&gt; 和&lt;hgroup&gt;.</div></pre></td></tr></table></figure>\n<ul>\n<li>音频和视频</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio&gt; 和 &lt;video&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>表单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input&gt; 属性type 的一些新值 ，新的 &lt;output&gt; 元素。</div></pre></td></tr></table></figure>\n<ul>\n<li>新的语义元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mark&gt;， &lt;figure&gt;， &lt;figcaption&gt;， &lt;data&gt;， &lt;time&gt;， &lt;output&gt;， &lt;progress&gt;，&lt;meter&gt;和&lt;main&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">  + &lt;iframe&gt; 的改进</div><div class=\"line\">使用 sandbox， seamless， 和 srcdoc 属性，作者们现在可以精确控制 &lt;iframe&gt;元素的安全级别以及期望的渲染。</div></pre></td></tr></table></figure>\n<ul>\n<li>MathML</li>\n</ul>\n<p>允许直接嵌入数学公式。</p>\n<ul>\n<li><p>通信</p>\n<ul>\n<li>Web Sockets</li>\n</ul>\n</li>\n</ul>\n<p>允许在页面和服务器之间建立持久连接并通过这种方法来交换非 HTML 数据。</p>\n<ul>\n<li>Server-sent events</li>\n</ul>\n<p>允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式。</p>\n<ul>\n<li>WebRTC</li>\n</ul>\n<p>这项技术，其中的 RTC 代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序。</p>\n<ul>\n<li>离线 &amp; 存储</li>\n</ul>\n<p> 存储： Web Storage</p>\n<ul>\n<li><p>sessionStorage 为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用 ( <strong>浏览器打开状态，包括页面重新加载和恢复</strong> )( 只能在一个网页！ )</p>\n</li>\n<li><p>localStorage 在浏览器关闭，然后重新打开<strong>仍存在</strong>。(同源网站)</p>\n</li>\n<li><p>cookie ( 同源 )<br>-<br>服务器设置的set-cookies ，浏览器保存下来，每一次请求的时候都带着它。</p>\n</li>\n</ul>\n<ul>\n<li>多媒体</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;audio&gt; 和 &lt;video&gt;</div></pre></td></tr></table></figure>\n<p>元素嵌入并支持新的多媒体内容的操作</p>\n<ul>\n<li>使用 Camera API</li>\n</ul>\n<p>允许使用，操作计算机摄像头，并从中存储图像。</p>\n<ul>\n<li>图像 &amp; 效果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;canvas&gt;  绘制图像和其他对象</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>SVG</strong> 一个基于 XML 的可以直接嵌入到 HTML 中的矢量图像格式</p>\n<ul>\n<li>WebGL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WebGL 通过引入了一套非常地符合 OpenGL ES 2.0 并且可以用在 HTML5 &lt;canvas&gt;元素中的 API 给 Web 带来了 3D 图像功能。</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>性能 &amp; 集成</p>\n<ul>\n<li>Web Workers</li>\n</ul>\n</li>\n</ul>\n<p>能够把 JavaScript 计算委托给后台线程，通过允许这些活动以防止使交互型事件变得缓慢。</p>\n<h2 id=\"XMLHttpRequest-Level-2\"><a href=\"#XMLHttpRequest-Level-2\" class=\"headerlink\" title=\"  + XMLHttpRequest Level 2\"></a>  + XMLHttpRequest Level 2</h2><p>允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这是在 Ajax背后的技术。</p>\n<ul>\n<li>History API</li>\n</ul>\n<p>允许对浏览器历史记录进行操作。这对于那些交互地加载新信息的页面尤其有用。</p>\n<p>history.pushState()<br>  会在当前的文档内创建和 <strong>激活新的历史记录条目</strong>， 不会触发 <strong>hashchange</strong> 事件</p>\n<p>history.replaceState()<br>  <strong>会修改当前历史记录 ( 不是创建 )</strong></p>\n<ul>\n<li><p>样式 CSS3</p>\n<ul>\n<li>新的背景样式特性</li>\n</ul>\n</li>\n</ul>\n<p>现在可以使用 box-shadow 给逻辑框设置一个阴影，而且还可以设置 多背景</p>\n<ul>\n<li><p>更精美的边框</p>\n<p>border-image,<br>border-radius</p>\n</li>\n<li><p>CSS Transitions 在不同的<strong>状态间</strong>设置动画</p>\n</li>\n<li><p>CSS Animations 在页面的某些部分设置动画而<strong>不需要一个触发事件</strong></p>\n</li>\n<li><p>你现在可以在页面中控制移动元素了</p>\n</li>\n<li><p>排版方面的改进</p>\n<p>还可以给它设置一个 阴影 或者更精细地控制它的 decorations。</p>\n<ul>\n<li>Word-wrap</li>\n<li>Text-overflow</li>\n<li>hyphenation</li>\n<li>@font-face</li>\n</ul>\n</li>\n<li><p>布局</p>\n<ul>\n<li>CSS 多栏布局</li>\n<li>CSS 灵活方框布局。</li>\n</ul>\n</li>\n<li><p>Canvas</p>\n</li>\n</ul>\n<p>三. es6</p>\n<p>四. promise</p>\n<p>对异步操作的封装，在异步操作执行成功或者失败时指定方法。</p>\n<p>promise 对象具备三种生命状态： pending, fulfilled，rejected。</p>\n<p>只能从最初的 <strong>pending -&gt; fulfilled / rejected</strong>, 而且状态的改变不可逆。</p>\n<p>resolve -&gt; fulfilled 状态, 并将 resolve 方法的第一个参数传给后续 then 所指定的 onFulfilled 函数<br>reject -&gt; rejected ， catch</p>\n<p>Promise 大致的工作流程：</p>\n<ul>\n<li>创建 Promise 对象 =&gt; 进入等待处理阶段 Pending</li>\n<li>处理完成后，切换到  Fulfilled / Rejected</li>\n<li>根据状态，执行 then / catch 方法 内的回调</li>\n<li>then 方法返回新的 Promise , 此时支持链式调用</li>\n</ul>\n<h2 id=\"五-promise解决了你什么问题\"><a href=\"#五-promise解决了你什么问题\" class=\"headerlink\" title=\"五. promise解决了你什么问题\"></a>五. promise解决了你什么问题</h2><p>异步操作时的嵌套太多。</p>\n<p>比如读</p>\n<p>六. 跨域的方法</p>\n<p>源： 协议，端口，域名<br>同源策略限制了一个源中加载文本或者脚本如何与来自另一个源的资源进行交互。</p>\n<ol>\n<li>jsonp ( json with padding ), 一种包含在函数调用中的 json</li>\n</ol>\n<ul>\n<li>服务器端返回 jsonp 格式:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">callback(  // callback 是浏览器传过去的回调函数</div><div class=\"line\">  &#123;</div><div class=\"line\">    &apos;name&apos;: &apos;innle&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>如何使用？</p>\n<p><strong>浏览器端</strong></p>\n<ul>\n<li><p>设置 dataType: jsonp</p>\n</li>\n<li><p>全局注册 回调函数 callbackName( data )，</p>\n<p>函数的参数是服务器端返回数据，<br>函数的内容就是处理这个数据</p>\n</li>\n<li><p>动态生成一个 script 标签如下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function callbackName( result ) &#123;</div><div class=\"line\">  console.log(result.name );</div><div class=\"line\">&#125;</div><div class=\"line\">var jsonpScript = document.createElement(&quot;script&quot;);</div><div class=\"line\">jsonpScript.type = &quot;text/javascript&quot;;</div><div class=\"line\">jsonpScript.src = &quot;https://www.xxx.com?callbackName=&quot; + callbackName ;</div><div class=\"line\">document.querySelector(&apos;head&apos;).appendChild(jsonpScript);</div></pre></td></tr></table></figure>\n<p><strong>服务器端</strong></p>\n<ul>\n<li>服务器接收到 script 请求后，从 url 的 query 的 callbackName 获取到回调函数名字，如: <em>callbackName</em></li>\n</ul>\n<p>然后动态生成一段 js 片段去给这个函数传入参数执行这个函数，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">callbackName(&#123;name: &apos;VIVI&apos;&#125;);</div></pre></td></tr></table></figure>\n<p><strong>执行</strong></p>\n<p>服务器返回这个 script 之后，浏览器端获取到这个 script 资源之后，会立即执行这个 javascript .</p>\n<ul>\n<li><p>Jquery 里的 $.getJSON</p>\n</li>\n<li><p>回调函数名称可以在 请求 url 中追加 <strong>?callback=?</strong></p>\n</li>\n<li><p>也可以定义这个名称；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">dataType: &apos;jsonp&apos;,</div><div class=\"line\">jsonp: &apos;callbackName&apos;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>不仅需要 浏览器端 js 进行配置，也需要 <strong>服务器端</strong> 返回数据格式的配置</li>\n<li>只支持 <strong>get</strong> 请求</li>\n</ul>\n<ol>\n<li>CORS  ( cross-origin resource sharing ) 跨域资源共享</li>\n</ol>\n<p>它允许浏览器向跨域服务器发出 XMLHttpRequest 请求</p>\n<p>使用和普通的 ajax 过程是一样的，只是 <strong>浏览器</strong> 在发现这是一个跨域请求的时候会 <strong>自动</strong> 帮我们处理一些事，比如验证</p>\n<p>CORS 请求分两种</p>\n<ul>\n<li><p>简单请求</p>\n<p>条件：</p>\n<p>浏览器做什么？</p>\n<p>自动在请求的头文件信息加上 ‘<strong>Origin</strong>: https//zhangxiaoxu.com ‘ 字段，表明自己来自哪个源。服务器获取这个值后，会判断是否同意这个请求并返回</p>\n<p>。。。  太多了</p>\n</li>\n<li><p>非简单请求</p>\n</li>\n</ul>\n<p>一般是对服务器有特殊要求的请求，比如： PUT ， DELETE，或者 Content-type: application/json</p>\n<p>比如：</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要浏览器端和服务端同时支持，</li>\n<li>ie10+</li>\n</ul>\n<ol>\n<li>window.postMessage(message, targetOrigin )<br>html5 特性，可以使用它向其他的 window 对象发送消息，无论这个 window 对象是不是同源</li>\n</ol>\n<ul>\n<li>window 对象 是接受消息的那一个 window 对象</li>\n<li>message  要发送的消息，类型只能为 字符串</li>\n<li>targetOrigin 限定接收信息的哪个 window 对象所在的域，如果不想限制域，可使用通配符 *<br>..太多</li>\n</ul>\n<ol>\n<li>document.domain</li>\n<li>window.name</li>\n<li>CSS Text Transformation</li>\n</ol>\n<ol>\n<li><p>React 中 superagent</p>\n<p>使用 superagent-jsonp</p>\n</li>\n</ol>\n<p>七. jsonp怎么用</p>\n<p>八. 用过什么库</p>\n<p>superagent ,superagent-mock<br>echart,</p>\n<p>九. gulp的插件用过啥</p>\n<p>十. webpack</p>\n<ul>\n<li><p>是什么？</p>\n<p>webpack是一个模块打包器。webpack把模块(s)连同它的依赖一起打包生成包含这些模块的静态资源。</p>\n</li>\n<li><p>为什么用它？</p>\n<p>一个体量庞大的代码库需要好好组织。<br>模块系统提供代码库划分成模块的选项。</p>\n<p>模块系统风格，目前有多个标准定义依赖和输出：</p>\n</li>\n</ul>\n<ol>\n<li><p>script标签（不要模块系统）</p>\n<p>下面这种就是不用模块系统，你会怎么去管理你的代码。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>模块接口导出到全局对象,即window对象。模块的接口可以访问全局对象的依赖关系</p>\n<p><strong>常见问题</strong></p>\n<ul>\n<li>全局冲突</li>\n<li><strong>严重依赖加载的顺序</strong></li>\n<li>开发人员必须人工解决模块/库的依赖关系</li>\n<li>大型项目，script一溜下来可以很长,难以管理</li>\n</ul>\n<ol>\n<li>CommonJS :同步加载</li>\n</ol>\n<p>这种风格用 <strong>同步 require</strong> 的方法去加载 <strong>一个</strong> 依赖并用<strong>暴露一个接口</strong>。<br>一个模块可以通过给 <strong>export</strong>  对象添加 <strong>属性</strong> 或给 <strong>module.exports</strong>设 置值 来指定导出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">require(&quot;module&quot;);</div><div class=\"line\">require(&quot;../file.js&quot;);</div><div class=\"line\">exports.doStuff = function() &#123;&#125;;</div><div class=\"line\">module.exports = someValue;</div></pre></td></tr></table></figure>\n<p>劣势 :</p>\n<ol>\n<li><strong>阻塞调用</strong>不适用网络。<strong>网络请求是异步的</strong>。</li>\n<li><p>没有<strong>并行加载</strong>机制。</p>\n</li>\n<li><p>AMD和它的一些变种: 异步加载</p>\n</li>\n</ol>\n<p>其它模块系统（例如 浏览器） 同步加载有困难(CommonJS) 而引入的一个异步版本（和定义模块和输出值的一种方法 ）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;);</div><div class=\"line\"></div><div class=\"line\">define(&quot;mymodule&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</div><div class=\"line\">  return someExportedValue;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>优点:</p>\n<ol>\n<li>适合网络的<strong>异步请求</strong>的风格</li>\n<li><strong>并行加载</strong>多个模块。<br>劣势</li>\n<li>编码费力，更难读和写</li>\n<li><p>看起来只是权宜之计。</p>\n</li>\n<li><p>ES 6</p>\n</li>\n</ol>\n<p>import语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &quot;jquery&quot;;</div><div class=\"line\">export function doStuff() &#123;&#125;</div><div class=\"line\">module &quot;localModule&quot; &#123;&#125;</div></pre></td></tr></table></figure>\n<p>优点:</p>\n<ol>\n<li>静态分析很容易。</li>\n<li>不会过时的ES标准 。</li>\n</ol>\n<p>劣势</p>\n<ol>\n<li>浏览器支持需要时间。（迟早的事）</li>\n<li>很少有模块用这种风格。生态圈</li>\n<li>很少有模块用这种风格。生态圈</li>\n</ol>\n<hr>\n<p><strong>传输：</strong></p>\n<p>模块应该在 <strong>浏览器</strong> 执行，所以必须从 <strong>服务器传输到浏览器</strong></p>\n<p>传输模块有两个极端：</p>\n<ol>\n<li><p>一个一个传<br>优点: 只有确实需要的模块才会传过去<br>缺点: 请求多，开销大<br>缺点: <strong>请求延迟，应用程序启动缓慢</strong></p>\n</li>\n<li><p>全部打包在一个传<br>优点: 请求的开销少，延迟少<br>缺点: 很多暂时不需要的模块给传输过去了</p>\n</li>\n</ol>\n<hr>\n<p><em><strong>分块传输：</strong></em></p>\n<p>上面两种情况的折中。</p>\n<p>在 <strong>编译</strong> 所有模块的时候，把 <strong>模块切成小块</strong>。(chunks )<br>这样允许多个 <strong>更快</strong>, <strong>更小</strong> 的请求。</p>\n<p>有些模块不是一开始就需要的，含有这些模块的分块在需要的时候可以加载到。<br>这样 <strong>加快了初始化速度</strong>, 但是 在 <strong>需要</strong> 用那些模块的时候 仍然让你去<strong>抓更多的代码</strong></p>\n<p>开发者怎么做 “切分点”，可以根据情况自由抉择。</p>\n<hr>\n<p>十一. 为什么要打包 (我说了http请求那点事)</p>\n<p>十三. 组件化是啥 –&gt;  模块化</p>\n<p>组件化原则: <strong>内聚性和低耦合性</strong></p>\n<p>就像要解决一个复杂的问题，需要把问题分割，变成一个个小的问题来做，比较好做，而且也比较容易多个人合作来做，一个人的问题没有做完，也不会影响到其他人。</p>\n<p>组件化，感觉更偏向 UI 方面，就像 React 里面的  Component 一样，比如说一个一般的文章列表的页面，就大致可以分成 footer ，header，文章列表，单个文章 这几个组件开发，每个组件都具有独立性。 页面就相当于一个组件的容器，然后组件一组合，就成了一个页面。</p>\n<p>然后，模块化，更偏向于功能 ( js )一些, 比如说一个 时间格式化处理的模块，一个 网络请求数据的模块。。完成某一个特定的功能。</p>\n<p>然后每个组件也可以引入多个模块，完成一个有功能的组件。</p>\n<p>总的来说，两个都是为了方便大家合作开发，解决代码复用的问题。而且这样维护起来也比较容易，能很快的定位问题，也能很快的统一解决问题。</p>\n<p>十二. 介绍一下react</p>\n<p>所谓组件，就是状态机器</p>\n<p>React 是用来构建 UI 的 JavaScript 库。<br>它的核心概念：</p>\n<ol>\n<li>组件和基于组件的设计流程， 每个组件都只处理自己的 UI 和逻辑</li>\n<li>单向数据流动</li>\n<li>虚拟 DOM 取代物理  DOM 作为操作对象</li>\n<li>用 JSX 语法取代  HTML 模版，在 JS 里声明式地描述 UI</li>\n</ol>\n<p>一般我们在开发的时候，会利用对 DOM 的操作，将变化的数据实时的反应到 UI 上。但是 复杂频繁的 DOM 操作一般是性能瓶颈产生的原因。 所以， REact 引入了 虚拟 DOM 的机制，在浏览器端用 Javascript 实现的一套 DOM API。<br>基于 React 进行开发时，所有的 DOM 构造都是通过虚拟  DOM 进行的，当数据变化的时候， React 会重新构建整个  DOM 树，然后 React 将当前整个 DOM 树和上一次的  DOM 树对比，得到 DOM 结构的区别，然后把需要变化的部分进行实际的浏览器的 DOM 更新。</p>\n<p>而且 React 能够批处理拟 DOM 的刷新，在一个事件循环内的 两次数据变化会被合并，<br>例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化。</p>\n<p>虽然每次都要构造完整的虚拟 DOM 树，但是因为 虚拟 DOM 时内存数据，性能极高，而对实际  DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。</p>\n<p>这样，在保证性能的同时，开发者将不再 需要 关注 <strong>某个数据的变化</strong> 如何更新到一个或者多个具体的 <strong>DOM元素</strong>，只需要关心在任意一个数据状态下，整个界面是如何 Render的。</p>\n<p>以前，服务器端所要做的就是根据数据 Render 出 HTML 送到浏览器端。过去哪怕只是一个文字的颜色改变都要通过刷新整个页面来完成的。</p>\n<p>而 React 做的 就是进行局部更新以保证性能。</p>\n<p>十四. 你觉的react的优点</p>\n<ul>\n<li>开发：</li>\n</ul>\n<p>上面，组件化，模块化，把复杂的逻辑，交互，分解的简单。</p>\n<p>生态圈好，用得人多，有很多的最佳实践总结参考。</p>\n<p>久经考验的最佳实践总结了组件构建知识，使大型 JavaScript 代码库变得可维护、可管理。</p>\n<p>React 适合大多数加载器和工具集 — AMD、CommonJS 或全局变量；gulp、bower、npm、browserify、webpack、grunt — 迎合现代 JavaScript 开发人员的每个奇思妙想</p>\n<p>React 的设计是异步后端架构的完美搭档，能够适应未来的技术。</p>\n<p>React 运行时对性能的专注可扩展至其他目标平台，包括（通过 React Native）iOS 和 Android。</p>\n<p>不用直接 操作 DOM，虚拟 DOM,</p>\n<p>React 使用了 VirtualDOM 的技术，在改变状态的时候会去 diff 一下原状态和新状态来进行一些改变。</p>\n<ul>\n<li>维护：</li>\n</ul>\n<p>定位问题容易，<br>增加新的需求容易</p>\n<p>十五. 为什么没有选择学习AngularJS</p>\n<p>十六. flex<br>弹性布局。<br>容器默认存在两根轴： 水平的主轴，垂直的交叉轴。<br>item 默认沿主轴排列，单个项目占据主轴空间叫做 main size</p>\n<p>justify-content属性定义了项目在主轴上的对齐方式<br>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>\n<p><strong>item</strong><br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p>\n<p>十七. 响应式布局是啥</p>\n<p>响应式布局是为了适配不同的终端。<br>要能根据不同终端设备（不同的屏幕宽度，分辨率）实现不同的页面布局，</p>\n<p>响应式布局：<br>CSS 媒体查询，Media Queries<br>流体布局，<br>自适应图片／视频等</p>\n<p>自适应：<br>CSS 媒体查询，<br>用 JS 操作 HTML 内容，<br>服务器端</p>\n<ul>\n<li>media queries</li>\n</ul>\n<p>用法：<br>在 web 页面头部放入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXX.css&quot; __media=&apos;all&apos;__ / &gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXXnormal.css&quot; __media=&apos;screen and (max-width: 1024px) &apos;__ / &gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;XXXwidthl.css&quot; __media=&apos;screen and (min-width: 1024px) &apos;__ / &gt;</div><div class=\"line\"></div><div class=\"line\">``</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">步骤：</div><div class=\"line\">- 基本布局</div><div class=\"line\">- meta 标签设置 屏幕 1:1显示，智能手机浏览器提供全视图， 禁止用户缩放</div><div class=\"line\">- 媒体查询 设置样式</div><div class=\"line\">CSS</div><div class=\"line\">@media screen and (max-width: 980px) &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- 设置多视图宽度</div><div class=\"line\"></div><div class=\"line\">max-device-width 分辨率</div></pre></td></tr></table></figure>\n<p>// ipad<br>@ media only screen and (min-width: 768px ) and (max-width: 1024px) {}<br>// iphone<br>@ media only screen and (min-width: 320px ) and (max-width: 768px) {}<br>```</p>\n<ul>\n<li>rem</li>\n<li>图片百分比</li>\n<li>图片 background-size ( cover 等比扩展图片来填满元素，contain 等比缩小图片适应元素的尺寸 )</li>\n</ul>\n<p>十八. 响应式布局是根据什么进行响应</p>\n<h2 id=\"十九-css中用什么进行屏幕的判定\"><a href=\"#十九-css中用什么进行屏幕的判定\" class=\"headerlink\" title=\"十九. css中用什么进行屏幕的判定\"></a>十九. css中用什么进行屏幕的判定</h2><p>分辨率。</p>\n<p>二十. css中实现阴影的有什么</p>\n<ul>\n<li>box-shadow</li>\n<li>text-shadow<br>-</li>\n</ul>\n<p>###二面</p>\n<p>点击a标签发生了啥</p>\n<ul>\n<li>URL</li>\n<li>浏览器 通过 DNS 获取 IP ( 有缓存，先缓存 )</li>\n<li>浏览器发送 http 请求 ( 请求报头， 请求主体 )</li>\n<li>传输层 TCP 传输报文 ( TCP 协议，三次握手 )</li>\n<li>网络层 IP 协议查询 物理地址</li>\n<li>数据达到数据链层</li>\n<li>服务器接收数据</li>\n<li>服务器响应清求</li>\n<li>服务器返回响应文件</li>\n<li>页面渲染： 解析 HTML -&gt; 构建 DOM 树 -&gt; 解析Css -&gt; 构建渲染树 -&gt; 布局渲染树 -&gt; 绘制渲染树</li>\n</ul>\n<p>TCP 三次握手，</p>\n<p>http :</p>\n<p>100 消息<br>200 成功<br>300 重定向<br>400 客户端错 404 not found 403 forbidden<br>500 服务器端错误</p>\n<p>对象： <strong>proto</strong> 属性，一般是 constructor.prototype<br>function: prototype</p>\n<p><strong>proto</strong> 指向</p>\n<p>字面量 : var a={}  –&gt; Function.prototype</p>\n<p>构造器方式 :<br>var A = function (){};<br>var a = new A()<br>; var a={}  –&gt;  A.prototype</p>\n<p>Object.create<br>var a1 = {}<br>var a2 = Object.create(a1); –&gt; a1</p>\n<p><strong>proto</strong> 连起来，递归访问到头是 null</p>\n<p>http2您说说</p>\n<p>说说各种框架</p>\n<p>聊聊AngularJS（说了我的理解，但不怎么了解）</p>\n<p>那你熟悉哪个框架（正在玩React，vue也懂一点）</p>\n<p>聊聊项目</p>\n<p>聊聊模块化吧</p>\n<p>sass你怎么用</p>\n<p>gulp用过啥</p>\n<p>gulp-autoprefixer<br>gulp-sass<br>gulp-ruby-sass<br>gulp-concat<br>gulp-connect<br>gulp-if<br>gulp-rename<br>gulp-uglify<br>gulp-imagemin<br>imagemin-pngquant<br>http-server</p>\n<p>介绍一下webpack</p>\n<p>实现sum(2,3);sum(2,3,4);sum(2,3,4,5);(我用了比较原始的方法，if来判断)</p>\n<p>那如果sum里面的参数不确定呢（提取arguments的长度，用for循环）</p>\n<p>你知道伪数组吗？<br>-<br>不是数组，有 length 并且值的类型为 number</p>\n<p>原型链</p>\n<p>那你重新设计一下这个函数，让它直接拥有数组的方法吧（var arg = Array.prototype.call(arguments)）</p>\n<p>ok， 再来一个数组去重吧（这太经典了吧）</p>\n"},{"title":"babel & eslint 配置","_content":"\n存档使用\n \n <!-- more -->\n\n- .babelrc\n\n```\n// in .babelrc\n{\n  \"presets\": [\"react\", \"es2015\", \"stage-0\"],\n}\n// 好像要 install 这几个\n// babel-plugin-transform-object-rest-spread\n// babel-preset-es2015\n// babel-preset-react\n// babel-preset-react-hmre\n//babel-preset-stage-0\n```\n\n- .eslintrc\n\n```\n// in .eslintrc\n{\n    \"parser\": \"babel-eslint\",\n    \"extends\": \"airbnb\",   \n    // 好像要额外 isntall 这几个\n    // eslint-config-airbnb\n    // eslint-config-rackt\n    // eslint-plugin-import\n    // eslint-plugin-jsx-a11y\n\n    \"env\": {\n      \"browser\": true,\n      \"commonjs\": true,\n      \"es6\": true,\n      \"jquery\": true\n    },\n    \"rules\": {\n      // \"max-len\": [1, 120, 2],\n      // \"max-len\": [1, 120, 2, {ignoreComments: true}],\n      \"arrow-parens\": 0,\n      \"react/prop-types\": [2, {ignore: [\"children\"]}],\n      \"react/jsx-filename-extension\": [1, { \"extensions\": [\".js\", \".jsx\"] }],\n      \"react/jsx-no-undef\": 2,\n      \"no-console\": 0,\n    }\n}\n```\n","source":"_posts/babel.md","raw":"---\ntitle: babel & eslint 配置\ncategories:\n- 编程\ntags:\n- 记录\n- 存档\n- 环境\n---\n\n存档使用\n \n <!-- more -->\n\n- .babelrc\n\n```\n// in .babelrc\n{\n  \"presets\": [\"react\", \"es2015\", \"stage-0\"],\n}\n// 好像要 install 这几个\n// babel-plugin-transform-object-rest-spread\n// babel-preset-es2015\n// babel-preset-react\n// babel-preset-react-hmre\n//babel-preset-stage-0\n```\n\n- .eslintrc\n\n```\n// in .eslintrc\n{\n    \"parser\": \"babel-eslint\",\n    \"extends\": \"airbnb\",   \n    // 好像要额外 isntall 这几个\n    // eslint-config-airbnb\n    // eslint-config-rackt\n    // eslint-plugin-import\n    // eslint-plugin-jsx-a11y\n\n    \"env\": {\n      \"browser\": true,\n      \"commonjs\": true,\n      \"es6\": true,\n      \"jquery\": true\n    },\n    \"rules\": {\n      // \"max-len\": [1, 120, 2],\n      // \"max-len\": [1, 120, 2, {ignoreComments: true}],\n      \"arrow-parens\": 0,\n      \"react/prop-types\": [2, {ignore: [\"children\"]}],\n      \"react/jsx-filename-extension\": [1, { \"extensions\": [\".js\", \".jsx\"] }],\n      \"react/jsx-no-undef\": 2,\n      \"no-console\": 0,\n    }\n}\n```\n","slug":"babel","published":1,"date":"2016-12-12T09:15:44.000Z","updated":"2016-12-12T09:25:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwpvzd5b0003lcra58yxgdlx","content":"<p>存档使用</p>\n <a id=\"more\"></a>\n<ul>\n<li>.babelrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in .babelrc</div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;, &quot;stage-0&quot;],</div><div class=\"line\">&#125;</div><div class=\"line\">// 好像要 install 这几个</div><div class=\"line\">// babel-plugin-transform-object-rest-spread</div><div class=\"line\">// babel-preset-es2015</div><div class=\"line\">// babel-preset-react</div><div class=\"line\">// babel-preset-react-hmre</div><div class=\"line\">//babel-preset-stage-0</div></pre></td></tr></table></figure>\n<ul>\n<li>.eslintrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in .eslintrc</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class=\"line\">    &quot;extends&quot;: &quot;airbnb&quot;,   </div><div class=\"line\">    // 好像要额外 isntall 这几个</div><div class=\"line\">    // eslint-config-airbnb</div><div class=\"line\">    // eslint-config-rackt</div><div class=\"line\">    // eslint-plugin-import</div><div class=\"line\">    // eslint-plugin-jsx-a11y</div><div class=\"line\"></div><div class=\"line\">    &quot;env&quot;: &#123;</div><div class=\"line\">      &quot;browser&quot;: true,</div><div class=\"line\">      &quot;commonjs&quot;: true,</div><div class=\"line\">      &quot;es6&quot;: true,</div><div class=\"line\">      &quot;jquery&quot;: true</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;rules&quot;: &#123;</div><div class=\"line\">      // &quot;max-len&quot;: [1, 120, 2],</div><div class=\"line\">      // &quot;max-len&quot;: [1, 120, 2, &#123;ignoreComments: true&#125;],</div><div class=\"line\">      &quot;arrow-parens&quot;: 0,</div><div class=\"line\">      &quot;react/prop-types&quot;: [2, &#123;ignore: [&quot;children&quot;]&#125;],</div><div class=\"line\">      &quot;react/jsx-filename-extension&quot;: [1, &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;] &#125;],</div><div class=\"line\">      &quot;react/jsx-no-undef&quot;: 2,</div><div class=\"line\">      &quot;no-console&quot;: 0,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>存档使用</p>","more":"<ul>\n<li>.babelrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in .babelrc</div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;, &quot;stage-0&quot;],</div><div class=\"line\">&#125;</div><div class=\"line\">// 好像要 install 这几个</div><div class=\"line\">// babel-plugin-transform-object-rest-spread</div><div class=\"line\">// babel-preset-es2015</div><div class=\"line\">// babel-preset-react</div><div class=\"line\">// babel-preset-react-hmre</div><div class=\"line\">//babel-preset-stage-0</div></pre></td></tr></table></figure>\n<ul>\n<li>.eslintrc</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in .eslintrc</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class=\"line\">    &quot;extends&quot;: &quot;airbnb&quot;,   </div><div class=\"line\">    // 好像要额外 isntall 这几个</div><div class=\"line\">    // eslint-config-airbnb</div><div class=\"line\">    // eslint-config-rackt</div><div class=\"line\">    // eslint-plugin-import</div><div class=\"line\">    // eslint-plugin-jsx-a11y</div><div class=\"line\"></div><div class=\"line\">    &quot;env&quot;: &#123;</div><div class=\"line\">      &quot;browser&quot;: true,</div><div class=\"line\">      &quot;commonjs&quot;: true,</div><div class=\"line\">      &quot;es6&quot;: true,</div><div class=\"line\">      &quot;jquery&quot;: true</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;rules&quot;: &#123;</div><div class=\"line\">      // &quot;max-len&quot;: [1, 120, 2],</div><div class=\"line\">      // &quot;max-len&quot;: [1, 120, 2, &#123;ignoreComments: true&#125;],</div><div class=\"line\">      &quot;arrow-parens&quot;: 0,</div><div class=\"line\">      &quot;react/prop-types&quot;: [2, &#123;ignore: [&quot;children&quot;]&#125;],</div><div class=\"line\">      &quot;react/jsx-filename-extension&quot;: [1, &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.jsx&quot;] &#125;],</div><div class=\"line\">      &quot;react/jsx-no-undef&quot;: 2,</div><div class=\"line\">      &quot;no-console&quot;: 0,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"webpack 配置","_content":"\n这些都是我以前记在 __有道云笔记__上的，搬过来～～\n--\n\n跟 webpack 抗战了很久，直到最近的一次才觉得自己入门了，终于完整的配成功了一次！！ 虽然我知道以后还是后奉献进去更多的时间，但是至少，进步了！\n\n每次配 webpack 的时候都是配到我想砸电脑。 ◡ ヽ(`Д´)ﾉ ┻━┻　 一把心酸泪啊～\n\n<!-- more -->\n\n#### 目录结构\n\n - root\n    + build                        发布目录，发布的时候打包成的文件放这里～\n    + dist                          开发目录，开发过程中打包成的文件放这里～\n    + src\n        - mock/                   mock 设置以及一些 模拟的数据\n        - commons/            公用的 js，\n          + utils/\n          + mock.js              superagent-mock 与 superagent 链接的地方\n        - components/        react component 一般的组件\n        - styles/                  最终输出的样式文件集合\n        - imgs/\n        - fonts/\n        - pages/                  页面组件 ( container component ), 一般这里 fetch 分发给子组件\n        - index.html\n        - index.js (入口)       webpack 打包的入口文件\n        - routes.js                react-router 路由结构\n\n\n\n记录一下现在的配置：\n\n#####  基础配置\n\n```\nvar path = require('path');\nvar webpack = require('webpack');\n// 自动生成 html 到 dist 文件里，当然还是要有模版的。。会自动添加你要引到 html 中的文件， 可以手动，也可以自动，默认是把webpack 设置打包出去的都引入。还可以自动给文件加上 hash。\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\nconst ROOT_PATH = path.resolve(__dirname);\nconst src = path.resolve(ROOT_PATH, 'src');\nconst dist = path.resolve(ROOT_PATH, 'dist');\nconst PORT = 7070;\n\nmodule.exports = {\n/*\n  现在的代码是合并以后的代码,这样出错以后就会采用source-map的形式直接显示你出错代码的位置。\n*/\n  devtool: 'eval-source-map',\n  // 这个是和 webpack-dev-derver 结合起来用的\n  entry: [\n    'webpack-dev-server/client?http:/localhost:' + PORT,\n    'webpack/hot/only-dev-server',\n    './src/index.js'\n  ],\n\n// 这个是结合 express 的用法\n  entry: [\n    'webpack-hot-middleware/client?reload=true',\n    './src/index.js'\n  ],\n\n  output: {\n    // 生成的文件放置的地方\n    path: dist,\n    publicPath: '/static/', //模板、样式、脚本、图片等资源对应的server上的路径\n    // 生成的主文件的名字\n    filename: 'bundle.js'\n    // chunkFilename: 'js/[id].bundle.js'   //dundle生成的配置\n  },\n\n  module: {\n  //先进行下检查\n    preLoaders: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        include: /src/,\n        loader: 'eslint'\n      }\n    ],\n    loaders: [{\n        test: /\\.js?$/,\n        exclude: /node_modules/,\n        include: [src, './mock'],\n        loader: 'react-hot!babel' //react 热替换\n      },\n      {\n        test: /\\.scss$/,\n           // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css?sourceMap!postcss!sass?sourceMap')\n      }, {\n        test: /\\.css$/,\n        // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css'),\n      }, {\n        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,\n        loader: 'url-loader?limit=8192&name=./fonts/[name].[ext]'\n      }, {\n        test: /\\.(png|jpe?g|gif)$/,\n        loader: 'url-loader?limit=8192&name=./imgs/[name].[ext]'\n      }\n    ]\n  },\n  // 编译 css 的时候加上 autoprefixer\n  postcss: function () {\n    return [require('autoprefixer')];\n  },\n  // 这里注意 第一个 参数是 '' ,里面没有空格\n  resolve: {\n    extensions: ['', '.js', '.jsx']\n  },\n\n  plugins: [\n  // production 环境下加  hash\n\n    new ExtractTextPlugin('./css/style.css'),\n    // 热替换\n    new webpack.HotModuleReplacementPlugin(),\n     dev 时候有错误提示，但不会自动停掉 编译 /server 服务\n    new webpack.NoErrorsPlugin(),\n    // 全局变量，这样在用 React 的时候就不用每一个文件前面都加 import 了。\n    new webpack.ProvidePlugin({\n      $: \"jquery\",\n      jQuery: \"jquery\",\n      \"window.jQuery\": \"jquery\",\n      \"React\": \"react\"\n    }),\n    new HtmlWebpackPlugin({\n      filename: './index.html',\n      template: './src/index.html',\n      title: 'Job',\n      inject: true,\n      hash: true,\n    }),\n  ]\n};\n\n```\n\n\n\n##### server 的配置 ( 开发时候用 )\n\n- 基于 express\n\n```\n// in server.js\nvar webpack = require('webpack');\nvar config = require('./webpack.config.js');\n\nvar webpackDevMiddleware = require('webpack-dev-middleware');\nvar webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst port = '7070';\nvar app = new(require('express'))();\n\nvar compiler = webpack(config);\napp.use(webpackDevMiddleware(compiler, {\n  noInfo: true,\n  publicPath: config.output.publicPath, // 与 output.publicPath 一定要一致\n  historyApiFallback: true,\n  stats: {\n    colors: true,\n  },\n}));\napp.use(webpackHotMiddleware(compiler));\n\napp.get('/', function(req,res) {\n  console.log('get /');\n  res.sendFile(__dirname + '/dist/index.html');\n});\n\napp.listen(port, '0.0.0.0', function (err, result) {\n  if (err) {\n    console.log(err);\n  }\n  // console.log('Listening at localhost:7070/');\n  console.info(\"==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port)\n});\n\n// in package.json\n// --content-base 页面／文件的 rootPath\n// --config 以这个 js 文件作为配置文件\n\n    \"dev\": \"webpack-dev-server --content-base=/dist --config server.js --progress --profile --colors\",\n\n    \"build\": \"rm -rf ./dist/* && webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details\",\n\n```\n\n\n\n- dev-serve版本\n\n```\n// webpack-dev-serve 是一个小型的用 Express 搭建成的 serve.\n// 用 webpack-dev-middleware 来 serve webpack bundle 的。（ webpack-dev-middleware 是一个简单的包装webpack的中间件，可以 watch 我们需要打包的文件，每次更新，打包成新的 bundle 都会通过它发出给serve。它将文件都放在内存里，而不是磁盘中。\n\n // in serve.js\nvar webpack = require('webpack');\nvar WebpackDevServer = require('webpack-dev-server');\nvar config = require('./webpack.config.js');\n\nvar compiler = webpack(config);\nconst API_TARGET = \"http://wuguishifu.com\";\n\nvar server = new WebpackDevServer(compiler, {\n  publicPath: config.output.publicPath,\n   // Can also be an array, or: contentBase: \"http://localhost/\",\n  contentBase: './dist',\n  inline: true,\n  noInfo: false,\n  stats: { colors: true },\n  historyApiFallback: true, // 找不到其它 html 文件时候会返回 index.html  很重要！！！\n  proxy: {  // webpack-dev-serve 利用 [http-proxy-middleware](https://github.com/nodejitsu/node-http-proxy) 来做的简单的 代理功能\n    '/api/*': {\n      target: API_TARGET,\n      secure: false,\n    },\n    '/media/*': {\n      target: API_TARGET,\n      secure: false,\n    },\n  }\n});\n\nserver.listen(7070, '0.0.0.0', function (err, result) {\n  if (err) {\n    console.log(err);\n  }\n  console.log('Listening at localhost:7070/');\n});\n\nmodule.exports = server;\n```\n\n\n- production 部分 ( 发布时候 )\n\n```\nvar path = require('path');\nvar webpack = require('webpack');\nvar config = require('./webpack.config.js');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\n\nconst ROOT_PATH = path.resolve(__dirname);\nconst src = path.resolve(ROOT_PATH, 'src');\nconst dist = path.resolve(ROOT_PATH, 'dist');\nconst build = path.resolve(ROOT_PATH, 'build');\n\nmodule.exports = {\n  devtool: false,\n\n  entry: {\n    //配置入口文件，有几个写几个。我这里有两个文件。一个是所有我需要引入的文件，一个是我的入口文件，index.js\n    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出,比如下面数组里面的js,全部压缩在了vendor这个文件这里\n    vendors: ['jquery'],\n    app: './src/index.js',\n  },\n\n  output: {\n    path: path.join(__dirname, 'build'),\n    // publicPath: '/',\n    publicPath: '/static/', //模板、样式、脚本、图片等资源对应的server上的路径\n    filename: 'bundle.[hash:8].js'\n    // chunkFilename: 'js/[id].bundle.js'   //dundle生成的配置\n  },\n\n    loaders: [{\n        test: /\\.js?$/,\n        exclude: /node_modules/,\n        include: [src, './mock'],\n        loader: 'babel'\n      },\n      {\n        test: /\\.scss$/,\n           // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css!postcss!sass')\n      }, {\n        test: /\\.css$/,\n        // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css'),\n      }, {\n        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,\n        loader: 'url-loader?limit=8192&name=./fonts/[name].[ext]'\n      }, {\n        test: /\\.(png|jpe?g|gif)$/,\n        loader: 'url-loader?limit=8192&name=./imgs/[name].[ext]'\n      }\n    ]\n  },\n  // 编译 css 的时候加上 autoprefixer\n  postcss: config.postcss,\n\n  resolve: config.resolve,\n\n  plugins: [\n    // 全局的环境变量\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new ExtractTextPlugin('./css/style.[hash:8].css'),\n    new webpack.ProvidePlugin({\n      $: \"jquery\",\n      jQuery: \"jquery\",\n      \"window.jQuery\": \"jquery\",\n      \"React\": \"react\"\n    }),\n    // 加入 minify 压缩选项\n    new HtmlWebpackPlugin({\n      filename: './index.html',\n      template: './src/index.html',\n      title: 'Job',\n      inject: true,\n      hash: true,\n      // chunks: ['vendor', 'app'], //需要引入的chunk，不配置就会引入所有页面的资源.名字来源于你的入口文件.\n      minify: {\n        removeComments: true,  // 移除HTML中的注释\n        collapseWhitespace: true  // 删除空白符与换行符\n      }\n    }),\n    // 压缩 JS，删除 console.log 之类\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false,\n        screw_ie8: true,\n        drop_console: true,\n        drop_debugger: true\n      }\n    }),\n    // 对比id的使用频率和分布来得出最短的id分配给使用频率高的模块\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 找到重复文件并去重。保证了重复的代码不被大包到bundle文件里面去，取而代之的是运行时请求一个封装的函数。\n    new webpack.optimize.DedupePlugin(),\n    //将引入的第三方库打包.这个要放到最后\n    // vendors 对应 entry 部分，打包相应的文件\n    // vendors.[hash:8].js 为打包生成的文件名\n    new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.[hash:8].js'),\n  ]\n};\n\n```\n\n##### package.json\n\n```\n\"scripts\": {\n  \"lint\": \"eslint src\",\n  \"cleardev\": \"rm -rf dist/\",\n  \"clearb\": \"rm -rf build/\",\n  \"dev\": \"npm run cleardev&&webpack-dev-server --config server.js --progress --profile --colors\",\n  \"build\": \"npm run clearb&&webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details\"\n},\n```\n\n{% blockquote %}\n\nwebpack 资料参照：\n\n- [webpack-dev-serve官网](http://webpack.github.io/docs/webpack-dev-server.html)\n\n- webpack 全套参考: [webpack 傻瓜指南](https://github.com/vikingmute/webpack-for-fools)\n\n- 多页的参考[webpack 性能优化](https://zhuanlan.zhihu.com/p/20914387?refer=jscss)\n\n- [Express结合Webpack的全栈自动刷新](http://acgtofe.com/posts/2016/02/full-live-reload-for-express-with-webpack)\n\n- 参考 [webpack 性能优化](https://zhuanlan.zhihu.com/p/20914387?refer=jscss)\n\n{% endblockquote %}\n","source":"_posts/webpack.md","raw":"---\ntitle: webpack 配置\ncategories:\n- 编程\ntags:\n- 记录\n- 存档\n- 环境\n---\n\n这些都是我以前记在 __有道云笔记__上的，搬过来～～\n--\n\n跟 webpack 抗战了很久，直到最近的一次才觉得自己入门了，终于完整的配成功了一次！！ 虽然我知道以后还是后奉献进去更多的时间，但是至少，进步了！\n\n每次配 webpack 的时候都是配到我想砸电脑。 ◡ ヽ(`Д´)ﾉ ┻━┻　 一把心酸泪啊～\n\n<!-- more -->\n\n#### 目录结构\n\n - root\n    + build                        发布目录，发布的时候打包成的文件放这里～\n    + dist                          开发目录，开发过程中打包成的文件放这里～\n    + src\n        - mock/                   mock 设置以及一些 模拟的数据\n        - commons/            公用的 js，\n          + utils/\n          + mock.js              superagent-mock 与 superagent 链接的地方\n        - components/        react component 一般的组件\n        - styles/                  最终输出的样式文件集合\n        - imgs/\n        - fonts/\n        - pages/                  页面组件 ( container component ), 一般这里 fetch 分发给子组件\n        - index.html\n        - index.js (入口)       webpack 打包的入口文件\n        - routes.js                react-router 路由结构\n\n\n\n记录一下现在的配置：\n\n#####  基础配置\n\n```\nvar path = require('path');\nvar webpack = require('webpack');\n// 自动生成 html 到 dist 文件里，当然还是要有模版的。。会自动添加你要引到 html 中的文件， 可以手动，也可以自动，默认是把webpack 设置打包出去的都引入。还可以自动给文件加上 hash。\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\nconst ROOT_PATH = path.resolve(__dirname);\nconst src = path.resolve(ROOT_PATH, 'src');\nconst dist = path.resolve(ROOT_PATH, 'dist');\nconst PORT = 7070;\n\nmodule.exports = {\n/*\n  现在的代码是合并以后的代码,这样出错以后就会采用source-map的形式直接显示你出错代码的位置。\n*/\n  devtool: 'eval-source-map',\n  // 这个是和 webpack-dev-derver 结合起来用的\n  entry: [\n    'webpack-dev-server/client?http:/localhost:' + PORT,\n    'webpack/hot/only-dev-server',\n    './src/index.js'\n  ],\n\n// 这个是结合 express 的用法\n  entry: [\n    'webpack-hot-middleware/client?reload=true',\n    './src/index.js'\n  ],\n\n  output: {\n    // 生成的文件放置的地方\n    path: dist,\n    publicPath: '/static/', //模板、样式、脚本、图片等资源对应的server上的路径\n    // 生成的主文件的名字\n    filename: 'bundle.js'\n    // chunkFilename: 'js/[id].bundle.js'   //dundle生成的配置\n  },\n\n  module: {\n  //先进行下检查\n    preLoaders: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        include: /src/,\n        loader: 'eslint'\n      }\n    ],\n    loaders: [{\n        test: /\\.js?$/,\n        exclude: /node_modules/,\n        include: [src, './mock'],\n        loader: 'react-hot!babel' //react 热替换\n      },\n      {\n        test: /\\.scss$/,\n           // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css?sourceMap!postcss!sass?sourceMap')\n      }, {\n        test: /\\.css$/,\n        // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css'),\n      }, {\n        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,\n        loader: 'url-loader?limit=8192&name=./fonts/[name].[ext]'\n      }, {\n        test: /\\.(png|jpe?g|gif)$/,\n        loader: 'url-loader?limit=8192&name=./imgs/[name].[ext]'\n      }\n    ]\n  },\n  // 编译 css 的时候加上 autoprefixer\n  postcss: function () {\n    return [require('autoprefixer')];\n  },\n  // 这里注意 第一个 参数是 '' ,里面没有空格\n  resolve: {\n    extensions: ['', '.js', '.jsx']\n  },\n\n  plugins: [\n  // production 环境下加  hash\n\n    new ExtractTextPlugin('./css/style.css'),\n    // 热替换\n    new webpack.HotModuleReplacementPlugin(),\n     dev 时候有错误提示，但不会自动停掉 编译 /server 服务\n    new webpack.NoErrorsPlugin(),\n    // 全局变量，这样在用 React 的时候就不用每一个文件前面都加 import 了。\n    new webpack.ProvidePlugin({\n      $: \"jquery\",\n      jQuery: \"jquery\",\n      \"window.jQuery\": \"jquery\",\n      \"React\": \"react\"\n    }),\n    new HtmlWebpackPlugin({\n      filename: './index.html',\n      template: './src/index.html',\n      title: 'Job',\n      inject: true,\n      hash: true,\n    }),\n  ]\n};\n\n```\n\n\n\n##### server 的配置 ( 开发时候用 )\n\n- 基于 express\n\n```\n// in server.js\nvar webpack = require('webpack');\nvar config = require('./webpack.config.js');\n\nvar webpackDevMiddleware = require('webpack-dev-middleware');\nvar webpackHotMiddleware = require('webpack-hot-middleware');\n\nconst port = '7070';\nvar app = new(require('express'))();\n\nvar compiler = webpack(config);\napp.use(webpackDevMiddleware(compiler, {\n  noInfo: true,\n  publicPath: config.output.publicPath, // 与 output.publicPath 一定要一致\n  historyApiFallback: true,\n  stats: {\n    colors: true,\n  },\n}));\napp.use(webpackHotMiddleware(compiler));\n\napp.get('/', function(req,res) {\n  console.log('get /');\n  res.sendFile(__dirname + '/dist/index.html');\n});\n\napp.listen(port, '0.0.0.0', function (err, result) {\n  if (err) {\n    console.log(err);\n  }\n  // console.log('Listening at localhost:7070/');\n  console.info(\"==> 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.\", port, port)\n});\n\n// in package.json\n// --content-base 页面／文件的 rootPath\n// --config 以这个 js 文件作为配置文件\n\n    \"dev\": \"webpack-dev-server --content-base=/dist --config server.js --progress --profile --colors\",\n\n    \"build\": \"rm -rf ./dist/* && webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details\",\n\n```\n\n\n\n- dev-serve版本\n\n```\n// webpack-dev-serve 是一个小型的用 Express 搭建成的 serve.\n// 用 webpack-dev-middleware 来 serve webpack bundle 的。（ webpack-dev-middleware 是一个简单的包装webpack的中间件，可以 watch 我们需要打包的文件，每次更新，打包成新的 bundle 都会通过它发出给serve。它将文件都放在内存里，而不是磁盘中。\n\n // in serve.js\nvar webpack = require('webpack');\nvar WebpackDevServer = require('webpack-dev-server');\nvar config = require('./webpack.config.js');\n\nvar compiler = webpack(config);\nconst API_TARGET = \"http://wuguishifu.com\";\n\nvar server = new WebpackDevServer(compiler, {\n  publicPath: config.output.publicPath,\n   // Can also be an array, or: contentBase: \"http://localhost/\",\n  contentBase: './dist',\n  inline: true,\n  noInfo: false,\n  stats: { colors: true },\n  historyApiFallback: true, // 找不到其它 html 文件时候会返回 index.html  很重要！！！\n  proxy: {  // webpack-dev-serve 利用 [http-proxy-middleware](https://github.com/nodejitsu/node-http-proxy) 来做的简单的 代理功能\n    '/api/*': {\n      target: API_TARGET,\n      secure: false,\n    },\n    '/media/*': {\n      target: API_TARGET,\n      secure: false,\n    },\n  }\n});\n\nserver.listen(7070, '0.0.0.0', function (err, result) {\n  if (err) {\n    console.log(err);\n  }\n  console.log('Listening at localhost:7070/');\n});\n\nmodule.exports = server;\n```\n\n\n- production 部分 ( 发布时候 )\n\n```\nvar path = require('path');\nvar webpack = require('webpack');\nvar config = require('./webpack.config.js');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\n\nconst ROOT_PATH = path.resolve(__dirname);\nconst src = path.resolve(ROOT_PATH, 'src');\nconst dist = path.resolve(ROOT_PATH, 'dist');\nconst build = path.resolve(ROOT_PATH, 'build');\n\nmodule.exports = {\n  devtool: false,\n\n  entry: {\n    //配置入口文件，有几个写几个。我这里有两个文件。一个是所有我需要引入的文件，一个是我的入口文件，index.js\n    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出,比如下面数组里面的js,全部压缩在了vendor这个文件这里\n    vendors: ['jquery'],\n    app: './src/index.js',\n  },\n\n  output: {\n    path: path.join(__dirname, 'build'),\n    // publicPath: '/',\n    publicPath: '/static/', //模板、样式、脚本、图片等资源对应的server上的路径\n    filename: 'bundle.[hash:8].js'\n    // chunkFilename: 'js/[id].bundle.js'   //dundle生成的配置\n  },\n\n    loaders: [{\n        test: /\\.js?$/,\n        exclude: /node_modules/,\n        include: [src, './mock'],\n        loader: 'babel'\n      },\n      {\n        test: /\\.scss$/,\n           // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css!postcss!sass')\n      }, {\n        test: /\\.css$/,\n        // 将 css 单独打包出来\n        loader: ExtractTextPlugin.extract('style-loader', 'css'),\n      }, {\n        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,\n        loader: 'url-loader?limit=8192&name=./fonts/[name].[ext]'\n      }, {\n        test: /\\.(png|jpe?g|gif)$/,\n        loader: 'url-loader?limit=8192&name=./imgs/[name].[ext]'\n      }\n    ]\n  },\n  // 编译 css 的时候加上 autoprefixer\n  postcss: config.postcss,\n\n  resolve: config.resolve,\n\n  plugins: [\n    // 全局的环境变量\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new ExtractTextPlugin('./css/style.[hash:8].css'),\n    new webpack.ProvidePlugin({\n      $: \"jquery\",\n      jQuery: \"jquery\",\n      \"window.jQuery\": \"jquery\",\n      \"React\": \"react\"\n    }),\n    // 加入 minify 压缩选项\n    new HtmlWebpackPlugin({\n      filename: './index.html',\n      template: './src/index.html',\n      title: 'Job',\n      inject: true,\n      hash: true,\n      // chunks: ['vendor', 'app'], //需要引入的chunk，不配置就会引入所有页面的资源.名字来源于你的入口文件.\n      minify: {\n        removeComments: true,  // 移除HTML中的注释\n        collapseWhitespace: true  // 删除空白符与换行符\n      }\n    }),\n    // 压缩 JS，删除 console.log 之类\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false,\n        screw_ie8: true,\n        drop_console: true,\n        drop_debugger: true\n      }\n    }),\n    // 对比id的使用频率和分布来得出最短的id分配给使用频率高的模块\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 找到重复文件并去重。保证了重复的代码不被大包到bundle文件里面去，取而代之的是运行时请求一个封装的函数。\n    new webpack.optimize.DedupePlugin(),\n    //将引入的第三方库打包.这个要放到最后\n    // vendors 对应 entry 部分，打包相应的文件\n    // vendors.[hash:8].js 为打包生成的文件名\n    new webpack.optimize.CommonsChunkPlugin('vendors', 'vendors.[hash:8].js'),\n  ]\n};\n\n```\n\n##### package.json\n\n```\n\"scripts\": {\n  \"lint\": \"eslint src\",\n  \"cleardev\": \"rm -rf dist/\",\n  \"clearb\": \"rm -rf build/\",\n  \"dev\": \"npm run cleardev&&webpack-dev-server --config server.js --progress --profile --colors\",\n  \"build\": \"npm run clearb&&webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details\"\n},\n```\n\n{% blockquote %}\n\nwebpack 资料参照：\n\n- [webpack-dev-serve官网](http://webpack.github.io/docs/webpack-dev-server.html)\n\n- webpack 全套参考: [webpack 傻瓜指南](https://github.com/vikingmute/webpack-for-fools)\n\n- 多页的参考[webpack 性能优化](https://zhuanlan.zhihu.com/p/20914387?refer=jscss)\n\n- [Express结合Webpack的全栈自动刷新](http://acgtofe.com/posts/2016/02/full-live-reload-for-express-with-webpack)\n\n- 参考 [webpack 性能优化](https://zhuanlan.zhihu.com/p/20914387?refer=jscss)\n\n{% endblockquote %}\n","slug":"webpack","published":1,"date":"2016-12-12T08:37:51.000Z","updated":"2016-12-12T09:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwpvzd6j000flcraarihfe2l","content":"<h2 id=\"这些都是我以前记在-有道云笔记上的，搬过来～～\"><a href=\"#这些都是我以前记在-有道云笔记上的，搬过来～～\" class=\"headerlink\" title=\"这些都是我以前记在 有道云笔记上的，搬过来～～\"></a>这些都是我以前记在 <strong>有道云笔记</strong>上的，搬过来～～</h2><p>跟 webpack 抗战了很久，直到最近的一次才觉得自己入门了，终于完整的配成功了一次！！ 虽然我知道以后还是后奉献进去更多的时间，但是至少，进步了！</p>\n<p>每次配 webpack 的时候都是配到我想砸电脑。 ◡ ヽ(`Д´)ﾉ ┻━┻　 一把心酸泪啊～</p>\n<a id=\"more\"></a>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><ul>\n<li>root<ul>\n<li>build                        发布目录，发布的时候打包成的文件放这里～</li>\n<li>dist                          开发目录，开发过程中打包成的文件放这里～</li>\n<li>src<ul>\n<li>mock/                   mock 设置以及一些 模拟的数据</li>\n<li>commons/            公用的 js，<ul>\n<li>utils/</li>\n<li>mock.js              superagent-mock 与 superagent 链接的地方</li>\n</ul>\n</li>\n<li>components/        react component 一般的组件</li>\n<li>styles/                  最终输出的样式文件集合</li>\n<li>imgs/</li>\n<li>fonts/</li>\n<li>pages/                  页面组件 ( container component ), 一般这里 fetch 分发给子组件</li>\n<li>index.html</li>\n<li>index.js (入口)       webpack 打包的入口文件</li>\n<li>routes.js                react-router 路由结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>记录一下现在的配置：</p>\n<h5 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">// 自动生成 html 到 dist 文件里，当然还是要有模版的。。会自动添加你要引到 html 中的文件， 可以手动，也可以自动，默认是把webpack 设置打包出去的都引入。还可以自动给文件加上 hash。</div><div class=\"line\">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class=\"line\">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class=\"line\"></div><div class=\"line\">const ROOT_PATH = path.resolve(__dirname);</div><div class=\"line\">const src = path.resolve(ROOT_PATH, &apos;src&apos;);</div><div class=\"line\">const dist = path.resolve(ROOT_PATH, &apos;dist&apos;);</div><div class=\"line\">const PORT = 7070;</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">/*</div><div class=\"line\">  现在的代码是合并以后的代码,这样出错以后就会采用source-map的形式直接显示你出错代码的位置。</div><div class=\"line\">*/</div><div class=\"line\">  devtool: &apos;eval-source-map&apos;,</div><div class=\"line\">  // 这个是和 webpack-dev-derver 结合起来用的</div><div class=\"line\">  entry: [</div><div class=\"line\">    &apos;webpack-dev-server/client?http:/localhost:&apos; + PORT,</div><div class=\"line\">    &apos;webpack/hot/only-dev-server&apos;,</div><div class=\"line\">    &apos;./src/index.js&apos;</div><div class=\"line\">  ],</div><div class=\"line\"></div><div class=\"line\">// 这个是结合 express 的用法</div><div class=\"line\">  entry: [</div><div class=\"line\">    &apos;webpack-hot-middleware/client?reload=true&apos;,</div><div class=\"line\">    &apos;./src/index.js&apos;</div><div class=\"line\">  ],</div><div class=\"line\"></div><div class=\"line\">  output: &#123;</div><div class=\"line\">    // 生成的文件放置的地方</div><div class=\"line\">    path: dist,</div><div class=\"line\">    publicPath: &apos;/static/&apos;, //模板、样式、脚本、图片等资源对应的server上的路径</div><div class=\"line\">    // 生成的主文件的名字</div><div class=\"line\">    filename: &apos;bundle.js&apos;</div><div class=\"line\">    // chunkFilename: &apos;js/[id].bundle.js&apos;   //dundle生成的配置</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  module: &#123;</div><div class=\"line\">  //先进行下检查</div><div class=\"line\">    preLoaders: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.js$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: /src/,</div><div class=\"line\">        loader: &apos;eslint&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">        test: /\\.js?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: [src, &apos;./mock&apos;],</div><div class=\"line\">        loader: &apos;react-hot!babel&apos; //react 热替换</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.scss$/,</div><div class=\"line\">           // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css?sourceMap!postcss!sass?sourceMap&apos;)</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css&apos;),</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./fonts/[name].[ext]&apos;</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(png|jpe?g|gif)$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./imgs/[name].[ext]&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 编译 css 的时候加上 autoprefixer</div><div class=\"line\">  postcss: function () &#123;</div><div class=\"line\">    return [require(&apos;autoprefixer&apos;)];</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 这里注意 第一个 参数是 &apos;&apos; ,里面没有空格</div><div class=\"line\">  resolve: &#123;</div><div class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  plugins: [</div><div class=\"line\">  // production 环境下加  hash</div><div class=\"line\"></div><div class=\"line\">    new ExtractTextPlugin(&apos;./css/style.css&apos;),</div><div class=\"line\">    // 热替换</div><div class=\"line\">    new webpack.HotModuleReplacementPlugin(),</div><div class=\"line\">     dev 时候有错误提示，但不会自动停掉 编译 /server 服务</div><div class=\"line\">    new webpack.NoErrorsPlugin(),</div><div class=\"line\">    // 全局变量，这样在用 React 的时候就不用每一个文件前面都加 import 了。</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;</div><div class=\"line\">      $: &quot;jquery&quot;,</div><div class=\"line\">      jQuery: &quot;jquery&quot;,</div><div class=\"line\">      &quot;window.jQuery&quot;: &quot;jquery&quot;,</div><div class=\"line\">      &quot;React&quot;: &quot;react&quot;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      filename: &apos;./index.html&apos;,</div><div class=\"line\">      template: &apos;./src/index.html&apos;,</div><div class=\"line\">      title: &apos;Job&apos;,</div><div class=\"line\">      inject: true,</div><div class=\"line\">      hash: true,</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"server-的配置-开发时候用\"><a href=\"#server-的配置-开发时候用\" class=\"headerlink\" title=\"server 的配置 ( 开发时候用 )\"></a>server 的配置 ( 开发时候用 )</h5><ul>\n<li>基于 express</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in server.js</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\"></div><div class=\"line\">var webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;);</div><div class=\"line\">var webpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;);</div><div class=\"line\"></div><div class=\"line\">const port = &apos;7070&apos;;</div><div class=\"line\">var app = new(require(&apos;express&apos;))();</div><div class=\"line\"></div><div class=\"line\">var compiler = webpack(config);</div><div class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</div><div class=\"line\">  noInfo: true,</div><div class=\"line\">  publicPath: config.output.publicPath, // 与 output.publicPath 一定要一致</div><div class=\"line\">  historyApiFallback: true,</div><div class=\"line\">  stats: &#123;</div><div class=\"line\">    colors: true,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;));</div><div class=\"line\">app.use(webpackHotMiddleware(compiler));</div><div class=\"line\"></div><div class=\"line\">app.get(&apos;/&apos;, function(req,res) &#123;</div><div class=\"line\">  console.log(&apos;get /&apos;);</div><div class=\"line\">  res.sendFile(__dirname + &apos;/dist/index.html&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(port, &apos;0.0.0.0&apos;, function (err, result) &#123;</div><div class=\"line\">  if (err) &#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">  // console.log(&apos;Listening at localhost:7070/&apos;);</div><div class=\"line\">  console.info(&quot;==&gt; 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.&quot;, port, port)</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// in package.json</div><div class=\"line\">// --content-base 页面／文件的 rootPath</div><div class=\"line\">// --config 以这个 js 文件作为配置文件</div><div class=\"line\"></div><div class=\"line\">    &quot;dev&quot;: &quot;webpack-dev-server --content-base=/dist --config server.js --progress --profile --colors&quot;,</div><div class=\"line\"></div><div class=\"line\">    &quot;build&quot;: &quot;rm -rf ./dist/* &amp;&amp; webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details&quot;,</div></pre></td></tr></table></figure>\n<ul>\n<li>dev-serve版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack-dev-serve 是一个小型的用 Express 搭建成的 serve.</div><div class=\"line\">// 用 webpack-dev-middleware 来 serve webpack bundle 的。（ webpack-dev-middleware 是一个简单的包装webpack的中间件，可以 watch 我们需要打包的文件，每次更新，打包成新的 bundle 都会通过它发出给serve。它将文件都放在内存里，而不是磁盘中。</div><div class=\"line\"></div><div class=\"line\"> // in serve.js</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var WebpackDevServer = require(&apos;webpack-dev-server&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\"></div><div class=\"line\">var compiler = webpack(config);</div><div class=\"line\">const API_TARGET = &quot;http://wuguishifu.com&quot;;</div><div class=\"line\"></div><div class=\"line\">var server = new WebpackDevServer(compiler, &#123;</div><div class=\"line\">  publicPath: config.output.publicPath,</div><div class=\"line\">   // Can also be an array, or: contentBase: &quot;http://localhost/&quot;,</div><div class=\"line\">  contentBase: &apos;./dist&apos;,</div><div class=\"line\">  inline: true,</div><div class=\"line\">  noInfo: false,</div><div class=\"line\">  stats: &#123; colors: true &#125;,</div><div class=\"line\">  historyApiFallback: true, // 找不到其它 html 文件时候会返回 index.html  很重要！！！</div><div class=\"line\">  proxy: &#123;  // webpack-dev-serve 利用 [http-proxy-middleware](https://github.com/nodejitsu/node-http-proxy) 来做的简单的 代理功能</div><div class=\"line\">    &apos;/api/*&apos;: &#123;</div><div class=\"line\">      target: API_TARGET,</div><div class=\"line\">      secure: false,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &apos;/media/*&apos;: &#123;</div><div class=\"line\">      target: API_TARGET,</div><div class=\"line\">      secure: false,</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">server.listen(7070, &apos;0.0.0.0&apos;, function (err, result) &#123;</div><div class=\"line\">  if (err) &#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">  console.log(&apos;Listening at localhost:7070/&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">module.exports = server;</div></pre></td></tr></table></figure>\n<ul>\n<li>production 部分 ( 发布时候 )</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\">var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class=\"line\">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class=\"line\"></div><div class=\"line\">const ROOT_PATH = path.resolve(__dirname);</div><div class=\"line\">const src = path.resolve(ROOT_PATH, &apos;src&apos;);</div><div class=\"line\">const dist = path.resolve(ROOT_PATH, &apos;dist&apos;);</div><div class=\"line\">const build = path.resolve(ROOT_PATH, &apos;build&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  devtool: false,</div><div class=\"line\"></div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    //配置入口文件，有几个写几个。我这里有两个文件。一个是所有我需要引入的文件，一个是我的入口文件，index.js</div><div class=\"line\">    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出,比如下面数组里面的js,全部压缩在了vendor这个文件这里</div><div class=\"line\">    vendors: [&apos;jquery&apos;],</div><div class=\"line\">    app: &apos;./src/index.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.join(__dirname, &apos;build&apos;),</div><div class=\"line\">    // publicPath: &apos;/&apos;,</div><div class=\"line\">    publicPath: &apos;/static/&apos;, //模板、样式、脚本、图片等资源对应的server上的路径</div><div class=\"line\">    filename: &apos;bundle.[hash:8].js&apos;</div><div class=\"line\">    // chunkFilename: &apos;js/[id].bundle.js&apos;   //dundle生成的配置</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">        test: /\\.js?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: [src, &apos;./mock&apos;],</div><div class=\"line\">        loader: &apos;babel&apos;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.scss$/,</div><div class=\"line\">           // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css!postcss!sass&apos;)</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css&apos;),</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./fonts/[name].[ext]&apos;</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(png|jpe?g|gif)$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./imgs/[name].[ext]&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 编译 css 的时候加上 autoprefixer</div><div class=\"line\">  postcss: config.postcss,</div><div class=\"line\"></div><div class=\"line\">  resolve: config.resolve,</div><div class=\"line\"></div><div class=\"line\">  plugins: [</div><div class=\"line\">    // 全局的环境变量</div><div class=\"line\">    new webpack.DefinePlugin(&#123;</div><div class=\"line\">      &apos;process.env&apos;: &#123;</div><div class=\"line\">        NODE_ENV: &apos;&quot;production&quot;&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new ExtractTextPlugin(&apos;./css/style.[hash:8].css&apos;),</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;</div><div class=\"line\">      $: &quot;jquery&quot;,</div><div class=\"line\">      jQuery: &quot;jquery&quot;,</div><div class=\"line\">      &quot;window.jQuery&quot;: &quot;jquery&quot;,</div><div class=\"line\">      &quot;React&quot;: &quot;react&quot;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 加入 minify 压缩选项</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      filename: &apos;./index.html&apos;,</div><div class=\"line\">      template: &apos;./src/index.html&apos;,</div><div class=\"line\">      title: &apos;Job&apos;,</div><div class=\"line\">      inject: true,</div><div class=\"line\">      hash: true,</div><div class=\"line\">      // chunks: [&apos;vendor&apos;, &apos;app&apos;], //需要引入的chunk，不配置就会引入所有页面的资源.名字来源于你的入口文件.</div><div class=\"line\">      minify: &#123;</div><div class=\"line\">        removeComments: true,  // 移除HTML中的注释</div><div class=\"line\">        collapseWhitespace: true  // 删除空白符与换行符</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 压缩 JS，删除 console.log 之类</div><div class=\"line\">    new webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">      compress: &#123;</div><div class=\"line\">        warnings: false,</div><div class=\"line\">        screw_ie8: true,</div><div class=\"line\">        drop_console: true,</div><div class=\"line\">        drop_debugger: true</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 对比id的使用频率和分布来得出最短的id分配给使用频率高的模块</div><div class=\"line\">    new webpack.optimize.OccurenceOrderPlugin(),</div><div class=\"line\">    // 找到重复文件并去重。保证了重复的代码不被大包到bundle文件里面去，取而代之的是运行时请求一个封装的函数。</div><div class=\"line\">    new webpack.optimize.DedupePlugin(),</div><div class=\"line\">    //将引入的第三方库打包.这个要放到最后</div><div class=\"line\">    // vendors 对应 entry 部分，打包相应的文件</div><div class=\"line\">    // vendors.[hash:8].js 为打包生成的文件名</div><div class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&apos;vendors&apos;, &apos;vendors.[hash:8].js&apos;),</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;lint&quot;: &quot;eslint src&quot;,</div><div class=\"line\">  &quot;cleardev&quot;: &quot;rm -rf dist/&quot;,</div><div class=\"line\">  &quot;clearb&quot;: &quot;rm -rf build/&quot;,</div><div class=\"line\">  &quot;dev&quot;: &quot;npm run cleardev&amp;&amp;webpack-dev-server --config server.js --progress --profile --colors&quot;,</div><div class=\"line\">  &quot;build&quot;: &quot;npm run clearb&amp;&amp;webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details&quot;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<blockquote><p>webpack 资料参照：</p>\n<ul>\n<li><p><a href=\"http://webpack.github.io/docs/webpack-dev-server.html\" target=\"_blank\" rel=\"external\">webpack-dev-serve官网</a></p>\n</li>\n<li><p>webpack 全套参考: <a href=\"https://github.com/vikingmute/webpack-for-fools\" target=\"_blank\" rel=\"external\">webpack 傻瓜指南</a></p>\n</li>\n<li><p>多页的参考<a href=\"https://zhuanlan.zhihu.com/p/20914387?refer=jscss\" target=\"_blank\" rel=\"external\">webpack 性能优化</a></p>\n</li>\n<li><p><a href=\"http://acgtofe.com/posts/2016/02/full-live-reload-for-express-with-webpack\" target=\"_blank\" rel=\"external\">Express结合Webpack的全栈自动刷新</a></p>\n</li>\n<li><p>参考 <a href=\"https://zhuanlan.zhihu.com/p/20914387?refer=jscss\" target=\"_blank\" rel=\"external\">webpack 性能优化</a></p>\n</li>\n</ul>\n</blockquote>\n","excerpt":"<h2 id=\"这些都是我以前记在-有道云笔记上的，搬过来～～\"><a href=\"#这些都是我以前记在-有道云笔记上的，搬过来～～\" class=\"headerlink\" title=\"这些都是我以前记在 有道云笔记上的，搬过来～～\"></a>这些都是我以前记在 <strong>有道云笔记</strong>上的，搬过来～～</h2><p>跟 webpack 抗战了很久，直到最近的一次才觉得自己入门了，终于完整的配成功了一次！！ 虽然我知道以后还是后奉献进去更多的时间，但是至少，进步了！</p>\n<p>每次配 webpack 的时候都是配到我想砸电脑。 ◡ ヽ(`Д´)ﾉ ┻━┻　 一把心酸泪啊～</p>","more":"<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><ul>\n<li>root<ul>\n<li>build                        发布目录，发布的时候打包成的文件放这里～</li>\n<li>dist                          开发目录，开发过程中打包成的文件放这里～</li>\n<li>src<ul>\n<li>mock/                   mock 设置以及一些 模拟的数据</li>\n<li>commons/            公用的 js，<ul>\n<li>utils/</li>\n<li>mock.js              superagent-mock 与 superagent 链接的地方</li>\n</ul>\n</li>\n<li>components/        react component 一般的组件</li>\n<li>styles/                  最终输出的样式文件集合</li>\n<li>imgs/</li>\n<li>fonts/</li>\n<li>pages/                  页面组件 ( container component ), 一般这里 fetch 分发给子组件</li>\n<li>index.html</li>\n<li>index.js (入口)       webpack 打包的入口文件</li>\n<li>routes.js                react-router 路由结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>记录一下现在的配置：</p>\n<h5 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">// 自动生成 html 到 dist 文件里，当然还是要有模版的。。会自动添加你要引到 html 中的文件， 可以手动，也可以自动，默认是把webpack 设置打包出去的都引入。还可以自动给文件加上 hash。</div><div class=\"line\">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class=\"line\">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class=\"line\"></div><div class=\"line\">const ROOT_PATH = path.resolve(__dirname);</div><div class=\"line\">const src = path.resolve(ROOT_PATH, &apos;src&apos;);</div><div class=\"line\">const dist = path.resolve(ROOT_PATH, &apos;dist&apos;);</div><div class=\"line\">const PORT = 7070;</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">/*</div><div class=\"line\">  现在的代码是合并以后的代码,这样出错以后就会采用source-map的形式直接显示你出错代码的位置。</div><div class=\"line\">*/</div><div class=\"line\">  devtool: &apos;eval-source-map&apos;,</div><div class=\"line\">  // 这个是和 webpack-dev-derver 结合起来用的</div><div class=\"line\">  entry: [</div><div class=\"line\">    &apos;webpack-dev-server/client?http:/localhost:&apos; + PORT,</div><div class=\"line\">    &apos;webpack/hot/only-dev-server&apos;,</div><div class=\"line\">    &apos;./src/index.js&apos;</div><div class=\"line\">  ],</div><div class=\"line\"></div><div class=\"line\">// 这个是结合 express 的用法</div><div class=\"line\">  entry: [</div><div class=\"line\">    &apos;webpack-hot-middleware/client?reload=true&apos;,</div><div class=\"line\">    &apos;./src/index.js&apos;</div><div class=\"line\">  ],</div><div class=\"line\"></div><div class=\"line\">  output: &#123;</div><div class=\"line\">    // 生成的文件放置的地方</div><div class=\"line\">    path: dist,</div><div class=\"line\">    publicPath: &apos;/static/&apos;, //模板、样式、脚本、图片等资源对应的server上的路径</div><div class=\"line\">    // 生成的主文件的名字</div><div class=\"line\">    filename: &apos;bundle.js&apos;</div><div class=\"line\">    // chunkFilename: &apos;js/[id].bundle.js&apos;   //dundle生成的配置</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  module: &#123;</div><div class=\"line\">  //先进行下检查</div><div class=\"line\">    preLoaders: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.js$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: /src/,</div><div class=\"line\">        loader: &apos;eslint&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">        test: /\\.js?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: [src, &apos;./mock&apos;],</div><div class=\"line\">        loader: &apos;react-hot!babel&apos; //react 热替换</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.scss$/,</div><div class=\"line\">           // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css?sourceMap!postcss!sass?sourceMap&apos;)</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css&apos;),</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./fonts/[name].[ext]&apos;</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(png|jpe?g|gif)$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./imgs/[name].[ext]&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 编译 css 的时候加上 autoprefixer</div><div class=\"line\">  postcss: function () &#123;</div><div class=\"line\">    return [require(&apos;autoprefixer&apos;)];</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 这里注意 第一个 参数是 &apos;&apos; ,里面没有空格</div><div class=\"line\">  resolve: &#123;</div><div class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  plugins: [</div><div class=\"line\">  // production 环境下加  hash</div><div class=\"line\"></div><div class=\"line\">    new ExtractTextPlugin(&apos;./css/style.css&apos;),</div><div class=\"line\">    // 热替换</div><div class=\"line\">    new webpack.HotModuleReplacementPlugin(),</div><div class=\"line\">     dev 时候有错误提示，但不会自动停掉 编译 /server 服务</div><div class=\"line\">    new webpack.NoErrorsPlugin(),</div><div class=\"line\">    // 全局变量，这样在用 React 的时候就不用每一个文件前面都加 import 了。</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;</div><div class=\"line\">      $: &quot;jquery&quot;,</div><div class=\"line\">      jQuery: &quot;jquery&quot;,</div><div class=\"line\">      &quot;window.jQuery&quot;: &quot;jquery&quot;,</div><div class=\"line\">      &quot;React&quot;: &quot;react&quot;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      filename: &apos;./index.html&apos;,</div><div class=\"line\">      template: &apos;./src/index.html&apos;,</div><div class=\"line\">      title: &apos;Job&apos;,</div><div class=\"line\">      inject: true,</div><div class=\"line\">      hash: true,</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"server-的配置-开发时候用\"><a href=\"#server-的配置-开发时候用\" class=\"headerlink\" title=\"server 的配置 ( 开发时候用 )\"></a>server 的配置 ( 开发时候用 )</h5><ul>\n<li>基于 express</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">// in server.js</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\"></div><div class=\"line\">var webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;);</div><div class=\"line\">var webpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;);</div><div class=\"line\"></div><div class=\"line\">const port = &apos;7070&apos;;</div><div class=\"line\">var app = new(require(&apos;express&apos;))();</div><div class=\"line\"></div><div class=\"line\">var compiler = webpack(config);</div><div class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</div><div class=\"line\">  noInfo: true,</div><div class=\"line\">  publicPath: config.output.publicPath, // 与 output.publicPath 一定要一致</div><div class=\"line\">  historyApiFallback: true,</div><div class=\"line\">  stats: &#123;</div><div class=\"line\">    colors: true,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;));</div><div class=\"line\">app.use(webpackHotMiddleware(compiler));</div><div class=\"line\"></div><div class=\"line\">app.get(&apos;/&apos;, function(req,res) &#123;</div><div class=\"line\">  console.log(&apos;get /&apos;);</div><div class=\"line\">  res.sendFile(__dirname + &apos;/dist/index.html&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.listen(port, &apos;0.0.0.0&apos;, function (err, result) &#123;</div><div class=\"line\">  if (err) &#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">  // console.log(&apos;Listening at localhost:7070/&apos;);</div><div class=\"line\">  console.info(&quot;==&gt; 🌎  Listening on port %s. Open up http://localhost:%s/ in your browser.&quot;, port, port)</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// in package.json</div><div class=\"line\">// --content-base 页面／文件的 rootPath</div><div class=\"line\">// --config 以这个 js 文件作为配置文件</div><div class=\"line\"></div><div class=\"line\">    &quot;dev&quot;: &quot;webpack-dev-server --content-base=/dist --config server.js --progress --profile --colors&quot;,</div><div class=\"line\"></div><div class=\"line\">    &quot;build&quot;: &quot;rm -rf ./dist/* &amp;&amp; webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details&quot;,</div></pre></td></tr></table></figure>\n<ul>\n<li>dev-serve版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">// webpack-dev-serve 是一个小型的用 Express 搭建成的 serve.</div><div class=\"line\">// 用 webpack-dev-middleware 来 serve webpack bundle 的。（ webpack-dev-middleware 是一个简单的包装webpack的中间件，可以 watch 我们需要打包的文件，每次更新，打包成新的 bundle 都会通过它发出给serve。它将文件都放在内存里，而不是磁盘中。</div><div class=\"line\"></div><div class=\"line\"> // in serve.js</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var WebpackDevServer = require(&apos;webpack-dev-server&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\"></div><div class=\"line\">var compiler = webpack(config);</div><div class=\"line\">const API_TARGET = &quot;http://wuguishifu.com&quot;;</div><div class=\"line\"></div><div class=\"line\">var server = new WebpackDevServer(compiler, &#123;</div><div class=\"line\">  publicPath: config.output.publicPath,</div><div class=\"line\">   // Can also be an array, or: contentBase: &quot;http://localhost/&quot;,</div><div class=\"line\">  contentBase: &apos;./dist&apos;,</div><div class=\"line\">  inline: true,</div><div class=\"line\">  noInfo: false,</div><div class=\"line\">  stats: &#123; colors: true &#125;,</div><div class=\"line\">  historyApiFallback: true, // 找不到其它 html 文件时候会返回 index.html  很重要！！！</div><div class=\"line\">  proxy: &#123;  // webpack-dev-serve 利用 [http-proxy-middleware](https://github.com/nodejitsu/node-http-proxy) 来做的简单的 代理功能</div><div class=\"line\">    &apos;/api/*&apos;: &#123;</div><div class=\"line\">      target: API_TARGET,</div><div class=\"line\">      secure: false,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &apos;/media/*&apos;: &#123;</div><div class=\"line\">      target: API_TARGET,</div><div class=\"line\">      secure: false,</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">server.listen(7070, &apos;0.0.0.0&apos;, function (err, result) &#123;</div><div class=\"line\">  if (err) &#123;</div><div class=\"line\">    console.log(err);</div><div class=\"line\">  &#125;</div><div class=\"line\">  console.log(&apos;Listening at localhost:7070/&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">module.exports = server;</div></pre></td></tr></table></figure>\n<ul>\n<li>production 部分 ( 发布时候 )</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var config = require(&apos;./webpack.config.js&apos;);</div><div class=\"line\">var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class=\"line\">var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class=\"line\"></div><div class=\"line\">const ROOT_PATH = path.resolve(__dirname);</div><div class=\"line\">const src = path.resolve(ROOT_PATH, &apos;src&apos;);</div><div class=\"line\">const dist = path.resolve(ROOT_PATH, &apos;dist&apos;);</div><div class=\"line\">const build = path.resolve(ROOT_PATH, &apos;build&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  devtool: false,</div><div class=\"line\"></div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    //配置入口文件，有几个写几个。我这里有两个文件。一个是所有我需要引入的文件，一个是我的入口文件，index.js</div><div class=\"line\">    //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出,比如下面数组里面的js,全部压缩在了vendor这个文件这里</div><div class=\"line\">    vendors: [&apos;jquery&apos;],</div><div class=\"line\">    app: &apos;./src/index.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.join(__dirname, &apos;build&apos;),</div><div class=\"line\">    // publicPath: &apos;/&apos;,</div><div class=\"line\">    publicPath: &apos;/static/&apos;, //模板、样式、脚本、图片等资源对应的server上的路径</div><div class=\"line\">    filename: &apos;bundle.[hash:8].js&apos;</div><div class=\"line\">    // chunkFilename: &apos;js/[id].bundle.js&apos;   //dundle生成的配置</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">        test: /\\.js?$/,</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\">        include: [src, &apos;./mock&apos;],</div><div class=\"line\">        loader: &apos;babel&apos;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.scss$/,</div><div class=\"line\">           // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css!postcss!sass&apos;)</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        // 将 css 单独打包出来</div><div class=\"line\">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css&apos;),</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(woff|woff2|ttf|eot|svg)\\??.*$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./fonts/[name].[ext]&apos;</div><div class=\"line\">      &#125;, &#123;</div><div class=\"line\">        test: /\\.(png|jpe?g|gif)$/,</div><div class=\"line\">        loader: &apos;url-loader?limit=8192&amp;name=./imgs/[name].[ext]&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  // 编译 css 的时候加上 autoprefixer</div><div class=\"line\">  postcss: config.postcss,</div><div class=\"line\"></div><div class=\"line\">  resolve: config.resolve,</div><div class=\"line\"></div><div class=\"line\">  plugins: [</div><div class=\"line\">    // 全局的环境变量</div><div class=\"line\">    new webpack.DefinePlugin(&#123;</div><div class=\"line\">      &apos;process.env&apos;: &#123;</div><div class=\"line\">        NODE_ENV: &apos;&quot;production&quot;&apos;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new ExtractTextPlugin(&apos;./css/style.[hash:8].css&apos;),</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;</div><div class=\"line\">      $: &quot;jquery&quot;,</div><div class=\"line\">      jQuery: &quot;jquery&quot;,</div><div class=\"line\">      &quot;window.jQuery&quot;: &quot;jquery&quot;,</div><div class=\"line\">      &quot;React&quot;: &quot;react&quot;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 加入 minify 压缩选项</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      filename: &apos;./index.html&apos;,</div><div class=\"line\">      template: &apos;./src/index.html&apos;,</div><div class=\"line\">      title: &apos;Job&apos;,</div><div class=\"line\">      inject: true,</div><div class=\"line\">      hash: true,</div><div class=\"line\">      // chunks: [&apos;vendor&apos;, &apos;app&apos;], //需要引入的chunk，不配置就会引入所有页面的资源.名字来源于你的入口文件.</div><div class=\"line\">      minify: &#123;</div><div class=\"line\">        removeComments: true,  // 移除HTML中的注释</div><div class=\"line\">        collapseWhitespace: true  // 删除空白符与换行符</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 压缩 JS，删除 console.log 之类</div><div class=\"line\">    new webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">      compress: &#123;</div><div class=\"line\">        warnings: false,</div><div class=\"line\">        screw_ie8: true,</div><div class=\"line\">        drop_console: true,</div><div class=\"line\">        drop_debugger: true</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    // 对比id的使用频率和分布来得出最短的id分配给使用频率高的模块</div><div class=\"line\">    new webpack.optimize.OccurenceOrderPlugin(),</div><div class=\"line\">    // 找到重复文件并去重。保证了重复的代码不被大包到bundle文件里面去，取而代之的是运行时请求一个封装的函数。</div><div class=\"line\">    new webpack.optimize.DedupePlugin(),</div><div class=\"line\">    //将引入的第三方库打包.这个要放到最后</div><div class=\"line\">    // vendors 对应 entry 部分，打包相应的文件</div><div class=\"line\">    // vendors.[hash:8].js 为打包生成的文件名</div><div class=\"line\">    new webpack.optimize.CommonsChunkPlugin(&apos;vendors&apos;, &apos;vendors.[hash:8].js&apos;),</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h5 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;lint&quot;: &quot;eslint src&quot;,</div><div class=\"line\">  &quot;cleardev&quot;: &quot;rm -rf dist/&quot;,</div><div class=\"line\">  &quot;clearb&quot;: &quot;rm -rf build/&quot;,</div><div class=\"line\">  &quot;dev&quot;: &quot;npm run cleardev&amp;&amp;webpack-dev-server --config server.js --progress --profile --colors&quot;,</div><div class=\"line\">  &quot;build&quot;: &quot;npm run clearb&amp;&amp;webpack --config webpack.prod.config.js --progress --profile --colors --display-error-details&quot;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<blockquote><p>webpack 资料参照：</p>\n<ul>\n<li><p><a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">webpack-dev-serve官网</a></p>\n</li>\n<li><p>webpack 全套参考: <a href=\"https://github.com/vikingmute/webpack-for-fools\">webpack 傻瓜指南</a></p>\n</li>\n<li><p>多页的参考<a href=\"https://zhuanlan.zhihu.com/p/20914387?refer=jscss\">webpack 性能优化</a></p>\n</li>\n<li><p><a href=\"http://acgtofe.com/posts/2016/02/full-live-reload-for-express-with-webpack\">Express结合Webpack的全栈自动刷新</a></p>\n</li>\n<li><p>参考 <a href=\"https://zhuanlan.zhihu.com/p/20914387?refer=jscss\">webpack 性能优化</a></p>\n</li>\n</ul>\n</blockquote>"},{"title":"数组","_content":"### 特征:\n\n  - 有序列表\n  - __每一项__ 都可以保存 __任意类型__ 的值\n  - 大小可以动态调整\n\n### 创建方式\n\n  - 构造函数 ( __也可以省略掉 new __ )\n\n```\nvar colors = new Array(); \n\n// 如果预先知道元素数量\nvar colors = new Array(20);\n\n// 如果预先知道要包含的项\nvar colors = new Array(\"red\", \"blue\", \"green\" );\n\n// 如上两个所示，给构造函数传入 number 类型参数 --> length 为 number 的数组\n// 给构造函数传入 其他类型参数 --> 创建包含那个值的只有一项的数组\n```\n<!-- more -->\n\n  - 数组字面量\n\n数组字面量由一对包含数组项的方括号表示，多个数组项以逗号隔开\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];\n\nvar values = [1,2,]; //  会创建一个包含 2  或 3 项的数组\n```\n\n### 访问\n\n- 使用 __方括号__, 并提供 相应值的基于 0 的数字的索引\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];\nalert( colors[0] ); // 显示第一项\n```\n\n### 设置\n\n设置数组的值与访问语法相同，但会替换指定位置的值。\n\n如果设置某个值的索引超过数组现有的项数，则会自动增加到该 __索引值 + 1_  的长度\n\n### length\n\n- 数组的项数保存在其 __length__ 的属性中\n- length > = 0\n- 可以通过改变 length 的值，向数组添加 ( 新增的每一项都为 undefined ) 或者减少 ( 减少的那几项是 undefined ) 项\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];    \ncolors[99] = \"black\";                            // 在位置 99 添加一种颜色\n\nalert( colors.length );    //100\nalert( colors[0] ); // 显示第一项\n```\n上例 3 到 98 实际上是 __不存在的__ , 所以访问它们都将返回 __undefined__\n\n### 检测数组 Array.isArray()\n\n### 转化方法 \n\n- __所有的对象__ 都具有 __toLocaleString()__, __toString()__, __valueOf()__ 方法\n\n  + toString() 返回由数组中每个值的字符串形式拼接而成的一个 __以逗号分隔的字符串__。 它会为取得每一项，调用每一项的 __toString()__ 。\n\n  + __valueOf()__ 返回 __数组__\n\n  + __toLocaleString()__  它也会创建一个数组值的以逗号分隔的__字符串__。 不同的是， 它会为取得每一项，调用每一项的 __toLocaleString()__ 。 而不是 __toString()__\n\nNOTE: alert() 会在后台调用 toString() 方法\n\n- 使用 join()\n  \n  + 可以使用不同的分隔符来构建这个字符串。\n  \n  + 一个参数，作为分隔符的 __字符串__\n  \n  + 如果不给 join() 传参数 ／ 传入 undefined 则使用 \"__,__\" 作为分隔符。 \n\n```\nvar colors = [\"red\", \"blue\", \"green\"];    \nconsole.log( colors.join(\"-\") ); // red-blue-green\n```\n\n###方法\n\n#### 栈方法\n\n栈是一种 __后进先出__ 的数据结构。\n在栈中项的插入 ( 叫做__推入 push__ ), 移除( 叫做 __弹出 pop__ ), 只发生在一个位置 --- __栈的顶部__\n\nECMAScript 为数组专门提供了 __push()__ 和 __pop()__ 方法，以便实现类似 栈 的行为。\n\n- push()\n\n  + 接收任意数量的参数，\n  + 将它们 逐个添加到 数组末尾，\n  + _返回修改后数组的__长度__。_\n\n- pop()\n\n  + 从数组的末尾 __移除最后一项__，\n  + 减少数组的 __length__ 值，\n  + 然后返回 __移除的项__\n\n```\n\nconst colors = new Array();\nconst count = colors.push(\"red\", \"green\");\n\nconsole.log(count); // 2\nconsole.log(colors ); // [\"red\", \"green\"]\n\nvar item = colors.pop();\nconsole.log( item ); // \"green\"\nconsole.log(colors); // [\"red\"]\n```\n#### 队列方法\n\n队列数据结构的访问规则是 __先进先出__\n\n队列在列表的 __末端添加项__，\n从列表的__前端移除项__\n\n- push()  与上面相同\n\n- shift() \n \n  + 从数组的前端 __取得项__\n  + 移除数组的第一个项\n  + 返回移除的那个项\n  + 同时长度 - 1\n\n```\nconst colors = new Array();\nconst count = colors.push(\"red\", \"green\");\n\nconsole.log(count);  // 2\nconsole.log(colors ); // [\"red\", \"green\"]\n\ncolors.push(\"black\");  // 3\n\nvar item = colors.shift();\nconsole.log( item );  // red\nconsole.log(colors);   [\"green\", \"black\"]\nconsole.log(colors.length); // 2\n```\n\n- unshift()\n\n  + unshift() 与 shift() 用途相反，\n  + 在数组的前端添加任意个项\n  + 返回新的数组的 __长度__\n\n\nunshift() 和 pop() 可以实现相反方向的队列\n- 在数组前端添加项\n- 在数组末端删除项\n\n```\nconst colors = new Array();\nconst count = colors.unshift(\"red\", \"green\");\n\nconsole.log(colors); // [\"red\", \"green\"]\nconsole.log(count); // 2\n\ncolors.unshift(\"black\");\n\nconsole.log(colors); // [\"black\", \"red\", \"green\"]\n\nvar item = colors.pop();\n\nconsole.log( item ); // \"green\"\nconsole.log(colors); // [\"black\", \"red\"]\nconsole.log(colors.length);\n```\nunshift() 和 shift() 可以实现相反方向的栈\n\n#### 重排序方法\n\n- sort()\n  \n  + 默认情况下， sort()  按__升序__排列数组\n  + 会 先调用每个数组项的 __toString()__ 转型方法 --> 得到字符串\n  + !!!!!  然后 比较__得到的字符串__\n  \n\n  + sort() 方法可以接收一个 __比较函数__ 作为参数，以便指定 哪个值 位于 哪个值 的前面。\n  \n  + 比较函数：\n\n    - 接收 __两个参数__\n    - 返回一个负数 ------- 第一个参数 在 第二个参数之前\n    - 返回一个正数 ------- 第一个参数 在 第二个参数之后\n\n如下：\n\n只要将比较函数作为参数传给 sort() 方法即可。\n\nNOTE:  __reverse() 不可以将 比较函数当 参数__\n```\nfunction compare(v1, v2) {\n  if( v1 < v2 ) {\n    return -1;\n  } else if( v1 > v2 ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst arrb = [1,23,4,6,76,1,1,535,2];\n\nconsole.log( arrb.sort(compare) ); // [1, 1, 1, 2, 4, 6, 23, 76, 535]\n```\n上面的 compare() 函数适用于大多数数据类型，\n\n对于__数值类型__ 或者其 __valueOf()__ 返回 __数值类型 __的对象类型，可以使用一个比较简单的函数\n\n```\nfunction compare(v1, v2 ) {\n  return v1 - v2;\n}\n```\n\n\n- reverse()   反转数据项的顺序\n\n```\nconst arrb = [1,23,4,6,76,1,1,535,2];\nconsole.log( arrb.reverse() ); // [2, 535, 1, 1, 76, 6, 4, 23, 1]\n```\n\n#### 操作方法\n\n- concat()  ------ 不改变原数组\n\n  + 创建当前数组的一个 __副本__\n  + 将接收到的参数 __添加__到这个副本的末尾\n  + 返回 __新构建的数组__\n  + __不会影响 原数组__\n\n  + 如果传递的不是数组，这些值就会被简单的添加到结果数组的末尾\n  + 如果没有传递参数，它只是 __复制__ 当前的数组并返回副本\n  \n```\nconst arrb = [1,23,4,6,76,1,1,535,2];\n\nlet arrc =  arrb.concat('a', 'b');\n\nconsole.log(arrc);  // [1, 23, 4, 6, 76, 1, 1, 535, 2, \"a\", \"b\"]\n\nlet arrd = arrb.concat('y', ['s', '2']); \n\nconsole.log(arrd); // [1, 23, 4, 6, 76, 1, 1, 535, 2, \"y\", \"s\", \"2\"]\n\nconsole.log(arrb); // [1, 23, 4, 6, 76, 1, 1, 535, 2]\n\n- slice()  ------ 不改变原数组\n\n  + 能够基于 当前数组中的一个或者多个项 __创建一个新数组__，\n\n  + 参数： 接受一个或者两个参数 (  返回项的 __起始位置__和__结束位置__ )\n    \n    - 一个参数： 返回 从该参数指定位置到当前数组末尾的所有项\n    \n    - 两个参数： 返回起始位置到结束位置(  _不包括结束位置_) 的所有项\n\n    - 如果参数有 __负值__，则用 _数组长度加上该数_来确定相应的位置。\n\n```\nconst arrb = [1,23,4,11,'a', 'b', 'v', 535,2];\n\nlet arrc =  arrb.slice(5);\n\nconsole.log(arrc);  // [\"b\", \"v\", 535, 2]\n\nlet arrd = arrb.slice(0,6);\n\nconsole.log(arrd); // [1, 23, 4, 11, \"a\", \"b\"]\n\nlet arre = arrb.slice(-5,6);\n\nconsole.log(arrb.length); // 9\n\nconsole.log(arre); // [\"a\", \"b\"]\n\n```\n\n#### splice() \n\n有很多种用法\n\n- 主要方式： 向数组的中部插入项\n\n使用主要这种方式的有 3 种：\n\n- 删除\n\n可以删除任意数量的项，需指定 2 个参数： 要删除第一项的位置 和 要删除的项数。\n\n- 插入\n\n可以向 __指定位置__ 插入任意数量的项。需指定 __至少 3 个参数__： 起始位置， 0 ( 要删除的项数 )，要插入的项 ( 可多个 )\n\n- 替换\n\n可以向指定位置插入任意数量的项，且同时删除任意数量的项。 需指定 3 个参数：起始位置，要删除的项的数目，要插入的任意数量的项 ( _插入的项数不必与删除的项数相等_)\n\n- 返回\n\nsplice()  始终都返回一个数组，该数组包含着从原始数组中删除的项\n\n```\nconst arrb = [1,23,4,11,'a', 'b', 'v', 535,2];\n\n// 删除\nlet arrc =  arrb.splice(0,1);\nconsole.log(arrc); //  [1]\nconsole.log(arrb); // [ 23,4,11,'a', 'b', 'v', 535,2 ]\n\n// 插入\nlet arrd = arrb.splice(1, 0, 'hello','hi');\n\nconsole.log(arrd); // [ 23, 'hello', 'hi',4,11,'a', 'b', 'v', 535,2 ]\nconsole.log(arrb); // []\n\n// 替换\nlet arre = arrb.splice(3, 2, 'one', 'two');\nconsole.log(arrb); // [ 23, 'hello', 'hi', 'one', 'two','a', 'b', 'v', 535,2 ]\nconsole.log(arre); // [4, 11]\n\n```\n#### 位置方法\n\n- indexOf()\n  从数组的开头开始向后查找\n\n- lastIndexOf()\n  从数组的末尾向前查找\n\n- 这两个参数都接收 2 个参数： 要查找的项， 查找起点位置的索引 ( 可选 )\n \n- 返回 要查找的项在数组的位置，或者没找到返回 -1\n- 在比较第一个参数和数组中的每一项时，__使用全等__\n\n```\nconst arrb = [10  ,23,4,11,666, 'b', 'v', a1,2];\n\nconsole.log(arrb.indexOf(666) ); // 7\n```\n#### 迭代方法 ----- 不修改原数组\n\n- every()  对数组中的 __每一项__运行指定函数，如果该函数 __每一项都返回 true__ ,  则返回 _true_, __ 当一项不满足则返回 false， 不再运行下面的项__\n\n返回 true / false\n\n- filter() 对数组中的 __每一项__运行指定函数，返回该函数会返回 _true_ 的项组成的数组\n\n返回 数组\n\n- forEach() 对数组中的 __每一项__运行指定函数 __无返回值__( 只能返回 undefined )\n\n返回 undefined ( 无返回值 )\n\n- map() 对数组中的 __每一项__运行指定函数，返回每次函数调用的__结果组成的数组__\n\n返回 数组\n\n- some() 对数组中的 __每一项__运行指定函数，如果该函数中的__任一项__会返回 true, 则返回 true\n\n返回 true / false\n\n```\nlet numbers = [1,5,67,8,3,1,7];\n\nlet everyResult = numbers.every((item, idx, array) => {\n  console.log(item);\n  return item > 6;\n})\n\nconsole.log(everyResult ); // false\n\nlet filterResult = numbers.filter((item, idx, array)=>{\n  let rest = array.slice(0, array.indexOf(item)).concat(array.slice(array.indexOf(item)+1,array.length ));\n  return rest.indexOf(item) >= 0 ? true: false  ;\n})\n\nconsole.log(filterResult); // [1, 1]\n\nlet forEachResult = [];\nnumbers.forEach((item, idx, array) => {\n  forEachResult[idx] = item -1 ;\n})\n\nconsole.log(forEachResult); // [0, 4, 66, 7, 2, 0, 6]\n\nlet mapResult = numbers.map((item,idx,array)=> {\n  return item-1;\n})\nconsole.log(mapResult); // [0, 4, 66, 7, 2, 0, 6]\n\nlet someResult = numbers.some((item, idx, array)=>{\n  return item > array[idx-1];\n})\nconsole.log(someResult); // true\n```\n\n#### 归并方法\n\n- reduce()\n- reduceRight()\n\n- 迭代所有项\n- 构建一个最终返回的值\n\n参数\n- 每一项上调用的 函数 \n  \n  + 这个函数接收 4 个参数: 前一个值， 当前值， 项的索引， 数组对象\n  \n  + 这个函数 __返回的任何值__都会作为 __第一个参数__自动传给 __下一项__\n\n- 初始值 ( 可选 )\n\n```\nlet numbers = [1,5,67,8,3,1,7];\n\nlet reduceResult = numbers.reduce((pre, cur, idx, array) => {\n  let item = idx > 0 ? cur + pre[idx-1] : cur;  // 每一项和已经得到的之前的一项相加\n  pre.push(item);\n  return pre;\n}, []);\n\nconsole.log( reduceResult );  // [1, 6, 73, 81, 84, 85, 92]\n```\n{% blockquote %}\n参考：\n\n_JavaScript 高级程序设计_\n{% endblockquote %}\n\n\n","source":"_posts/array.md","raw":"---\ntitle: 数组\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- 数组\n- JS 基础\n---\n### 特征:\n\n  - 有序列表\n  - __每一项__ 都可以保存 __任意类型__ 的值\n  - 大小可以动态调整\n\n### 创建方式\n\n  - 构造函数 ( __也可以省略掉 new __ )\n\n```\nvar colors = new Array(); \n\n// 如果预先知道元素数量\nvar colors = new Array(20);\n\n// 如果预先知道要包含的项\nvar colors = new Array(\"red\", \"blue\", \"green\" );\n\n// 如上两个所示，给构造函数传入 number 类型参数 --> length 为 number 的数组\n// 给构造函数传入 其他类型参数 --> 创建包含那个值的只有一项的数组\n```\n<!-- more -->\n\n  - 数组字面量\n\n数组字面量由一对包含数组项的方括号表示，多个数组项以逗号隔开\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];\n\nvar values = [1,2,]; //  会创建一个包含 2  或 3 项的数组\n```\n\n### 访问\n\n- 使用 __方括号__, 并提供 相应值的基于 0 的数字的索引\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];\nalert( colors[0] ); // 显示第一项\n```\n\n### 设置\n\n设置数组的值与访问语法相同，但会替换指定位置的值。\n\n如果设置某个值的索引超过数组现有的项数，则会自动增加到该 __索引值 + 1_  的长度\n\n### length\n\n- 数组的项数保存在其 __length__ 的属性中\n- length > = 0\n- 可以通过改变 length 的值，向数组添加 ( 新增的每一项都为 undefined ) 或者减少 ( 减少的那几项是 undefined ) 项\n\n```\nvar colors = [\"red\", \"blue\", \"green\"];    \ncolors[99] = \"black\";                            // 在位置 99 添加一种颜色\n\nalert( colors.length );    //100\nalert( colors[0] ); // 显示第一项\n```\n上例 3 到 98 实际上是 __不存在的__ , 所以访问它们都将返回 __undefined__\n\n### 检测数组 Array.isArray()\n\n### 转化方法 \n\n- __所有的对象__ 都具有 __toLocaleString()__, __toString()__, __valueOf()__ 方法\n\n  + toString() 返回由数组中每个值的字符串形式拼接而成的一个 __以逗号分隔的字符串__。 它会为取得每一项，调用每一项的 __toString()__ 。\n\n  + __valueOf()__ 返回 __数组__\n\n  + __toLocaleString()__  它也会创建一个数组值的以逗号分隔的__字符串__。 不同的是， 它会为取得每一项，调用每一项的 __toLocaleString()__ 。 而不是 __toString()__\n\nNOTE: alert() 会在后台调用 toString() 方法\n\n- 使用 join()\n  \n  + 可以使用不同的分隔符来构建这个字符串。\n  \n  + 一个参数，作为分隔符的 __字符串__\n  \n  + 如果不给 join() 传参数 ／ 传入 undefined 则使用 \"__,__\" 作为分隔符。 \n\n```\nvar colors = [\"red\", \"blue\", \"green\"];    \nconsole.log( colors.join(\"-\") ); // red-blue-green\n```\n\n###方法\n\n#### 栈方法\n\n栈是一种 __后进先出__ 的数据结构。\n在栈中项的插入 ( 叫做__推入 push__ ), 移除( 叫做 __弹出 pop__ ), 只发生在一个位置 --- __栈的顶部__\n\nECMAScript 为数组专门提供了 __push()__ 和 __pop()__ 方法，以便实现类似 栈 的行为。\n\n- push()\n\n  + 接收任意数量的参数，\n  + 将它们 逐个添加到 数组末尾，\n  + _返回修改后数组的__长度__。_\n\n- pop()\n\n  + 从数组的末尾 __移除最后一项__，\n  + 减少数组的 __length__ 值，\n  + 然后返回 __移除的项__\n\n```\n\nconst colors = new Array();\nconst count = colors.push(\"red\", \"green\");\n\nconsole.log(count); // 2\nconsole.log(colors ); // [\"red\", \"green\"]\n\nvar item = colors.pop();\nconsole.log( item ); // \"green\"\nconsole.log(colors); // [\"red\"]\n```\n#### 队列方法\n\n队列数据结构的访问规则是 __先进先出__\n\n队列在列表的 __末端添加项__，\n从列表的__前端移除项__\n\n- push()  与上面相同\n\n- shift() \n \n  + 从数组的前端 __取得项__\n  + 移除数组的第一个项\n  + 返回移除的那个项\n  + 同时长度 - 1\n\n```\nconst colors = new Array();\nconst count = colors.push(\"red\", \"green\");\n\nconsole.log(count);  // 2\nconsole.log(colors ); // [\"red\", \"green\"]\n\ncolors.push(\"black\");  // 3\n\nvar item = colors.shift();\nconsole.log( item );  // red\nconsole.log(colors);   [\"green\", \"black\"]\nconsole.log(colors.length); // 2\n```\n\n- unshift()\n\n  + unshift() 与 shift() 用途相反，\n  + 在数组的前端添加任意个项\n  + 返回新的数组的 __长度__\n\n\nunshift() 和 pop() 可以实现相反方向的队列\n- 在数组前端添加项\n- 在数组末端删除项\n\n```\nconst colors = new Array();\nconst count = colors.unshift(\"red\", \"green\");\n\nconsole.log(colors); // [\"red\", \"green\"]\nconsole.log(count); // 2\n\ncolors.unshift(\"black\");\n\nconsole.log(colors); // [\"black\", \"red\", \"green\"]\n\nvar item = colors.pop();\n\nconsole.log( item ); // \"green\"\nconsole.log(colors); // [\"black\", \"red\"]\nconsole.log(colors.length);\n```\nunshift() 和 shift() 可以实现相反方向的栈\n\n#### 重排序方法\n\n- sort()\n  \n  + 默认情况下， sort()  按__升序__排列数组\n  + 会 先调用每个数组项的 __toString()__ 转型方法 --> 得到字符串\n  + !!!!!  然后 比较__得到的字符串__\n  \n\n  + sort() 方法可以接收一个 __比较函数__ 作为参数，以便指定 哪个值 位于 哪个值 的前面。\n  \n  + 比较函数：\n\n    - 接收 __两个参数__\n    - 返回一个负数 ------- 第一个参数 在 第二个参数之前\n    - 返回一个正数 ------- 第一个参数 在 第二个参数之后\n\n如下：\n\n只要将比较函数作为参数传给 sort() 方法即可。\n\nNOTE:  __reverse() 不可以将 比较函数当 参数__\n```\nfunction compare(v1, v2) {\n  if( v1 < v2 ) {\n    return -1;\n  } else if( v1 > v2 ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst arrb = [1,23,4,6,76,1,1,535,2];\n\nconsole.log( arrb.sort(compare) ); // [1, 1, 1, 2, 4, 6, 23, 76, 535]\n```\n上面的 compare() 函数适用于大多数数据类型，\n\n对于__数值类型__ 或者其 __valueOf()__ 返回 __数值类型 __的对象类型，可以使用一个比较简单的函数\n\n```\nfunction compare(v1, v2 ) {\n  return v1 - v2;\n}\n```\n\n\n- reverse()   反转数据项的顺序\n\n```\nconst arrb = [1,23,4,6,76,1,1,535,2];\nconsole.log( arrb.reverse() ); // [2, 535, 1, 1, 76, 6, 4, 23, 1]\n```\n\n#### 操作方法\n\n- concat()  ------ 不改变原数组\n\n  + 创建当前数组的一个 __副本__\n  + 将接收到的参数 __添加__到这个副本的末尾\n  + 返回 __新构建的数组__\n  + __不会影响 原数组__\n\n  + 如果传递的不是数组，这些值就会被简单的添加到结果数组的末尾\n  + 如果没有传递参数，它只是 __复制__ 当前的数组并返回副本\n  \n```\nconst arrb = [1,23,4,6,76,1,1,535,2];\n\nlet arrc =  arrb.concat('a', 'b');\n\nconsole.log(arrc);  // [1, 23, 4, 6, 76, 1, 1, 535, 2, \"a\", \"b\"]\n\nlet arrd = arrb.concat('y', ['s', '2']); \n\nconsole.log(arrd); // [1, 23, 4, 6, 76, 1, 1, 535, 2, \"y\", \"s\", \"2\"]\n\nconsole.log(arrb); // [1, 23, 4, 6, 76, 1, 1, 535, 2]\n\n- slice()  ------ 不改变原数组\n\n  + 能够基于 当前数组中的一个或者多个项 __创建一个新数组__，\n\n  + 参数： 接受一个或者两个参数 (  返回项的 __起始位置__和__结束位置__ )\n    \n    - 一个参数： 返回 从该参数指定位置到当前数组末尾的所有项\n    \n    - 两个参数： 返回起始位置到结束位置(  _不包括结束位置_) 的所有项\n\n    - 如果参数有 __负值__，则用 _数组长度加上该数_来确定相应的位置。\n\n```\nconst arrb = [1,23,4,11,'a', 'b', 'v', 535,2];\n\nlet arrc =  arrb.slice(5);\n\nconsole.log(arrc);  // [\"b\", \"v\", 535, 2]\n\nlet arrd = arrb.slice(0,6);\n\nconsole.log(arrd); // [1, 23, 4, 11, \"a\", \"b\"]\n\nlet arre = arrb.slice(-5,6);\n\nconsole.log(arrb.length); // 9\n\nconsole.log(arre); // [\"a\", \"b\"]\n\n```\n\n#### splice() \n\n有很多种用法\n\n- 主要方式： 向数组的中部插入项\n\n使用主要这种方式的有 3 种：\n\n- 删除\n\n可以删除任意数量的项，需指定 2 个参数： 要删除第一项的位置 和 要删除的项数。\n\n- 插入\n\n可以向 __指定位置__ 插入任意数量的项。需指定 __至少 3 个参数__： 起始位置， 0 ( 要删除的项数 )，要插入的项 ( 可多个 )\n\n- 替换\n\n可以向指定位置插入任意数量的项，且同时删除任意数量的项。 需指定 3 个参数：起始位置，要删除的项的数目，要插入的任意数量的项 ( _插入的项数不必与删除的项数相等_)\n\n- 返回\n\nsplice()  始终都返回一个数组，该数组包含着从原始数组中删除的项\n\n```\nconst arrb = [1,23,4,11,'a', 'b', 'v', 535,2];\n\n// 删除\nlet arrc =  arrb.splice(0,1);\nconsole.log(arrc); //  [1]\nconsole.log(arrb); // [ 23,4,11,'a', 'b', 'v', 535,2 ]\n\n// 插入\nlet arrd = arrb.splice(1, 0, 'hello','hi');\n\nconsole.log(arrd); // [ 23, 'hello', 'hi',4,11,'a', 'b', 'v', 535,2 ]\nconsole.log(arrb); // []\n\n// 替换\nlet arre = arrb.splice(3, 2, 'one', 'two');\nconsole.log(arrb); // [ 23, 'hello', 'hi', 'one', 'two','a', 'b', 'v', 535,2 ]\nconsole.log(arre); // [4, 11]\n\n```\n#### 位置方法\n\n- indexOf()\n  从数组的开头开始向后查找\n\n- lastIndexOf()\n  从数组的末尾向前查找\n\n- 这两个参数都接收 2 个参数： 要查找的项， 查找起点位置的索引 ( 可选 )\n \n- 返回 要查找的项在数组的位置，或者没找到返回 -1\n- 在比较第一个参数和数组中的每一项时，__使用全等__\n\n```\nconst arrb = [10  ,23,4,11,666, 'b', 'v', a1,2];\n\nconsole.log(arrb.indexOf(666) ); // 7\n```\n#### 迭代方法 ----- 不修改原数组\n\n- every()  对数组中的 __每一项__运行指定函数，如果该函数 __每一项都返回 true__ ,  则返回 _true_, __ 当一项不满足则返回 false， 不再运行下面的项__\n\n返回 true / false\n\n- filter() 对数组中的 __每一项__运行指定函数，返回该函数会返回 _true_ 的项组成的数组\n\n返回 数组\n\n- forEach() 对数组中的 __每一项__运行指定函数 __无返回值__( 只能返回 undefined )\n\n返回 undefined ( 无返回值 )\n\n- map() 对数组中的 __每一项__运行指定函数，返回每次函数调用的__结果组成的数组__\n\n返回 数组\n\n- some() 对数组中的 __每一项__运行指定函数，如果该函数中的__任一项__会返回 true, 则返回 true\n\n返回 true / false\n\n```\nlet numbers = [1,5,67,8,3,1,7];\n\nlet everyResult = numbers.every((item, idx, array) => {\n  console.log(item);\n  return item > 6;\n})\n\nconsole.log(everyResult ); // false\n\nlet filterResult = numbers.filter((item, idx, array)=>{\n  let rest = array.slice(0, array.indexOf(item)).concat(array.slice(array.indexOf(item)+1,array.length ));\n  return rest.indexOf(item) >= 0 ? true: false  ;\n})\n\nconsole.log(filterResult); // [1, 1]\n\nlet forEachResult = [];\nnumbers.forEach((item, idx, array) => {\n  forEachResult[idx] = item -1 ;\n})\n\nconsole.log(forEachResult); // [0, 4, 66, 7, 2, 0, 6]\n\nlet mapResult = numbers.map((item,idx,array)=> {\n  return item-1;\n})\nconsole.log(mapResult); // [0, 4, 66, 7, 2, 0, 6]\n\nlet someResult = numbers.some((item, idx, array)=>{\n  return item > array[idx-1];\n})\nconsole.log(someResult); // true\n```\n\n#### 归并方法\n\n- reduce()\n- reduceRight()\n\n- 迭代所有项\n- 构建一个最终返回的值\n\n参数\n- 每一项上调用的 函数 \n  \n  + 这个函数接收 4 个参数: 前一个值， 当前值， 项的索引， 数组对象\n  \n  + 这个函数 __返回的任何值__都会作为 __第一个参数__自动传给 __下一项__\n\n- 初始值 ( 可选 )\n\n```\nlet numbers = [1,5,67,8,3,1,7];\n\nlet reduceResult = numbers.reduce((pre, cur, idx, array) => {\n  let item = idx > 0 ? cur + pre[idx-1] : cur;  // 每一项和已经得到的之前的一项相加\n  pre.push(item);\n  return pre;\n}, []);\n\nconsole.log( reduceResult );  // [1, 6, 73, 81, 84, 85, 92]\n```\n{% blockquote %}\n参考：\n\n_JavaScript 高级程序设计_\n{% endblockquote %}\n\n\n","slug":"array","published":1,"date":"2016-12-14T16:41:21.000Z","updated":"2016-12-15T05:40:52.000Z","_id":"ciwpwkc9e0000p4ra4techqkj","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征:\"></a>特征:</h3><ul>\n<li>有序列表</li>\n<li><strong>每一项</strong> 都可以保存 <strong>任意类型</strong> 的值</li>\n<li>大小可以动态调整</li>\n</ul>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><ul>\n<li>构造函数 ( <strong>也可以省略掉 new </strong> )</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = new Array(); </div><div class=\"line\"></div><div class=\"line\">// 如果预先知道元素数量</div><div class=\"line\">var colors = new Array(20);</div><div class=\"line\"></div><div class=\"line\">// 如果预先知道要包含的项</div><div class=\"line\">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot; );</div><div class=\"line\"></div><div class=\"line\">// 如上两个所示，给构造函数传入 number 类型参数 --&gt; length 为 number 的数组</div><div class=\"line\">// 给构造函数传入 其他类型参数 --&gt; 创建包含那个值的只有一项的数组</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>数组字面量</li>\n</ul>\n<p>数组字面量由一对包含数组项的方括号表示，多个数组项以逗号隔开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class=\"line\"></div><div class=\"line\">var values = [1,2,]; //  会创建一个包含 2  或 3 项的数组</div></pre></td></tr></table></figure>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><ul>\n<li>使用 <strong>方括号</strong>, 并提供 相应值的基于 0 的数字的索引</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class=\"line\">alert( colors[0] ); // 显示第一项</div></pre></td></tr></table></figure>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>设置数组的值与访问语法相同，但会替换指定位置的值。</p>\n<p>如果设置某个值的索引超过数组现有的项数，则会自动增加到该 _<em>索引值 + 1</em>  的长度</p>\n<h3 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h3><ul>\n<li>数组的项数保存在其 <strong>length</strong> 的属性中</li>\n<li>length &gt; = 0</li>\n<li>可以通过改变 length 的值，向数组添加 ( 新增的每一项都为 undefined ) 或者减少 ( 减少的那几项是 undefined ) 项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    </div><div class=\"line\">colors[99] = &quot;black&quot;;                            // 在位置 99 添加一种颜色</div><div class=\"line\"></div><div class=\"line\">alert( colors.length );    //100</div><div class=\"line\">alert( colors[0] ); // 显示第一项</div></pre></td></tr></table></figure>\n<p>上例 3 到 98 实际上是 <strong>不存在的</strong> , 所以访问它们都将返回 <strong>undefined</strong></p>\n<h3 id=\"检测数组-Array-isArray\"><a href=\"#检测数组-Array-isArray\" class=\"headerlink\" title=\"检测数组 Array.isArray()\"></a>检测数组 Array.isArray()</h3><h3 id=\"转化方法\"><a href=\"#转化方法\" class=\"headerlink\" title=\"转化方法\"></a>转化方法</h3><ul>\n<li><p><strong>所有的对象</strong> 都具有 <strong>toLocaleString()</strong>, <strong>toString()</strong>, <strong>valueOf()</strong> 方法</p>\n<ul>\n<li><p>toString() 返回由数组中每个值的字符串形式拼接而成的一个 <strong>以逗号分隔的字符串</strong>。 它会为取得每一项，调用每一项的 <strong>toString()</strong> 。</p>\n</li>\n<li><p><strong>valueOf()</strong> 返回 <strong>数组</strong></p>\n</li>\n<li><p><strong>toLocaleString()</strong>  它也会创建一个数组值的以逗号分隔的<strong>字符串</strong>。 不同的是， 它会为取得每一项，调用每一项的 <strong>toLocaleString()</strong> 。 而不是 <strong>toString()</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>NOTE: alert() 会在后台调用 toString() 方法</p>\n<ul>\n<li><p>使用 join()</p>\n<ul>\n<li><p>可以使用不同的分隔符来构建这个字符串。</p>\n</li>\n<li><p>一个参数，作为分隔符的 <strong>字符串</strong></p>\n</li>\n<li><p>如果不给 join() 传参数 ／ 传入 undefined 则使用 “<strong>,</strong>“ 作为分隔符。 </p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    </div><div class=\"line\">console.log( colors.join(&quot;-&quot;) ); // red-blue-green</div></pre></td></tr></table></figure>\n<p>###方法</p>\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><p>栈是一种 <strong>后进先出</strong> 的数据结构。<br>在栈中项的插入 ( 叫做<strong>推入 push</strong> ), 移除( 叫做 <strong>弹出 pop</strong> ), 只发生在一个位置 — <strong>栈的顶部</strong></p>\n<p>ECMAScript 为数组专门提供了 <strong>push()</strong> 和 <strong>pop()</strong> 方法，以便实现类似 栈 的行为。</p>\n<ul>\n<li><p>push()</p>\n<ul>\n<li>接收任意数量的参数，</li>\n<li>将它们 逐个添加到 数组末尾，</li>\n<li><em>返回修改后数组的<strong>长度</strong>。</em></li>\n</ul>\n</li>\n<li><p>pop()</p>\n<ul>\n<li>从数组的末尾 <strong>移除最后一项</strong>，</li>\n<li>减少数组的 <strong>length</strong> 值，</li>\n<li>然后返回 <strong>移除的项</strong></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.push(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(count); // 2</div><div class=\"line\">console.log(colors ); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">var item = colors.pop();</div><div class=\"line\">console.log( item ); // &quot;green&quot;</div><div class=\"line\">console.log(colors); // [&quot;red&quot;]</div></pre></td></tr></table></figure>\n<h4 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h4><p>队列数据结构的访问规则是 <strong>先进先出</strong></p>\n<p>队列在列表的 <strong>末端添加项</strong>，<br>从列表的<strong>前端移除项</strong></p>\n<ul>\n<li><p>push()  与上面相同</p>\n</li>\n<li><p>shift() </p>\n<ul>\n<li>从数组的前端 <strong>取得项</strong></li>\n<li>移除数组的第一个项</li>\n<li>返回移除的那个项</li>\n<li>同时长度 - 1</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.push(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(count);  // 2</div><div class=\"line\">console.log(colors ); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">colors.push(&quot;black&quot;);  // 3</div><div class=\"line\"></div><div class=\"line\">var item = colors.shift();</div><div class=\"line\">console.log( item );  // red</div><div class=\"line\">console.log(colors);   [&quot;green&quot;, &quot;black&quot;]</div><div class=\"line\">console.log(colors.length); // 2</div></pre></td></tr></table></figure>\n<ul>\n<li><p>unshift()</p>\n<ul>\n<li>unshift() 与 shift() 用途相反，</li>\n<li>在数组的前端添加任意个项</li>\n<li>返回新的数组的 <strong>长度</strong></li>\n</ul>\n</li>\n</ul>\n<p>unshift() 和 pop() 可以实现相反方向的队列</p>\n<ul>\n<li>在数组前端添加项</li>\n<li>在数组末端删除项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.unshift(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(colors); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\">console.log(count); // 2</div><div class=\"line\"></div><div class=\"line\">colors.unshift(&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(colors); // [&quot;black&quot;, &quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">var item = colors.pop();</div><div class=\"line\"></div><div class=\"line\">console.log( item ); // &quot;green&quot;</div><div class=\"line\">console.log(colors); // [&quot;black&quot;, &quot;red&quot;]</div><div class=\"line\">console.log(colors.length);</div></pre></td></tr></table></figure>\n<p>unshift() 和 shift() 可以实现相反方向的栈</p>\n<h4 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h4><ul>\n<li><p>sort()</p>\n<ul>\n<li>默认情况下， sort()  按<strong>升序</strong>排列数组</li>\n<li>会 先调用每个数组项的 <strong>toString()</strong> 转型方法 –&gt; 得到字符串</li>\n<li>!!!!!  然后 比较<strong>得到的字符串</strong></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>sort() 方法可以接收一个 <strong>比较函数</strong> 作为参数，以便指定 哪个值 位于 哪个值 的前面。</p>\n</li>\n<li><p>比较函数：</p>\n<ul>\n<li>接收 <strong>两个参数</strong></li>\n<li>返回一个负数 ——- 第一个参数 在 第二个参数之前</li>\n<li>返回一个正数 ——- 第一个参数 在 第二个参数之后</li>\n</ul>\n</li>\n</ul>\n<p>如下：</p>\n<p>只要将比较函数作为参数传给 sort() 方法即可。</p>\n<p>NOTE:  <strong>reverse() 不可以将 比较函数当 参数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2) &#123;</div><div class=\"line\">  if( v1 &lt; v2 ) &#123;</div><div class=\"line\">    return -1;</div><div class=\"line\">  &#125; else if( v1 &gt; v2 ) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\"></div><div class=\"line\">console.log( arrb.sort(compare) ); // [1, 1, 1, 2, 4, 6, 23, 76, 535]</div></pre></td></tr></table></figure></p>\n<p>上面的 compare() 函数适用于大多数数据类型，</p>\n<p>对于<strong>数值类型</strong> 或者其 <strong>valueOf()</strong> 返回 <strong>数值类型 </strong>的对象类型，可以使用一个比较简单的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2 ) &#123;</div><div class=\"line\">  return v1 - v2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>reverse()   反转数据项的顺序</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\">console.log( arrb.reverse() ); // [2, 535, 1, 1, 76, 6, 4, 23, 1]</div></pre></td></tr></table></figure>\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><ul>\n<li><p>concat()  —— 不改变原数组</p>\n<ul>\n<li>创建当前数组的一个 <strong>副本</strong></li>\n<li>将接收到的参数 <strong>添加</strong>到这个副本的末尾</li>\n<li>返回 <strong>新构建的数组</strong></li>\n<li><p><strong>不会影响 原数组</strong></p>\n</li>\n<li><p>如果传递的不是数组，这些值就会被简单的添加到结果数组的末尾</p>\n</li>\n<li>如果没有传递参数，它只是 <strong>复制</strong> 当前的数组并返回副本</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\"></div><div class=\"line\">let arrc =  arrb.concat(&apos;a&apos;, &apos;b&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log(arrc);  // [1, 23, 4, 6, 76, 1, 1, 535, 2, &quot;a&quot;, &quot;b&quot;]</div><div class=\"line\"></div><div class=\"line\">let arrd = arrb.concat(&apos;y&apos;, [&apos;s&apos;, &apos;2&apos;]); </div><div class=\"line\"></div><div class=\"line\">console.log(arrd); // [1, 23, 4, 6, 76, 1, 1, 535, 2, &quot;y&quot;, &quot;s&quot;, &quot;2&quot;]</div><div class=\"line\"></div><div class=\"line\">console.log(arrb); // [1, 23, 4, 6, 76, 1, 1, 535, 2]</div><div class=\"line\"></div><div class=\"line\">- slice()  ------ 不改变原数组</div><div class=\"line\"></div><div class=\"line\">  + 能够基于 当前数组中的一个或者多个项 __创建一个新数组__，</div><div class=\"line\"></div><div class=\"line\">  + 参数： 接受一个或者两个参数 (  返回项的 __起始位置__和__结束位置__ )</div><div class=\"line\">    </div><div class=\"line\">    - 一个参数： 返回 从该参数指定位置到当前数组末尾的所有项</div><div class=\"line\">    </div><div class=\"line\">    - 两个参数： 返回起始位置到结束位置(  _不包括结束位置_) 的所有项</div><div class=\"line\"></div><div class=\"line\">    - 如果参数有 __负值__，则用 _数组长度加上该数_来确定相应的位置。</div></pre></td></tr></table></figure>\n<p>const arrb = [1,23,4,11,’a’, ‘b’, ‘v’, 535,2];</p>\n<p>let arrc =  arrb.slice(5);</p>\n<p>console.log(arrc);  // [“b”, “v”, 535, 2]</p>\n<p>let arrd = arrb.slice(0,6);</p>\n<p>console.log(arrd); // [1, 23, 4, 11, “a”, “b”]</p>\n<p>let arre = arrb.slice(-5,6);</p>\n<p>console.log(arrb.length); // 9</p>\n<p>console.log(arre); // [“a”, “b”]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### splice() </div><div class=\"line\"></div><div class=\"line\">有很多种用法</div><div class=\"line\"></div><div class=\"line\">- 主要方式： 向数组的中部插入项</div><div class=\"line\"></div><div class=\"line\">使用主要这种方式的有 3 种：</div><div class=\"line\"></div><div class=\"line\">- 删除</div><div class=\"line\"></div><div class=\"line\">可以删除任意数量的项，需指定 2 个参数： 要删除第一项的位置 和 要删除的项数。</div><div class=\"line\"></div><div class=\"line\">- 插入</div><div class=\"line\"></div><div class=\"line\">可以向 __指定位置__ 插入任意数量的项。需指定 __至少 3 个参数__： 起始位置， 0 ( 要删除的项数 )，要插入的项 ( 可多个 )</div><div class=\"line\"></div><div class=\"line\">- 替换</div><div class=\"line\"></div><div class=\"line\">可以向指定位置插入任意数量的项，且同时删除任意数量的项。 需指定 3 个参数：起始位置，要删除的项的数目，要插入的任意数量的项 ( _插入的项数不必与删除的项数相等_)</div><div class=\"line\"></div><div class=\"line\">- 返回</div><div class=\"line\"></div><div class=\"line\">splice()  始终都返回一个数组，该数组包含着从原始数组中删除的项</div></pre></td></tr></table></figure>\n<p>const arrb = [1,23,4,11,’a’, ‘b’, ‘v’, 535,2];</p>\n<p>// 删除<br>let arrc =  arrb.splice(0,1);<br>console.log(arrc); //  [1]<br>console.log(arrb); // [ 23,4,11,’a’, ‘b’, ‘v’, 535,2 ]</p>\n<p>// 插入<br>let arrd = arrb.splice(1, 0, ‘hello’,’hi’);</p>\n<p>console.log(arrd); // [ 23, ‘hello’, ‘hi’,4,11,’a’, ‘b’, ‘v’, 535,2 ]<br>console.log(arrb); // []</p>\n<p>// 替换<br>let arre = arrb.splice(3, 2, ‘one’, ‘two’);<br>console.log(arrb); // [ 23, ‘hello’, ‘hi’, ‘one’, ‘two’,’a’, ‘b’, ‘v’, 535,2 ]<br>console.log(arre); // [4, 11]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 位置方法</div><div class=\"line\"></div><div class=\"line\">- indexOf()</div><div class=\"line\">  从数组的开头开始向后查找</div><div class=\"line\"></div><div class=\"line\">- lastIndexOf()</div><div class=\"line\">  从数组的末尾向前查找</div><div class=\"line\"></div><div class=\"line\">- 这两个参数都接收 2 个参数： 要查找的项， 查找起点位置的索引 ( 可选 )</div><div class=\"line\"> </div><div class=\"line\">- 返回 要查找的项在数组的位置，或者没找到返回 -1</div><div class=\"line\">- 在比较第一个参数和数组中的每一项时，__使用全等__</div></pre></td></tr></table></figure>\n<p>const arrb = [10  ,23,4,11,666, ‘b’, ‘v’, a1,2];</p>\n<p>console.log(arrb.indexOf(666) ); // 7<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 迭代方法 ----- 不修改原数组</div><div class=\"line\"></div><div class=\"line\">- every()  对数组中的 __每一项__运行指定函数，如果该函数 __每一项都返回 true__ ,  则返回 _true_, __ 当一项不满足则返回 false， 不再运行下面的项__</div><div class=\"line\"></div><div class=\"line\">返回 true / false</div><div class=\"line\"></div><div class=\"line\">- filter() 对数组中的 __每一项__运行指定函数，返回该函数会返回 _true_ 的项组成的数组</div><div class=\"line\"></div><div class=\"line\">返回 数组</div><div class=\"line\"></div><div class=\"line\">- forEach() 对数组中的 __每一项__运行指定函数 __无返回值__( 只能返回 undefined )</div><div class=\"line\"></div><div class=\"line\">返回 undefined ( 无返回值 )</div><div class=\"line\"></div><div class=\"line\">- map() 对数组中的 __每一项__运行指定函数，返回每次函数调用的__结果组成的数组__</div><div class=\"line\"></div><div class=\"line\">返回 数组</div><div class=\"line\"></div><div class=\"line\">- some() 对数组中的 __每一项__运行指定函数，如果该函数中的__任一项__会返回 true, 则返回 true</div><div class=\"line\"></div><div class=\"line\">返回 true / false</div></pre></td></tr></table></figure></p>\n<p>let numbers = [1,5,67,8,3,1,7];</p>\n<p>let everyResult = numbers.every((item, idx, array) =&gt; {<br>  console.log(item);<br>  return item &gt; 6;<br>})</p>\n<p>console.log(everyResult ); // false</p>\n<p>let filterResult = numbers.filter((item, idx, array)=&gt;{<br>  let rest = array.slice(0, array.indexOf(item)).concat(array.slice(array.indexOf(item)+1,array.length ));<br>  return rest.indexOf(item) &gt;= 0 ? true: false  ;<br>})</p>\n<p>console.log(filterResult); // [1, 1]</p>\n<p>let forEachResult = [];<br>numbers.forEach((item, idx, array) =&gt; {<br>  forEachResult[idx] = item -1 ;<br>})</p>\n<p>console.log(forEachResult); // [0, 4, 66, 7, 2, 0, 6]</p>\n<p>let mapResult = numbers.map((item,idx,array)=&gt; {<br>  return item-1;<br>})<br>console.log(mapResult); // [0, 4, 66, 7, 2, 0, 6]</p>\n<p>let someResult = numbers.some((item, idx, array)=&gt;{<br>  return item &gt; array[idx-1];<br>})<br>console.log(someResult); // true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 归并方法</div><div class=\"line\"></div><div class=\"line\">- reduce()</div><div class=\"line\">- reduceRight()</div><div class=\"line\"></div><div class=\"line\">- 迭代所有项</div><div class=\"line\">- 构建一个最终返回的值</div><div class=\"line\"></div><div class=\"line\">参数</div><div class=\"line\">- 每一项上调用的 函数 </div><div class=\"line\">  </div><div class=\"line\">  + 这个函数接收 4 个参数: 前一个值， 当前值， 项的索引， 数组对象</div><div class=\"line\">  </div><div class=\"line\">  + 这个函数 __返回的任何值__都会作为 __第一个参数__自动传给 __下一项__</div><div class=\"line\"></div><div class=\"line\">- 初始值 ( 可选 )</div></pre></td></tr></table></figure></p>\n<p>let numbers = [1,5,67,8,3,1,7];</p>\n<p>let reduceResult = numbers.reduce((pre, cur, idx, array) =&gt; {<br>  let item = idx &gt; 0 ? cur + pre[idx-1] : cur;  // 每一项和已经得到的之前的一项相加<br>  pre.push(item);<br>  return pre;<br>}, []);</p>\n<p>console.log( reduceResult );  // [1, 6, 73, 81, 84, 85, 92]<br>```<br><blockquote><p>参考：</p>\n<p><em>JavaScript 高级程序设计</em></p>\n</blockquote></p>\n","excerpt":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征:\"></a>特征:</h3><ul>\n<li>有序列表</li>\n<li><strong>每一项</strong> 都可以保存 <strong>任意类型</strong> 的值</li>\n<li>大小可以动态调整</li>\n</ul>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><ul>\n<li>构造函数 ( <strong>也可以省略掉 new </strong> )</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = new Array(); </div><div class=\"line\"></div><div class=\"line\">// 如果预先知道元素数量</div><div class=\"line\">var colors = new Array(20);</div><div class=\"line\"></div><div class=\"line\">// 如果预先知道要包含的项</div><div class=\"line\">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot; );</div><div class=\"line\"></div><div class=\"line\">// 如上两个所示，给构造函数传入 number 类型参数 --&gt; length 为 number 的数组</div><div class=\"line\">// 给构造函数传入 其他类型参数 --&gt; 创建包含那个值的只有一项的数组</div></pre></td></tr></table></figure>","more":"<ul>\n<li>数组字面量</li>\n</ul>\n<p>数组字面量由一对包含数组项的方括号表示，多个数组项以逗号隔开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class=\"line\"></div><div class=\"line\">var values = [1,2,]; //  会创建一个包含 2  或 3 项的数组</div></pre></td></tr></table></figure>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><ul>\n<li>使用 <strong>方括号</strong>, 并提供 相应值的基于 0 的数字的索引</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class=\"line\">alert( colors[0] ); // 显示第一项</div></pre></td></tr></table></figure>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p>设置数组的值与访问语法相同，但会替换指定位置的值。</p>\n<p>如果设置某个值的索引超过数组现有的项数，则会自动增加到该 _<em>索引值 + 1</em>  的长度</p>\n<h3 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h3><ul>\n<li>数组的项数保存在其 <strong>length</strong> 的属性中</li>\n<li>length &gt; = 0</li>\n<li>可以通过改变 length 的值，向数组添加 ( 新增的每一项都为 undefined ) 或者减少 ( 减少的那几项是 undefined ) 项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    </div><div class=\"line\">colors[99] = &quot;black&quot;;                            // 在位置 99 添加一种颜色</div><div class=\"line\"></div><div class=\"line\">alert( colors.length );    //100</div><div class=\"line\">alert( colors[0] ); // 显示第一项</div></pre></td></tr></table></figure>\n<p>上例 3 到 98 实际上是 <strong>不存在的</strong> , 所以访问它们都将返回 <strong>undefined</strong></p>\n<h3 id=\"检测数组-Array-isArray\"><a href=\"#检测数组-Array-isArray\" class=\"headerlink\" title=\"检测数组 Array.isArray()\"></a>检测数组 Array.isArray()</h3><h3 id=\"转化方法\"><a href=\"#转化方法\" class=\"headerlink\" title=\"转化方法\"></a>转化方法</h3><ul>\n<li><p><strong>所有的对象</strong> 都具有 <strong>toLocaleString()</strong>, <strong>toString()</strong>, <strong>valueOf()</strong> 方法</p>\n<ul>\n<li><p>toString() 返回由数组中每个值的字符串形式拼接而成的一个 <strong>以逗号分隔的字符串</strong>。 它会为取得每一项，调用每一项的 <strong>toString()</strong> 。</p>\n</li>\n<li><p><strong>valueOf()</strong> 返回 <strong>数组</strong></p>\n</li>\n<li><p><strong>toLocaleString()</strong>  它也会创建一个数组值的以逗号分隔的<strong>字符串</strong>。 不同的是， 它会为取得每一项，调用每一项的 <strong>toLocaleString()</strong> 。 而不是 <strong>toString()</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>NOTE: alert() 会在后台调用 toString() 方法</p>\n<ul>\n<li><p>使用 join()</p>\n<ul>\n<li><p>可以使用不同的分隔符来构建这个字符串。</p>\n</li>\n<li><p>一个参数，作为分隔符的 <strong>字符串</strong></p>\n</li>\n<li><p>如果不给 join() 传参数 ／ 传入 undefined 则使用 “<strong>,</strong>“ 作为分隔符。 </p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];    </div><div class=\"line\">console.log( colors.join(&quot;-&quot;) ); // red-blue-green</div></pre></td></tr></table></figure>\n<p>###方法</p>\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><p>栈是一种 <strong>后进先出</strong> 的数据结构。<br>在栈中项的插入 ( 叫做<strong>推入 push</strong> ), 移除( 叫做 <strong>弹出 pop</strong> ), 只发生在一个位置 — <strong>栈的顶部</strong></p>\n<p>ECMAScript 为数组专门提供了 <strong>push()</strong> 和 <strong>pop()</strong> 方法，以便实现类似 栈 的行为。</p>\n<ul>\n<li><p>push()</p>\n<ul>\n<li>接收任意数量的参数，</li>\n<li>将它们 逐个添加到 数组末尾，</li>\n<li><em>返回修改后数组的<strong>长度</strong>。</em></li>\n</ul>\n</li>\n<li><p>pop()</p>\n<ul>\n<li>从数组的末尾 <strong>移除最后一项</strong>，</li>\n<li>减少数组的 <strong>length</strong> 值，</li>\n<li>然后返回 <strong>移除的项</strong></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.push(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(count); // 2</div><div class=\"line\">console.log(colors ); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">var item = colors.pop();</div><div class=\"line\">console.log( item ); // &quot;green&quot;</div><div class=\"line\">console.log(colors); // [&quot;red&quot;]</div></pre></td></tr></table></figure>\n<h4 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h4><p>队列数据结构的访问规则是 <strong>先进先出</strong></p>\n<p>队列在列表的 <strong>末端添加项</strong>，<br>从列表的<strong>前端移除项</strong></p>\n<ul>\n<li><p>push()  与上面相同</p>\n</li>\n<li><p>shift() </p>\n<ul>\n<li>从数组的前端 <strong>取得项</strong></li>\n<li>移除数组的第一个项</li>\n<li>返回移除的那个项</li>\n<li>同时长度 - 1</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.push(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(count);  // 2</div><div class=\"line\">console.log(colors ); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">colors.push(&quot;black&quot;);  // 3</div><div class=\"line\"></div><div class=\"line\">var item = colors.shift();</div><div class=\"line\">console.log( item );  // red</div><div class=\"line\">console.log(colors);   [&quot;green&quot;, &quot;black&quot;]</div><div class=\"line\">console.log(colors.length); // 2</div></pre></td></tr></table></figure>\n<ul>\n<li><p>unshift()</p>\n<ul>\n<li>unshift() 与 shift() 用途相反，</li>\n<li>在数组的前端添加任意个项</li>\n<li>返回新的数组的 <strong>长度</strong></li>\n</ul>\n</li>\n</ul>\n<p>unshift() 和 pop() 可以实现相反方向的队列</p>\n<ul>\n<li>在数组前端添加项</li>\n<li>在数组末端删除项</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">const colors = new Array();</div><div class=\"line\">const count = colors.unshift(&quot;red&quot;, &quot;green&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(colors); // [&quot;red&quot;, &quot;green&quot;]</div><div class=\"line\">console.log(count); // 2</div><div class=\"line\"></div><div class=\"line\">colors.unshift(&quot;black&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(colors); // [&quot;black&quot;, &quot;red&quot;, &quot;green&quot;]</div><div class=\"line\"></div><div class=\"line\">var item = colors.pop();</div><div class=\"line\"></div><div class=\"line\">console.log( item ); // &quot;green&quot;</div><div class=\"line\">console.log(colors); // [&quot;black&quot;, &quot;red&quot;]</div><div class=\"line\">console.log(colors.length);</div></pre></td></tr></table></figure>\n<p>unshift() 和 shift() 可以实现相反方向的栈</p>\n<h4 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h4><ul>\n<li><p>sort()</p>\n<ul>\n<li>默认情况下， sort()  按<strong>升序</strong>排列数组</li>\n<li>会 先调用每个数组项的 <strong>toString()</strong> 转型方法 –&gt; 得到字符串</li>\n<li>!!!!!  然后 比较<strong>得到的字符串</strong></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>sort() 方法可以接收一个 <strong>比较函数</strong> 作为参数，以便指定 哪个值 位于 哪个值 的前面。</p>\n</li>\n<li><p>比较函数：</p>\n<ul>\n<li>接收 <strong>两个参数</strong></li>\n<li>返回一个负数 ——- 第一个参数 在 第二个参数之前</li>\n<li>返回一个正数 ——- 第一个参数 在 第二个参数之后</li>\n</ul>\n</li>\n</ul>\n<p>如下：</p>\n<p>只要将比较函数作为参数传给 sort() 方法即可。</p>\n<p>NOTE:  <strong>reverse() 不可以将 比较函数当 参数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2) &#123;</div><div class=\"line\">  if( v1 &lt; v2 ) &#123;</div><div class=\"line\">    return -1;</div><div class=\"line\">  &#125; else if( v1 &gt; v2 ) &#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    return 0;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\"></div><div class=\"line\">console.log( arrb.sort(compare) ); // [1, 1, 1, 2, 4, 6, 23, 76, 535]</div></pre></td></tr></table></figure></p>\n<p>上面的 compare() 函数适用于大多数数据类型，</p>\n<p>对于<strong>数值类型</strong> 或者其 <strong>valueOf()</strong> 返回 <strong>数值类型 </strong>的对象类型，可以使用一个比较简单的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(v1, v2 ) &#123;</div><div class=\"line\">  return v1 - v2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>reverse()   反转数据项的顺序</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\">console.log( arrb.reverse() ); // [2, 535, 1, 1, 76, 6, 4, 23, 1]</div></pre></td></tr></table></figure>\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><ul>\n<li><p>concat()  —— 不改变原数组</p>\n<ul>\n<li>创建当前数组的一个 <strong>副本</strong></li>\n<li>将接收到的参数 <strong>添加</strong>到这个副本的末尾</li>\n<li>返回 <strong>新构建的数组</strong></li>\n<li><p><strong>不会影响 原数组</strong></p>\n</li>\n<li><p>如果传递的不是数组，这些值就会被简单的添加到结果数组的末尾</p>\n</li>\n<li>如果没有传递参数，它只是 <strong>复制</strong> 当前的数组并返回副本</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const arrb = [1,23,4,6,76,1,1,535,2];</div><div class=\"line\"></div><div class=\"line\">let arrc =  arrb.concat(&apos;a&apos;, &apos;b&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log(arrc);  // [1, 23, 4, 6, 76, 1, 1, 535, 2, &quot;a&quot;, &quot;b&quot;]</div><div class=\"line\"></div><div class=\"line\">let arrd = arrb.concat(&apos;y&apos;, [&apos;s&apos;, &apos;2&apos;]); </div><div class=\"line\"></div><div class=\"line\">console.log(arrd); // [1, 23, 4, 6, 76, 1, 1, 535, 2, &quot;y&quot;, &quot;s&quot;, &quot;2&quot;]</div><div class=\"line\"></div><div class=\"line\">console.log(arrb); // [1, 23, 4, 6, 76, 1, 1, 535, 2]</div><div class=\"line\"></div><div class=\"line\">- slice()  ------ 不改变原数组</div><div class=\"line\"></div><div class=\"line\">  + 能够基于 当前数组中的一个或者多个项 __创建一个新数组__，</div><div class=\"line\"></div><div class=\"line\">  + 参数： 接受一个或者两个参数 (  返回项的 __起始位置__和__结束位置__ )</div><div class=\"line\">    </div><div class=\"line\">    - 一个参数： 返回 从该参数指定位置到当前数组末尾的所有项</div><div class=\"line\">    </div><div class=\"line\">    - 两个参数： 返回起始位置到结束位置(  _不包括结束位置_) 的所有项</div><div class=\"line\"></div><div class=\"line\">    - 如果参数有 __负值__，则用 _数组长度加上该数_来确定相应的位置。</div></pre></td></tr></table></figure>\n<p>const arrb = [1,23,4,11,’a’, ‘b’, ‘v’, 535,2];</p>\n<p>let arrc =  arrb.slice(5);</p>\n<p>console.log(arrc);  // [“b”, “v”, 535, 2]</p>\n<p>let arrd = arrb.slice(0,6);</p>\n<p>console.log(arrd); // [1, 23, 4, 11, “a”, “b”]</p>\n<p>let arre = arrb.slice(-5,6);</p>\n<p>console.log(arrb.length); // 9</p>\n<p>console.log(arre); // [“a”, “b”]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### splice() </div><div class=\"line\"></div><div class=\"line\">有很多种用法</div><div class=\"line\"></div><div class=\"line\">- 主要方式： 向数组的中部插入项</div><div class=\"line\"></div><div class=\"line\">使用主要这种方式的有 3 种：</div><div class=\"line\"></div><div class=\"line\">- 删除</div><div class=\"line\"></div><div class=\"line\">可以删除任意数量的项，需指定 2 个参数： 要删除第一项的位置 和 要删除的项数。</div><div class=\"line\"></div><div class=\"line\">- 插入</div><div class=\"line\"></div><div class=\"line\">可以向 __指定位置__ 插入任意数量的项。需指定 __至少 3 个参数__： 起始位置， 0 ( 要删除的项数 )，要插入的项 ( 可多个 )</div><div class=\"line\"></div><div class=\"line\">- 替换</div><div class=\"line\"></div><div class=\"line\">可以向指定位置插入任意数量的项，且同时删除任意数量的项。 需指定 3 个参数：起始位置，要删除的项的数目，要插入的任意数量的项 ( _插入的项数不必与删除的项数相等_)</div><div class=\"line\"></div><div class=\"line\">- 返回</div><div class=\"line\"></div><div class=\"line\">splice()  始终都返回一个数组，该数组包含着从原始数组中删除的项</div></pre></td></tr></table></figure>\n<p>const arrb = [1,23,4,11,’a’, ‘b’, ‘v’, 535,2];</p>\n<p>// 删除<br>let arrc =  arrb.splice(0,1);<br>console.log(arrc); //  [1]<br>console.log(arrb); // [ 23,4,11,’a’, ‘b’, ‘v’, 535,2 ]</p>\n<p>// 插入<br>let arrd = arrb.splice(1, 0, ‘hello’,’hi’);</p>\n<p>console.log(arrd); // [ 23, ‘hello’, ‘hi’,4,11,’a’, ‘b’, ‘v’, 535,2 ]<br>console.log(arrb); // []</p>\n<p>// 替换<br>let arre = arrb.splice(3, 2, ‘one’, ‘two’);<br>console.log(arrb); // [ 23, ‘hello’, ‘hi’, ‘one’, ‘two’,’a’, ‘b’, ‘v’, 535,2 ]<br>console.log(arre); // [4, 11]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 位置方法</div><div class=\"line\"></div><div class=\"line\">- indexOf()</div><div class=\"line\">  从数组的开头开始向后查找</div><div class=\"line\"></div><div class=\"line\">- lastIndexOf()</div><div class=\"line\">  从数组的末尾向前查找</div><div class=\"line\"></div><div class=\"line\">- 这两个参数都接收 2 个参数： 要查找的项， 查找起点位置的索引 ( 可选 )</div><div class=\"line\"> </div><div class=\"line\">- 返回 要查找的项在数组的位置，或者没找到返回 -1</div><div class=\"line\">- 在比较第一个参数和数组中的每一项时，__使用全等__</div></pre></td></tr></table></figure>\n<p>const arrb = [10  ,23,4,11,666, ‘b’, ‘v’, a1,2];</p>\n<p>console.log(arrb.indexOf(666) ); // 7<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 迭代方法 ----- 不修改原数组</div><div class=\"line\"></div><div class=\"line\">- every()  对数组中的 __每一项__运行指定函数，如果该函数 __每一项都返回 true__ ,  则返回 _true_, __ 当一项不满足则返回 false， 不再运行下面的项__</div><div class=\"line\"></div><div class=\"line\">返回 true / false</div><div class=\"line\"></div><div class=\"line\">- filter() 对数组中的 __每一项__运行指定函数，返回该函数会返回 _true_ 的项组成的数组</div><div class=\"line\"></div><div class=\"line\">返回 数组</div><div class=\"line\"></div><div class=\"line\">- forEach() 对数组中的 __每一项__运行指定函数 __无返回值__( 只能返回 undefined )</div><div class=\"line\"></div><div class=\"line\">返回 undefined ( 无返回值 )</div><div class=\"line\"></div><div class=\"line\">- map() 对数组中的 __每一项__运行指定函数，返回每次函数调用的__结果组成的数组__</div><div class=\"line\"></div><div class=\"line\">返回 数组</div><div class=\"line\"></div><div class=\"line\">- some() 对数组中的 __每一项__运行指定函数，如果该函数中的__任一项__会返回 true, 则返回 true</div><div class=\"line\"></div><div class=\"line\">返回 true / false</div></pre></td></tr></table></figure></p>\n<p>let numbers = [1,5,67,8,3,1,7];</p>\n<p>let everyResult = numbers.every((item, idx, array) =&gt; {<br>  console.log(item);<br>  return item &gt; 6;<br>})</p>\n<p>console.log(everyResult ); // false</p>\n<p>let filterResult = numbers.filter((item, idx, array)=&gt;{<br>  let rest = array.slice(0, array.indexOf(item)).concat(array.slice(array.indexOf(item)+1,array.length ));<br>  return rest.indexOf(item) &gt;= 0 ? true: false  ;<br>})</p>\n<p>console.log(filterResult); // [1, 1]</p>\n<p>let forEachResult = [];<br>numbers.forEach((item, idx, array) =&gt; {<br>  forEachResult[idx] = item -1 ;<br>})</p>\n<p>console.log(forEachResult); // [0, 4, 66, 7, 2, 0, 6]</p>\n<p>let mapResult = numbers.map((item,idx,array)=&gt; {<br>  return item-1;<br>})<br>console.log(mapResult); // [0, 4, 66, 7, 2, 0, 6]</p>\n<p>let someResult = numbers.some((item, idx, array)=&gt;{<br>  return item &gt; array[idx-1];<br>})<br>console.log(someResult); // true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 归并方法</div><div class=\"line\"></div><div class=\"line\">- reduce()</div><div class=\"line\">- reduceRight()</div><div class=\"line\"></div><div class=\"line\">- 迭代所有项</div><div class=\"line\">- 构建一个最终返回的值</div><div class=\"line\"></div><div class=\"line\">参数</div><div class=\"line\">- 每一项上调用的 函数 </div><div class=\"line\">  </div><div class=\"line\">  + 这个函数接收 4 个参数: 前一个值， 当前值， 项的索引， 数组对象</div><div class=\"line\">  </div><div class=\"line\">  + 这个函数 __返回的任何值__都会作为 __第一个参数__自动传给 __下一项__</div><div class=\"line\"></div><div class=\"line\">- 初始值 ( 可选 )</div></pre></td></tr></table></figure></p>\n<p>let numbers = [1,5,67,8,3,1,7];</p>\n<p>let reduceResult = numbers.reduce((pre, cur, idx, array) =&gt; {<br>  let item = idx &gt; 0 ? cur + pre[idx-1] : cur;  // 每一项和已经得到的之前的一项相加<br>  pre.push(item);<br>  return pre;<br>}, []);</p>\n<p>console.log( reduceResult );  // [1, 6, 73, 81, 84, 85, 92]<br>```<br><blockquote><p>参考：</p>\n<p><em>JavaScript 高级程序设计</em></p>\n</blockquote></p>"},{"title":"箭头函数","auto_spacing":true,"_content":"\n#### 基本定义\n```\n  // ES5\n  var selected = allJobs.filter(function (job) {\n    return job.isSelected();\n  });\n\n  // ES6\n  var selected = allJobs.filter(job => job.isSelected());\n```\n\n- 当函数只有  __一个参数__ 的时候，可以使用新标准中的箭头函数，它的语法非常简单：标识符=>表达式。你无需输入function和return，一些小括号、大括号以及 __分号__ 也可以省略。\n\n<!-- more -->\n\n- 如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用 __小括号__  包裹 __参数list__。\n\n```\n  // ES5\n    var total = values.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  // ES6\n    var total = values.reduce((a, b) => a + b, 0);\n```\n\n如果函数逻辑稍微复杂一些，不能一行代码就完成的。怎么办呢？\n\n- 除表达式外，箭头函数还可以包含一个 __块语句__\n\n```\n  // ES5\n  $(\"#confetti-btn\").click(function (event) {\n    playTrumpet();\n    fireConfettiCannon();\n  });\n```\n这是它们在ES6中看起来的样子：\n```\n  // ES6\n  $(\"#confetti-btn\").click(event => {\n    playTrumpet();\n     fireConfettiCannon();\n  });\n```\n\n#### 返回对象字面量\n##### 注意！！这里有个坑\n\n 使用了块语句( { } ) 的箭头函数不会自动返回值，你需要使用return语句将所需值返回。\n\n 这样有什么问题呢？\n\n```\n   // 为与你玩耍的每一个小狗创建一个新的空对象\n   var chewToys = puppies.map(puppy => {});   // 这样写会报Bug！\n```\n你以为 你为每一个小狗创建一个新的空对象，但是 其实根本不是，这样是 __会报错__ 的,为什么呢?\n\n因为箭头函数还可以包含一个 __块语句__！！！\n\nES6中的规则是，__紧随__ 箭头的 { 被解析为块的开始，而不是对象的开始。因此，puppy => {} 这段代码就被解析为没有任何行为并返回undefined的箭头函数 !!\n\n所以\n\n返回对象字面量时\n\n必须要用 小括号将返回的对象 括起来！！\n--\n\n```\n  var chewToys = puppies.map(puppy => ({}))\n```\n\n#### this\n\n箭头函数还有一个 特点\n\n- 它 __没有自己的this__ 值，箭头函数内的this值 __继承自外围作用域__。\n\n```\n  {\n    ...\n    addAll: function addAll(pieces) {\n      var self = this;\n\n      _.each(pieces, function (piece) {\n        self.add(piece);\n      });\n    },\n    ...\n  }\n```\n在上面这个对象的 addAll 方法中， 有一个 匿名函数，这个匿名函数是拿不到 外部函数的 this 的 ( 内部 上下文，拿不到 外部的 this, arguments )，而我们需要用 this.add 这个 方法，所以 我们，外部能拿到 this 的地方，将 this 赋值给另一个 内部函数可以访问到 变量, 然后我们在内部函数通过访问这个变量来访问 this.add 方法。\n\n__但是用 箭头函数 就不用这么麻烦了。__\n\n```\n  // ES6\n   {\n     ...\n     addAll: function addAll(pieces) {\n       _.each(pieces,  piece => this.add(piece));\n     },\n     ...\n   }\n```\n\n在这里 __addAll__ 方法先从它的 __调用者__处获取了this值，然后由于内部函数是一个 __箭头函数__，所以它继承了 __外围作用域__的this值 ( 即 addAll )。\n\n#### 使用 call 或 apply 调用\n\n- 由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并 __没有什么影响__\n-\n```\n  var adder = {\n    base : 1,\n\n    add : function(a) {\n      var f = v => v + this.base;\n      return f(a);\n    },\n\n    addThruCall: function(a) {\n      var f = v => v + this.base;\n      var b = {\n        base : 2\n      };\n\n      return f.call(b, a);\n    }\n  };\n\n  console.log(adder.add(1));         // 输出 2\n  console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）\n```\n\n#### 不绑定 arguments\n- 箭头函数还有一个特性， 不绑定 arguments，箭头函数不会在其内部暴露出  arguments 对象\n- 若在函数中将 arguments 赋值给某一变量，则这个变量将会指向，这个箭头函数所在的作用域一个 名为 arguments 的值，如果没有的话就返货 undefined\n\n```\n  var arguments = 42;\n  var arr = () => arguments;\n\n  arr(); // 42\n\n  function foo() {\n    var f = () => arguments[0]; // foo's implicit arguments binding\n    return f(2);\n  }\n\n  foo(1); // 1\n```\n\n上面箭头函数的 arguments 是指向，外部函数的 arguments, 而不是自身的。\n\n- 虽然箭头函数没有自己的 arguments 对象，但是大多数情形下，rest参数可以给出一个解决方案\n\n  ```\n  function foo() {\n    var f = (...args) => args[0];\n    return f(2);\n  }\n\n  foo(1); // 2\n```\n#### Parsing order ( 这个不理解 @ @ )\n\nThe arrow in an arrow function is not an operator, but arrow functions have special parsing rules that interact differently with (operator precedence)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence], compared to a regular function.\n\n```\n  let callback;\n\n  callback = callback || function() {}; // ok\n  callback = callback || () => {}; // SyntaxError: invalid arrow-function arguments\n  callback = callback || (() => {});    // ok\n```\n\n####  箭头函数的运用的地方\n\n在ES6中，你需要遵循以下规则：\n\n- 通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。\n- 其它情况全都使用箭头函数。\n\n{% blockquote %}\n\n参考：\n\n[深入浅出ES6（七）：箭头函数 Arrow Functions\n](http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions/)\n\n[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n\n{% endblockquote %}\n","source":"_posts/es6-arrowfunction.md","raw":"---\ntitle: 箭头函数\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- ES6\nauto_spacing: true\n---\n\n#### 基本定义\n```\n  // ES5\n  var selected = allJobs.filter(function (job) {\n    return job.isSelected();\n  });\n\n  // ES6\n  var selected = allJobs.filter(job => job.isSelected());\n```\n\n- 当函数只有  __一个参数__ 的时候，可以使用新标准中的箭头函数，它的语法非常简单：标识符=>表达式。你无需输入function和return，一些小括号、大括号以及 __分号__ 也可以省略。\n\n<!-- more -->\n\n- 如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用 __小括号__  包裹 __参数list__。\n\n```\n  // ES5\n    var total = values.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  // ES6\n    var total = values.reduce((a, b) => a + b, 0);\n```\n\n如果函数逻辑稍微复杂一些，不能一行代码就完成的。怎么办呢？\n\n- 除表达式外，箭头函数还可以包含一个 __块语句__\n\n```\n  // ES5\n  $(\"#confetti-btn\").click(function (event) {\n    playTrumpet();\n    fireConfettiCannon();\n  });\n```\n这是它们在ES6中看起来的样子：\n```\n  // ES6\n  $(\"#confetti-btn\").click(event => {\n    playTrumpet();\n     fireConfettiCannon();\n  });\n```\n\n#### 返回对象字面量\n##### 注意！！这里有个坑\n\n 使用了块语句( { } ) 的箭头函数不会自动返回值，你需要使用return语句将所需值返回。\n\n 这样有什么问题呢？\n\n```\n   // 为与你玩耍的每一个小狗创建一个新的空对象\n   var chewToys = puppies.map(puppy => {});   // 这样写会报Bug！\n```\n你以为 你为每一个小狗创建一个新的空对象，但是 其实根本不是，这样是 __会报错__ 的,为什么呢?\n\n因为箭头函数还可以包含一个 __块语句__！！！\n\nES6中的规则是，__紧随__ 箭头的 { 被解析为块的开始，而不是对象的开始。因此，puppy => {} 这段代码就被解析为没有任何行为并返回undefined的箭头函数 !!\n\n所以\n\n返回对象字面量时\n\n必须要用 小括号将返回的对象 括起来！！\n--\n\n```\n  var chewToys = puppies.map(puppy => ({}))\n```\n\n#### this\n\n箭头函数还有一个 特点\n\n- 它 __没有自己的this__ 值，箭头函数内的this值 __继承自外围作用域__。\n\n```\n  {\n    ...\n    addAll: function addAll(pieces) {\n      var self = this;\n\n      _.each(pieces, function (piece) {\n        self.add(piece);\n      });\n    },\n    ...\n  }\n```\n在上面这个对象的 addAll 方法中， 有一个 匿名函数，这个匿名函数是拿不到 外部函数的 this 的 ( 内部 上下文，拿不到 外部的 this, arguments )，而我们需要用 this.add 这个 方法，所以 我们，外部能拿到 this 的地方，将 this 赋值给另一个 内部函数可以访问到 变量, 然后我们在内部函数通过访问这个变量来访问 this.add 方法。\n\n__但是用 箭头函数 就不用这么麻烦了。__\n\n```\n  // ES6\n   {\n     ...\n     addAll: function addAll(pieces) {\n       _.each(pieces,  piece => this.add(piece));\n     },\n     ...\n   }\n```\n\n在这里 __addAll__ 方法先从它的 __调用者__处获取了this值，然后由于内部函数是一个 __箭头函数__，所以它继承了 __外围作用域__的this值 ( 即 addAll )。\n\n#### 使用 call 或 apply 调用\n\n- 由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并 __没有什么影响__\n-\n```\n  var adder = {\n    base : 1,\n\n    add : function(a) {\n      var f = v => v + this.base;\n      return f(a);\n    },\n\n    addThruCall: function(a) {\n      var f = v => v + this.base;\n      var b = {\n        base : 2\n      };\n\n      return f.call(b, a);\n    }\n  };\n\n  console.log(adder.add(1));         // 输出 2\n  console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）\n```\n\n#### 不绑定 arguments\n- 箭头函数还有一个特性， 不绑定 arguments，箭头函数不会在其内部暴露出  arguments 对象\n- 若在函数中将 arguments 赋值给某一变量，则这个变量将会指向，这个箭头函数所在的作用域一个 名为 arguments 的值，如果没有的话就返货 undefined\n\n```\n  var arguments = 42;\n  var arr = () => arguments;\n\n  arr(); // 42\n\n  function foo() {\n    var f = () => arguments[0]; // foo's implicit arguments binding\n    return f(2);\n  }\n\n  foo(1); // 1\n```\n\n上面箭头函数的 arguments 是指向，外部函数的 arguments, 而不是自身的。\n\n- 虽然箭头函数没有自己的 arguments 对象，但是大多数情形下，rest参数可以给出一个解决方案\n\n  ```\n  function foo() {\n    var f = (...args) => args[0];\n    return f(2);\n  }\n\n  foo(1); // 2\n```\n#### Parsing order ( 这个不理解 @ @ )\n\nThe arrow in an arrow function is not an operator, but arrow functions have special parsing rules that interact differently with (operator precedence)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence], compared to a regular function.\n\n```\n  let callback;\n\n  callback = callback || function() {}; // ok\n  callback = callback || () => {}; // SyntaxError: invalid arrow-function arguments\n  callback = callback || (() => {});    // ok\n```\n\n####  箭头函数的运用的地方\n\n在ES6中，你需要遵循以下规则：\n\n- 通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。\n- 其它情况全都使用箭头函数。\n\n{% blockquote %}\n\n参考：\n\n[深入浅出ES6（七）：箭头函数 Arrow Functions\n](http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions/)\n\n[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n\n{% endblockquote %}\n","slug":"es6-arrowfunction","published":1,"date":"2016-12-01T11:55:08.000Z","updated":"2016-12-05T06:19:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwqo03qo0000lvralr0q162t","content":"<h4 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">var selected = allJobs.filter(function (job) &#123;</div><div class=\"line\">  return job.isSelected();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// ES6</div><div class=\"line\">var selected = allJobs.filter(job =&gt; job.isSelected());</div></pre></td></tr></table></figure>\n<ul>\n<li>当函数只有  <strong>一个参数</strong> 的时候，可以使用新标准中的箭头函数，它的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及 <strong>分号</strong> 也可以省略。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用 <strong>小括号</strong>  包裹 <strong>参数list</strong>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">  var total = values.reduce(function (a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">// ES6</div><div class=\"line\">  var total = values.reduce((a, b) =&gt; a + b, 0);</div></pre></td></tr></table></figure>\n<p>如果函数逻辑稍微复杂一些，不能一行代码就完成的。怎么办呢？</p>\n<ul>\n<li>除表达式外，箭头函数还可以包含一个 <strong>块语句</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">$(&quot;#confetti-btn&quot;).click(function (event) &#123;</div><div class=\"line\">  playTrumpet();</div><div class=\"line\">  fireConfettiCannon();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这是它们在ES6中看起来的样子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES6</div><div class=\"line\">$(&quot;#confetti-btn&quot;).click(event =&gt; &#123;</div><div class=\"line\">  playTrumpet();</div><div class=\"line\">   fireConfettiCannon();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"返回对象字面量\"><a href=\"#返回对象字面量\" class=\"headerlink\" title=\"返回对象字面量\"></a>返回对象字面量</h4><h5 id=\"注意！！这里有个坑\"><a href=\"#注意！！这里有个坑\" class=\"headerlink\" title=\"注意！！这里有个坑\"></a>注意！！这里有个坑</h5><p> 使用了块语句( { } ) 的箭头函数不会自动返回值，你需要使用return语句将所需值返回。</p>\n<p> 这样有什么问题呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 为与你玩耍的每一个小狗创建一个新的空对象</div><div class=\"line\">var chewToys = puppies.map(puppy =&gt; &#123;&#125;);   // 这样写会报Bug！</div></pre></td></tr></table></figure>\n<p>你以为 你为每一个小狗创建一个新的空对象，但是 其实根本不是，这样是 <strong>会报错</strong> 的,为什么呢?</p>\n<p>因为箭头函数还可以包含一个 <strong>块语句</strong>！！！</p>\n<p>ES6中的规则是，<strong>紧随</strong> 箭头的 { 被解析为块的开始，而不是对象的开始。因此，puppy =&gt; {} 这段代码就被解析为没有任何行为并返回undefined的箭头函数 !!</p>\n<p>所以</p>\n<p>返回对象字面量时</p>\n<h2 id=\"必须要用-小括号将返回的对象-括起来！！\"><a href=\"#必须要用-小括号将返回的对象-括起来！！\" class=\"headerlink\" title=\"必须要用 小括号将返回的对象 括起来！！\"></a>必须要用 小括号将返回的对象 括起来！！</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var chewToys = puppies.map(puppy =&gt; (&#123;&#125;))</div></pre></td></tr></table></figure>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>箭头函数还有一个 特点</p>\n<ul>\n<li>它 <strong>没有自己的this</strong> 值，箭头函数内的this值 <strong>继承自外围作用域</strong>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  addAll: function addAll(pieces) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\"></div><div class=\"line\">    _.each(pieces, function (piece) &#123;</div><div class=\"line\">      self.add(piece);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面这个对象的 addAll 方法中， 有一个 匿名函数，这个匿名函数是拿不到 外部函数的 this 的 ( 内部 上下文，拿不到 外部的 this, arguments )，而我们需要用 this.add 这个 方法，所以 我们，外部能拿到 this 的地方，将 this 赋值给另一个 内部函数可以访问到 变量, 然后我们在内部函数通过访问这个变量来访问 this.add 方法。</p>\n<p><strong>但是用 箭头函数 就不用这么麻烦了。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES6</div><div class=\"line\"> &#123;</div><div class=\"line\">   ...</div><div class=\"line\">   addAll: function addAll(pieces) &#123;</div><div class=\"line\">     _.each(pieces,  piece =&gt; this.add(piece));</div><div class=\"line\">   &#125;,</div><div class=\"line\">   ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在这里 <strong>addAll</strong> 方法先从它的 <strong>调用者</strong>处获取了this值，然后由于内部函数是一个 <strong>箭头函数</strong>，所以它继承了 <strong>外围作用域</strong>的this值 ( 即 addAll )。</p>\n<h4 id=\"使用-call-或-apply-调用\"><a href=\"#使用-call-或-apply-调用\" class=\"headerlink\" title=\"使用 call 或 apply 调用\"></a>使用 call 或 apply 调用</h4><ul>\n<li>由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并 <strong>没有什么影响</strong><br>-<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">var adder = &#123;</div><div class=\"line\">  base : 1,</div><div class=\"line\"></div><div class=\"line\">  add : function(a) &#123;</div><div class=\"line\">    var f = v =&gt; v + this.base;</div><div class=\"line\">    return f(a);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  addThruCall: function(a) &#123;</div><div class=\"line\">    var f = v =&gt; v + this.base;</div><div class=\"line\">    var b = &#123;</div><div class=\"line\">      base : 2</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    return f.call(b, a);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(adder.add(1));         // 输出 2</div><div class=\"line\">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"不绑定-arguments\"><a href=\"#不绑定-arguments\" class=\"headerlink\" title=\"不绑定 arguments\"></a>不绑定 arguments</h4><ul>\n<li>箭头函数还有一个特性， 不绑定 arguments，箭头函数不会在其内部暴露出  arguments 对象</li>\n<li>若在函数中将 arguments 赋值给某一变量，则这个变量将会指向，这个箭头函数所在的作用域一个 名为 arguments 的值，如果没有的话就返货 undefined</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arguments = 42;</div><div class=\"line\">var arr = () =&gt; arguments;</div><div class=\"line\"></div><div class=\"line\">arr(); // 42</div><div class=\"line\"></div><div class=\"line\">function foo() &#123;</div><div class=\"line\">  var f = () =&gt; arguments[0]; // foo&apos;s implicit arguments binding</div><div class=\"line\">  return f(2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(1); // 1</div></pre></td></tr></table></figure>\n<p>上面箭头函数的 arguments 是指向，外部函数的 arguments, 而不是自身的。</p>\n<ul>\n<li><p>虽然箭头函数没有自己的 arguments 对象，但是大多数情形下，rest参数可以给出一个解决方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">  var f = (...args) =&gt; args[0];</div><div class=\"line\">  return f(2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(1); // 2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Parsing-order-这个不理解\"><a href=\"#Parsing-order-这个不理解\" class=\"headerlink\" title=\"Parsing order ( 这个不理解 @ @ )\"></a>Parsing order ( 这个不理解 @ @ )</h4><p>The arrow in an arrow function is not an operator, but arrow functions have special parsing rules that interact differently with (operator precedence)[<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a>], compared to a regular function.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let callback;</div><div class=\"line\"></div><div class=\"line\">callback = callback || function() &#123;&#125;; // ok</div><div class=\"line\">callback = callback || () =&gt; &#123;&#125;; // SyntaxError: invalid arrow-function arguments</div><div class=\"line\">callback = callback || (() =&gt; &#123;&#125;);    // ok</div></pre></td></tr></table></figure>\n<h4 id=\"箭头函数的运用的地方\"><a href=\"#箭头函数的运用的地方\" class=\"headerlink\" title=\"箭头函数的运用的地方\"></a>箭头函数的运用的地方</h4><p>在ES6中，你需要遵循以下规则：</p>\n<ul>\n<li>通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。</li>\n<li>其它情况全都使用箭头函数。</li>\n</ul>\n<blockquote><p>参考：</p>\n<p><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions/\" target=\"_blank\" rel=\"external\">深入浅出ES6（七）：箭头函数 Arrow Functions\n</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"external\">箭头函数</a></p>\n</blockquote>\n","excerpt":"<h4 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">var selected = allJobs.filter(function (job) &#123;</div><div class=\"line\">  return job.isSelected();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// ES6</div><div class=\"line\">var selected = allJobs.filter(job =&gt; job.isSelected());</div></pre></td></tr></table></figure>\n<ul>\n<li>当函数只有  <strong>一个参数</strong> 的时候，可以使用新标准中的箭头函数，它的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及 <strong>分号</strong> 也可以省略。</li>\n</ul>","more":"<ul>\n<li>如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用 <strong>小括号</strong>  包裹 <strong>参数list</strong>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">  var total = values.reduce(function (a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">// ES6</div><div class=\"line\">  var total = values.reduce((a, b) =&gt; a + b, 0);</div></pre></td></tr></table></figure>\n<p>如果函数逻辑稍微复杂一些，不能一行代码就完成的。怎么办呢？</p>\n<ul>\n<li>除表达式外，箭头函数还可以包含一个 <strong>块语句</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES5</div><div class=\"line\">$(&quot;#confetti-btn&quot;).click(function (event) &#123;</div><div class=\"line\">  playTrumpet();</div><div class=\"line\">  fireConfettiCannon();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这是它们在ES6中看起来的样子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES6</div><div class=\"line\">$(&quot;#confetti-btn&quot;).click(event =&gt; &#123;</div><div class=\"line\">  playTrumpet();</div><div class=\"line\">   fireConfettiCannon();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"返回对象字面量\"><a href=\"#返回对象字面量\" class=\"headerlink\" title=\"返回对象字面量\"></a>返回对象字面量</h4><h5 id=\"注意！！这里有个坑\"><a href=\"#注意！！这里有个坑\" class=\"headerlink\" title=\"注意！！这里有个坑\"></a>注意！！这里有个坑</h5><p> 使用了块语句( { } ) 的箭头函数不会自动返回值，你需要使用return语句将所需值返回。</p>\n<p> 这样有什么问题呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 为与你玩耍的每一个小狗创建一个新的空对象</div><div class=\"line\">var chewToys = puppies.map(puppy =&gt; &#123;&#125;);   // 这样写会报Bug！</div></pre></td></tr></table></figure>\n<p>你以为 你为每一个小狗创建一个新的空对象，但是 其实根本不是，这样是 <strong>会报错</strong> 的,为什么呢?</p>\n<p>因为箭头函数还可以包含一个 <strong>块语句</strong>！！！</p>\n<p>ES6中的规则是，<strong>紧随</strong> 箭头的 { 被解析为块的开始，而不是对象的开始。因此，puppy =&gt; {} 这段代码就被解析为没有任何行为并返回undefined的箭头函数 !!</p>\n<p>所以</p>\n<p>返回对象字面量时</p>\n<h2 id=\"必须要用-小括号将返回的对象-括起来！！\"><a href=\"#必须要用-小括号将返回的对象-括起来！！\" class=\"headerlink\" title=\"必须要用 小括号将返回的对象 括起来！！\"></a>必须要用 小括号将返回的对象 括起来！！</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var chewToys = puppies.map(puppy =&gt; (&#123;&#125;))</div></pre></td></tr></table></figure>\n<h4 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h4><p>箭头函数还有一个 特点</p>\n<ul>\n<li>它 <strong>没有自己的this</strong> 值，箭头函数内的this值 <strong>继承自外围作用域</strong>。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  addAll: function addAll(pieces) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\"></div><div class=\"line\">    _.each(pieces, function (piece) &#123;</div><div class=\"line\">      self.add(piece);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面这个对象的 addAll 方法中， 有一个 匿名函数，这个匿名函数是拿不到 外部函数的 this 的 ( 内部 上下文，拿不到 外部的 this, arguments )，而我们需要用 this.add 这个 方法，所以 我们，外部能拿到 this 的地方，将 this 赋值给另一个 内部函数可以访问到 变量, 然后我们在内部函数通过访问这个变量来访问 this.add 方法。</p>\n<p><strong>但是用 箭头函数 就不用这么麻烦了。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ES6</div><div class=\"line\"> &#123;</div><div class=\"line\">   ...</div><div class=\"line\">   addAll: function addAll(pieces) &#123;</div><div class=\"line\">     _.each(pieces,  piece =&gt; this.add(piece));</div><div class=\"line\">   &#125;,</div><div class=\"line\">   ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在这里 <strong>addAll</strong> 方法先从它的 <strong>调用者</strong>处获取了this值，然后由于内部函数是一个 <strong>箭头函数</strong>，所以它继承了 <strong>外围作用域</strong>的this值 ( 即 addAll )。</p>\n<h4 id=\"使用-call-或-apply-调用\"><a href=\"#使用-call-或-apply-调用\" class=\"headerlink\" title=\"使用 call 或 apply 调用\"></a>使用 call 或 apply 调用</h4><ul>\n<li>由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并 <strong>没有什么影响</strong><br>-<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">var adder = &#123;</div><div class=\"line\">  base : 1,</div><div class=\"line\"></div><div class=\"line\">  add : function(a) &#123;</div><div class=\"line\">    var f = v =&gt; v + this.base;</div><div class=\"line\">    return f(a);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  addThruCall: function(a) &#123;</div><div class=\"line\">    var f = v =&gt; v + this.base;</div><div class=\"line\">    var b = &#123;</div><div class=\"line\">      base : 2</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    return f.call(b, a);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(adder.add(1));         // 输出 2</div><div class=\"line\">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"不绑定-arguments\"><a href=\"#不绑定-arguments\" class=\"headerlink\" title=\"不绑定 arguments\"></a>不绑定 arguments</h4><ul>\n<li>箭头函数还有一个特性， 不绑定 arguments，箭头函数不会在其内部暴露出  arguments 对象</li>\n<li>若在函数中将 arguments 赋值给某一变量，则这个变量将会指向，这个箭头函数所在的作用域一个 名为 arguments 的值，如果没有的话就返货 undefined</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arguments = 42;</div><div class=\"line\">var arr = () =&gt; arguments;</div><div class=\"line\"></div><div class=\"line\">arr(); // 42</div><div class=\"line\"></div><div class=\"line\">function foo() &#123;</div><div class=\"line\">  var f = () =&gt; arguments[0]; // foo&apos;s implicit arguments binding</div><div class=\"line\">  return f(2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(1); // 1</div></pre></td></tr></table></figure>\n<p>上面箭头函数的 arguments 是指向，外部函数的 arguments, 而不是自身的。</p>\n<ul>\n<li><p>虽然箭头函数没有自己的 arguments 对象，但是大多数情形下，rest参数可以给出一个解决方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">  var f = (...args) =&gt; args[0];</div><div class=\"line\">  return f(2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(1); // 2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Parsing-order-这个不理解\"><a href=\"#Parsing-order-这个不理解\" class=\"headerlink\" title=\"Parsing order ( 这个不理解 @ @ )\"></a>Parsing order ( 这个不理解 @ @ )</h4><p>The arrow in an arrow function is not an operator, but arrow functions have special parsing rules that interact differently with (operator precedence)[<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a>], compared to a regular function.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let callback;</div><div class=\"line\"></div><div class=\"line\">callback = callback || function() &#123;&#125;; // ok</div><div class=\"line\">callback = callback || () =&gt; &#123;&#125;; // SyntaxError: invalid arrow-function arguments</div><div class=\"line\">callback = callback || (() =&gt; &#123;&#125;);    // ok</div></pre></td></tr></table></figure>\n<h4 id=\"箭头函数的运用的地方\"><a href=\"#箭头函数的运用的地方\" class=\"headerlink\" title=\"箭头函数的运用的地方\"></a>箭头函数的运用的地方</h4><p>在ES6中，你需要遵循以下规则：</p>\n<ul>\n<li>通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。</li>\n<li>其它情况全都使用箭头函数。</li>\n</ul>\n<blockquote><p>参考：</p>\n<p><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions/\">深入浅出ES6（七）：箭头函数 Arrow Functions\n</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a></p>\n</blockquote>"},{"title":"promise","auto_spacing":true,"_content":"\n\n### 定义\n\n所谓 Promise, 简单说就是一个容器。里面保存着某个 __未来__才会 _结束的事件_ ( 通常是一个异步操作 ) 的 __结果__。\n\n- Promise 对象是一个 __返回值的代理__，这个返回值在 promise 对象创建时未必已知。\n\n- 它允许你为异步操作的成功返回值 ／ 失败信息指定处理方法。\n\n- 这使异步方法可以像同步方法那样返回值： 异步方法会返回一个包含原返回值的 promise 对象来替代原返回值\n\n<!-- more -->\nPromise 对象有以下几种状态：\n\n- pending\n- fufilled 成功的操作\n- rejected 失败的操作\n\npending 可转换带着 __一个成功值的 fulfilled 状态__,\n也可变成一个 __带着失败信息的 rejected 状态__\n\n- 当状态发生转换的时候， promise.then 绑定的方法就会被调用 \n\n- 当绑定方法时， promise 对象已经处于 fulfilled / rejected 状态，则相应的方法会被 __立刻调用__ \n\n- 一个 promise 对象处在 fulfilled ／ rejected 状态时它也可以被称为 settled  状态。 ( resolved 表示 promise 对象处于 settled  状态，或 promise 对象被 __锁定__在调用链中 ) \n\n- 因为 Promise.prototype.then 和 Promise.prototype.catch 方法 __返回 promises  对象__，所以它们可以被链式调用\n\n\n\n\n\n### 语法\n\nnew Promise( executor );\nnew Promise(function(resolve, reject) {...} );\n\n参数：\nexecutor\n\n- 函数\n- 默认有 resolve, reject 两个参数\n- 在创建 Promise 对象的时候会 __立即执行__ ( 在 Promise 构造函数返回 Promise 对象之前就会被执行 )\n- 调用 resolve 和 reject 函数会分别触发  promise 的成功或者 失败。\n- 这个函数参数 通常被用来执行一些异步操作，操作完成后可以选择 调用 resolve 来触发 promise 的成功状态，或者，在出现错误的时候调用 reject 函数来触发 promise 的失败。\n- \n### 属性\n\n- Promise.prototype 表示 Promise 构造器的原型\n- Promise.length 长度：1 ( 构造器参数数目 )\n\n### 方法\n\n- Promise.all( iterable )\n\n  + 当 iterable 里的所有 promise 对象都成功的时候才会触发成功 \n  \n  +  任何一个 iterable 里的 promise 失败都会立刻触发该 promise 对象的失败 \n  \n  + 触发成功的状态后，会把一个 包含 iterable 里 __所有__ promise __返回值__ 的 __数组__作为成功回调的返回值 (顺序跟 iterable 的__顺序保持一致__)。\n\n  + 触发失败的状态后, 会 __返回__ iterable 中__第一个触发失败的 promise 对象__ 的 __错误信息__( 作为它的错误信息 ) \n\n- Promise.race( iterable )\n当 iterable 参数里的任意一个 promise 被成功或失败后，\n父 promise 也会马上用子 promise 的成功返回值 或失败详情作为参数调用 父 promise 绑定的相应句柄, 并返回该 promise 对象。\n\nNOTE !!! ： __这个是 promises ---> Promise.all  实现的原理__\n\n- Promise.reject( reason )\n\n返回一个 因为 reason 而被拒绝 (rejected) 的 Promise 对象\n\n- Promise.resolve( value )\n\n  + Returns a _Promise_ object that is resolved with the given value .  ( fulfill )\n\n  + 如果该 value 为 thenable ( 带有 then 方法 )\n      \n      - 返回的 Promise 对象会 \"跟随\" 这个value 并采用这个 value 的最终状态 \n \n  +  value 没有带 then 方法,  返回的 Promise will be fulfilled with the value\n  \n  +  如果你不知道 value 是不是一个 promise, Promise.resolve( value )  it instead and work with the return value as a promise. \n\n👆没有理解!! 看例子。。\n--\n\n### Promise prototype\n#### 属性\n\n- Promise.prototype.constructor\n\n返回 the function that created an instance's prototype.\n这个函数默认为是 _Promise function_ \n\n#### 方法\n\n- Promise.prototype.catch( onRejected )\n\n    + 向当前promise 添加 处理 rejection 的一个回调函数 onRejected， \n\n    + 如果这个回调函数被调用，将返回一个_ 新的 promise_\n    \n    + 这个 _新的 promise_ 会 resolve ( 解析 ) 这个回调函数的 value.\n    \n    + 如果 这个 _新的promise_ 的状态为 fulfilled, 就会被 resolve 它最原始的 fulfilled 状态\n    \n-  Promise.prototype.then(onFulfilles, onRejected )\n    \n    + 向当前的 promise 添加处理 fulfillment and rejection 的函数 onFulfiles, onRejected\n    \n    + 并且 ( 这个 then 函数 ) 返回一个_新的 promise _\n    \n    + 这个_新的 promise_ 解析 (resolving ) 处理函数 ( onFufilled / onRejected ) 的 返回值\n    \n    + 或者 如果这个 promise 没有被处理 , _这个新的 promise_ 解析成 它原来的 settled 值。 ( 比如说，相关的处理程序 onFulfilled 或者 onRejected 不是一个函数 )\n\n```\nlet promiseCount = 0;\n\n// 执行三次函数 ( 三个 promise )\ntestPromise();\ntestPromise();\ntestPromise();\n\n\nfunction testPromise() {\n  // 将全局的 count + 1 并赋值给自己的 小count\n  let thisPromiseCount = ++promiseCount;\n\n  let log = document.getElementById('log');\n  \n  log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Start (<small> 同步数据开始啦~~ </small>)<br/>` );\n  \n  // 声明一个 promise 对象\n  let p1 = new Promise(\n    // 立刻开始执行\n    function(resolve, reject) {\n      \n      log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Started (<small> promise 异步数据 开始啦！(-promise-) </small>)<br/>`);\n      \n      // 设置 *** 后 resolve, 传入 小count 作为参数\n      window.setTimeout(\n        function() {\n          resolve(thisPromiseCount);\n          // reject(thisPromiseCount);\n        }, Math.random()*2000 + 1000);\n    \n    }\n  );\n  \n\n  p1.then(\n    \n    function(val) {\n      log.insertAdjacentHTML('beforeend', `( ${val} ) made (<small> promise 异步数据 快完了 (-then-) </small>)<br/>`);\n    }\n\n  )\n  .catch(\n    \n    function(reason) {\n      log.insertAdjacentHTML( 'beforeend' ,`我被 拒绝 了！！！ ಥ_ಥ  因为 ${reason} `);\n    }\n \n  );\n  \n  log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Promise fulfilled!  (<small> 同步数据 最后～  </small>)<br/>`);\n}\n```\n\n结果：\n当 resolve 的时候:\n\n![](http://img.jackon.me/promise-resolve.png)\n\n当 reject 的时候: \n![](http://img.jackon.me/promise-reject.png)\n\n-- \n\n### 补充:\n\nelement.insertAdjacentHTML\n\n##### 概念：\nelement.insertAdjacentHTML()\n  - 将指定的文本解析为 _HTML 或 XML_\n  - 并将生成的节点 __插入__到指定位置的 __DOM__ 树中。\n  - 它不会__重新__解析它正在使用的元素, 因此它不会破环元素内的现有元素。这避免了 __额外__的序列化步骤，使其比直接 innerHTML __操作更快__\n\n##### 语法\n\nelement.insertAdjacentHTML( position, text );\n\n- position 是想对于 元素 ( element ) 的 __位置__, 并且必须是以下 _字符串_之一:\n\n  - 'beforebegin' 元素自身的前面\n  - 'afterbegin' 插入元素内部的第一个子节点之前\n  - 'beforeend' 插入元素内部的最后一个子节点之后\n  - 'afterend' 元素自身的后面\n\n- text \n要被解析成 HTML / XML, 并插入到 DOM 树中的字符\n\n位置名称的可视化：\n--\n```\n<!-- beforebegin --> \n<p> \n<!-- afterbegin --> \nfoo \n<!-- beforeend --> \n</p> \n<!-- afterend -->\n```\n<br/>\n<br/>\n\n\n{% blockquote %}\n参考：\n[MDN: Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n[MDN: element.insertAdjacentHTML](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML)\n\n{% endblockquote %}\n\n还未看:\n[We have a problem with promises](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)\n\n","source":"_posts/promise.md","raw":"---\ntitle: promise\ncategories:\n- 编程\ntags:\n- promise\n- ES6\n- 抄抄抄\nauto_spacing: true\n---\n\n\n### 定义\n\n所谓 Promise, 简单说就是一个容器。里面保存着某个 __未来__才会 _结束的事件_ ( 通常是一个异步操作 ) 的 __结果__。\n\n- Promise 对象是一个 __返回值的代理__，这个返回值在 promise 对象创建时未必已知。\n\n- 它允许你为异步操作的成功返回值 ／ 失败信息指定处理方法。\n\n- 这使异步方法可以像同步方法那样返回值： 异步方法会返回一个包含原返回值的 promise 对象来替代原返回值\n\n<!-- more -->\nPromise 对象有以下几种状态：\n\n- pending\n- fufilled 成功的操作\n- rejected 失败的操作\n\npending 可转换带着 __一个成功值的 fulfilled 状态__,\n也可变成一个 __带着失败信息的 rejected 状态__\n\n- 当状态发生转换的时候， promise.then 绑定的方法就会被调用 \n\n- 当绑定方法时， promise 对象已经处于 fulfilled / rejected 状态，则相应的方法会被 __立刻调用__ \n\n- 一个 promise 对象处在 fulfilled ／ rejected 状态时它也可以被称为 settled  状态。 ( resolved 表示 promise 对象处于 settled  状态，或 promise 对象被 __锁定__在调用链中 ) \n\n- 因为 Promise.prototype.then 和 Promise.prototype.catch 方法 __返回 promises  对象__，所以它们可以被链式调用\n\n\n\n\n\n### 语法\n\nnew Promise( executor );\nnew Promise(function(resolve, reject) {...} );\n\n参数：\nexecutor\n\n- 函数\n- 默认有 resolve, reject 两个参数\n- 在创建 Promise 对象的时候会 __立即执行__ ( 在 Promise 构造函数返回 Promise 对象之前就会被执行 )\n- 调用 resolve 和 reject 函数会分别触发  promise 的成功或者 失败。\n- 这个函数参数 通常被用来执行一些异步操作，操作完成后可以选择 调用 resolve 来触发 promise 的成功状态，或者，在出现错误的时候调用 reject 函数来触发 promise 的失败。\n- \n### 属性\n\n- Promise.prototype 表示 Promise 构造器的原型\n- Promise.length 长度：1 ( 构造器参数数目 )\n\n### 方法\n\n- Promise.all( iterable )\n\n  + 当 iterable 里的所有 promise 对象都成功的时候才会触发成功 \n  \n  +  任何一个 iterable 里的 promise 失败都会立刻触发该 promise 对象的失败 \n  \n  + 触发成功的状态后，会把一个 包含 iterable 里 __所有__ promise __返回值__ 的 __数组__作为成功回调的返回值 (顺序跟 iterable 的__顺序保持一致__)。\n\n  + 触发失败的状态后, 会 __返回__ iterable 中__第一个触发失败的 promise 对象__ 的 __错误信息__( 作为它的错误信息 ) \n\n- Promise.race( iterable )\n当 iterable 参数里的任意一个 promise 被成功或失败后，\n父 promise 也会马上用子 promise 的成功返回值 或失败详情作为参数调用 父 promise 绑定的相应句柄, 并返回该 promise 对象。\n\nNOTE !!! ： __这个是 promises ---> Promise.all  实现的原理__\n\n- Promise.reject( reason )\n\n返回一个 因为 reason 而被拒绝 (rejected) 的 Promise 对象\n\n- Promise.resolve( value )\n\n  + Returns a _Promise_ object that is resolved with the given value .  ( fulfill )\n\n  + 如果该 value 为 thenable ( 带有 then 方法 )\n      \n      - 返回的 Promise 对象会 \"跟随\" 这个value 并采用这个 value 的最终状态 \n \n  +  value 没有带 then 方法,  返回的 Promise will be fulfilled with the value\n  \n  +  如果你不知道 value 是不是一个 promise, Promise.resolve( value )  it instead and work with the return value as a promise. \n\n👆没有理解!! 看例子。。\n--\n\n### Promise prototype\n#### 属性\n\n- Promise.prototype.constructor\n\n返回 the function that created an instance's prototype.\n这个函数默认为是 _Promise function_ \n\n#### 方法\n\n- Promise.prototype.catch( onRejected )\n\n    + 向当前promise 添加 处理 rejection 的一个回调函数 onRejected， \n\n    + 如果这个回调函数被调用，将返回一个_ 新的 promise_\n    \n    + 这个 _新的 promise_ 会 resolve ( 解析 ) 这个回调函数的 value.\n    \n    + 如果 这个 _新的promise_ 的状态为 fulfilled, 就会被 resolve 它最原始的 fulfilled 状态\n    \n-  Promise.prototype.then(onFulfilles, onRejected )\n    \n    + 向当前的 promise 添加处理 fulfillment and rejection 的函数 onFulfiles, onRejected\n    \n    + 并且 ( 这个 then 函数 ) 返回一个_新的 promise _\n    \n    + 这个_新的 promise_ 解析 (resolving ) 处理函数 ( onFufilled / onRejected ) 的 返回值\n    \n    + 或者 如果这个 promise 没有被处理 , _这个新的 promise_ 解析成 它原来的 settled 值。 ( 比如说，相关的处理程序 onFulfilled 或者 onRejected 不是一个函数 )\n\n```\nlet promiseCount = 0;\n\n// 执行三次函数 ( 三个 promise )\ntestPromise();\ntestPromise();\ntestPromise();\n\n\nfunction testPromise() {\n  // 将全局的 count + 1 并赋值给自己的 小count\n  let thisPromiseCount = ++promiseCount;\n\n  let log = document.getElementById('log');\n  \n  log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Start (<small> 同步数据开始啦~~ </small>)<br/>` );\n  \n  // 声明一个 promise 对象\n  let p1 = new Promise(\n    // 立刻开始执行\n    function(resolve, reject) {\n      \n      log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Started (<small> promise 异步数据 开始啦！(-promise-) </small>)<br/>`);\n      \n      // 设置 *** 后 resolve, 传入 小count 作为参数\n      window.setTimeout(\n        function() {\n          resolve(thisPromiseCount);\n          // reject(thisPromiseCount);\n        }, Math.random()*2000 + 1000);\n    \n    }\n  );\n  \n\n  p1.then(\n    \n    function(val) {\n      log.insertAdjacentHTML('beforeend', `( ${val} ) made (<small> promise 异步数据 快完了 (-then-) </small>)<br/>`);\n    }\n\n  )\n  .catch(\n    \n    function(reason) {\n      log.insertAdjacentHTML( 'beforeend' ,`我被 拒绝 了！！！ ಥ_ಥ  因为 ${reason} `);\n    }\n \n  );\n  \n  log.insertAdjacentHTML('beforeend', `( ${thisPromiseCount} ) Promise fulfilled!  (<small> 同步数据 最后～  </small>)<br/>`);\n}\n```\n\n结果：\n当 resolve 的时候:\n\n![](http://img.jackon.me/promise-resolve.png)\n\n当 reject 的时候: \n![](http://img.jackon.me/promise-reject.png)\n\n-- \n\n### 补充:\n\nelement.insertAdjacentHTML\n\n##### 概念：\nelement.insertAdjacentHTML()\n  - 将指定的文本解析为 _HTML 或 XML_\n  - 并将生成的节点 __插入__到指定位置的 __DOM__ 树中。\n  - 它不会__重新__解析它正在使用的元素, 因此它不会破环元素内的现有元素。这避免了 __额外__的序列化步骤，使其比直接 innerHTML __操作更快__\n\n##### 语法\n\nelement.insertAdjacentHTML( position, text );\n\n- position 是想对于 元素 ( element ) 的 __位置__, 并且必须是以下 _字符串_之一:\n\n  - 'beforebegin' 元素自身的前面\n  - 'afterbegin' 插入元素内部的第一个子节点之前\n  - 'beforeend' 插入元素内部的最后一个子节点之后\n  - 'afterend' 元素自身的后面\n\n- text \n要被解析成 HTML / XML, 并插入到 DOM 树中的字符\n\n位置名称的可视化：\n--\n```\n<!-- beforebegin --> \n<p> \n<!-- afterbegin --> \nfoo \n<!-- beforeend --> \n</p> \n<!-- afterend -->\n```\n<br/>\n<br/>\n\n\n{% blockquote %}\n参考：\n[MDN: Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n[MDN: element.insertAdjacentHTML](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML)\n\n{% endblockquote %}\n\n还未看:\n[We have a problem with promises](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)\n\n","slug":"promise","published":1,"date":"2016-12-15T05:56:49.000Z","updated":"2016-12-15T14:18:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwqo03qy0001lvrakque9u4r","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>所谓 Promise, 简单说就是一个容器。里面保存着某个 <strong>未来</strong>才会 <em>结束的事件</em> ( 通常是一个异步操作 ) 的 <strong>结果</strong>。</p>\n<ul>\n<li><p>Promise 对象是一个 <strong>返回值的代理</strong>，这个返回值在 promise 对象创建时未必已知。</p>\n</li>\n<li><p>它允许你为异步操作的成功返回值 ／ 失败信息指定处理方法。</p>\n</li>\n<li><p>这使异步方法可以像同步方法那样返回值： 异步方法会返回一个包含原返回值的 promise 对象来替代原返回值</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>Promise 对象有以下几种状态：</p>\n<ul>\n<li>pending</li>\n<li>fufilled 成功的操作</li>\n<li>rejected 失败的操作</li>\n</ul>\n<p>pending 可转换带着 <strong>一个成功值的 fulfilled 状态</strong>,<br>也可变成一个 <strong>带着失败信息的 rejected 状态</strong></p>\n<ul>\n<li><p>当状态发生转换的时候， promise.then 绑定的方法就会被调用 </p>\n</li>\n<li><p>当绑定方法时， promise 对象已经处于 fulfilled / rejected 状态，则相应的方法会被 <strong>立刻调用</strong> </p>\n</li>\n<li><p>一个 promise 对象处在 fulfilled ／ rejected 状态时它也可以被称为 settled  状态。 ( resolved 表示 promise 对象处于 settled  状态，或 promise 对象被 <strong>锁定</strong>在调用链中 ) </p>\n</li>\n<li><p>因为 Promise.prototype.then 和 Promise.prototype.catch 方法 <strong>返回 promises  对象</strong>，所以它们可以被链式调用</p>\n</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>new Promise( executor );<br>new Promise(function(resolve, reject) {…} );</p>\n<p>参数：<br>executor</p>\n<ul>\n<li>函数</li>\n<li>默认有 resolve, reject 两个参数</li>\n<li>在创建 Promise 对象的时候会 <strong>立即执行</strong> ( 在 Promise 构造函数返回 Promise 对象之前就会被执行 )</li>\n<li>调用 resolve 和 reject 函数会分别触发  promise 的成功或者 失败。</li>\n<li>这个函数参数 通常被用来执行一些异步操作，操作完成后可以选择 调用 resolve 来触发 promise 的成功状态，或者，在出现错误的时候调用 reject 函数来触发 promise 的失败。</li>\n<li><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3></li>\n<li><p>Promise.prototype 表示 Promise 构造器的原型</p>\n</li>\n<li>Promise.length 长度：1 ( 构造器参数数目 )</li>\n</ul>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><p>Promise.all( iterable )</p>\n<ul>\n<li><p>当 iterable 里的所有 promise 对象都成功的时候才会触发成功 </p>\n</li>\n<li><p>任何一个 iterable 里的 promise 失败都会立刻触发该 promise 对象的失败 </p>\n</li>\n<li><p>触发成功的状态后，会把一个 包含 iterable 里 <strong>所有</strong> promise <strong>返回值</strong> 的 <strong>数组</strong>作为成功回调的返回值 (顺序跟 iterable 的<strong>顺序保持一致</strong>)。</p>\n</li>\n<li><p>触发失败的状态后, 会 <strong>返回</strong> iterable 中<strong>第一个触发失败的 promise 对象</strong> 的 <strong>错误信息</strong>( 作为它的错误信息 ) </p>\n</li>\n</ul>\n</li>\n<li><p>Promise.race( iterable )<br>当 iterable 参数里的任意一个 promise 被成功或失败后，<br>父 promise 也会马上用子 promise 的成功返回值 或失败详情作为参数调用 父 promise 绑定的相应句柄, 并返回该 promise 对象。</p>\n</li>\n</ul>\n<p>NOTE !!! ： <strong>这个是 promises —&gt; Promise.all  实现的原理</strong></p>\n<ul>\n<li>Promise.reject( reason )</li>\n</ul>\n<p>返回一个 因为 reason 而被拒绝 (rejected) 的 Promise 对象</p>\n<ul>\n<li><p>Promise.resolve( value )</p>\n<ul>\n<li><p>Returns a <em>Promise</em> object that is resolved with the given value .  ( fulfill )</p>\n</li>\n<li><p>如果该 value 为 thenable ( 带有 then 方法 )</p>\n<ul>\n<li>返回的 Promise 对象会 “跟随” 这个value 并采用这个 value 的最终状态 </li>\n</ul>\n</li>\n<li><p>value 没有带 then 方法,  返回的 Promise will be fulfilled with the value</p>\n</li>\n<li><p>如果你不知道 value 是不是一个 promise, Promise.resolve( value )  it instead and work with the return value as a promise. </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"👆没有理解-看例子。。\"><a href=\"#👆没有理解-看例子。。\" class=\"headerlink\" title=\"👆没有理解!! 看例子。。\"></a>👆没有理解!! 看例子。。</h2><h3 id=\"Promise-prototype\"><a href=\"#Promise-prototype\" class=\"headerlink\" title=\"Promise prototype\"></a>Promise prototype</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>Promise.prototype.constructor</li>\n</ul>\n<p>返回 the function that created an instance’s prototype.<br>这个函数默认为是 <em>Promise function</em> </p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li><p>Promise.prototype.catch( onRejected )</p>\n<ul>\n<li><p>向当前promise 添加 处理 rejection 的一个回调函数 onRejected， </p>\n</li>\n<li><p>如果这个回调函数被调用，将返回一个<em> 新的 promise</em></p>\n</li>\n<li><p>这个 <em>新的 promise</em> 会 resolve ( 解析 ) 这个回调函数的 value.</p>\n</li>\n<li><p>如果 这个 <em>新的promise</em> 的状态为 fulfilled, 就会被 resolve 它最原始的 fulfilled 状态</p>\n</li>\n</ul>\n</li>\n<li><p>Promise.prototype.then(onFulfilles, onRejected )</p>\n<ul>\n<li><p>向当前的 promise 添加处理 fulfillment and rejection 的函数 onFulfiles, onRejected</p>\n</li>\n<li><p>并且 ( 这个 then 函数 ) 返回一个<em>新的 promise </em></p>\n</li>\n<li><p>这个<em>新的 promise</em> 解析 (resolving ) 处理函数 ( onFufilled / onRejected ) 的 返回值</p>\n</li>\n<li><p>或者 如果这个 promise 没有被处理 , <em>这个新的 promise</em> 解析成 它原来的 settled 值。 ( 比如说，相关的处理程序 onFulfilled 或者 onRejected 不是一个函数 )</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">let promiseCount = 0;</div><div class=\"line\"></div><div class=\"line\">// 执行三次函数 ( 三个 promise )</div><div class=\"line\">testPromise();</div><div class=\"line\">testPromise();</div><div class=\"line\">testPromise();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function testPromise() &#123;</div><div class=\"line\">  // 将全局的 count + 1 并赋值给自己的 小count</div><div class=\"line\">  let thisPromiseCount = ++promiseCount;</div><div class=\"line\"></div><div class=\"line\">  let log = document.getElementById(&apos;log&apos;);</div><div class=\"line\">  </div><div class=\"line\">  log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Start (&lt;small&gt; 同步数据开始啦~~ &lt;/small&gt;)&lt;br/&gt;` );</div><div class=\"line\">  </div><div class=\"line\">  // 声明一个 promise 对象</div><div class=\"line\">  let p1 = new Promise(</div><div class=\"line\">    // 立刻开始执行</div><div class=\"line\">    function(resolve, reject) &#123;</div><div class=\"line\">      </div><div class=\"line\">      log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Started (&lt;small&gt; promise 异步数据 开始啦！(-promise-) &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">      </div><div class=\"line\">      // 设置 *** 后 resolve, 传入 小count 作为参数</div><div class=\"line\">      window.setTimeout(</div><div class=\"line\">        function() &#123;</div><div class=\"line\">          resolve(thisPromiseCount);</div><div class=\"line\">          // reject(thisPromiseCount);</div><div class=\"line\">        &#125;, Math.random()*2000 + 1000);</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">  );</div><div class=\"line\">  </div><div class=\"line\"></div><div class=\"line\">  p1.then(</div><div class=\"line\">    </div><div class=\"line\">    function(val) &#123;</div><div class=\"line\">      log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;val&#125; ) made (&lt;small&gt; promise 异步数据 快完了 (-then-) &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  )</div><div class=\"line\">  .catch(</div><div class=\"line\">    </div><div class=\"line\">    function(reason) &#123;</div><div class=\"line\">      log.insertAdjacentHTML( &apos;beforeend&apos; ,`我被 拒绝 了！！！ ಥ_ಥ  因为 $&#123;reason&#125; `);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">  );</div><div class=\"line\">  </div><div class=\"line\">  log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Promise fulfilled!  (&lt;small&gt; 同步数据 最后～  &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果：<br>当 resolve 的时候:</p>\n<p><img src=\"http://img.jackon.me/promise-resolve.png\" alt=\"\"></p>\n<p>当 reject 的时候:<br><img src=\"http://img.jackon.me/promise-reject.png\" alt=\"\"></p>\n<p>– </p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充:\"></a>补充:</h3><p>element.insertAdjacentHTML</p>\n<h5 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h5><p>element.insertAdjacentHTML()</p>\n<ul>\n<li>将指定的文本解析为 <em>HTML 或 XML</em></li>\n<li>并将生成的节点 <strong>插入</strong>到指定位置的 <strong>DOM</strong> 树中。</li>\n<li>它不会<strong>重新</strong>解析它正在使用的元素, 因此它不会破环元素内的现有元素。这避免了 <strong>额外</strong>的序列化步骤，使其比直接 innerHTML <strong>操作更快</strong></li>\n</ul>\n<h5 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h5><p>element.insertAdjacentHTML( position, text );</p>\n<ul>\n<li><p>position 是想对于 元素 ( element ) 的 <strong>位置</strong>, 并且必须是以下 <em>字符串</em>之一:</p>\n<ul>\n<li>‘beforebegin’ 元素自身的前面</li>\n<li>‘afterbegin’ 插入元素内部的第一个子节点之前</li>\n<li>‘beforeend’ 插入元素内部的最后一个子节点之后</li>\n<li>‘afterend’ 元素自身的后面</li>\n</ul>\n</li>\n<li><p>text<br>要被解析成 HTML / XML, 并插入到 DOM 树中的字符</p>\n</li>\n</ul>\n<h2 id=\"位置名称的可视化：\"><a href=\"#位置名称的可视化：\" class=\"headerlink\" title=\"位置名称的可视化：\"></a>位置名称的可视化：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- beforebegin --&gt; </div><div class=\"line\">&lt;p&gt; </div><div class=\"line\">&lt;!-- afterbegin --&gt; </div><div class=\"line\">foo </div><div class=\"line\">&lt;!-- beforeend --&gt; </div><div class=\"line\">&lt;/p&gt; </div><div class=\"line\">&lt;!-- afterend --&gt;</div></pre></td></tr></table></figure>\n<p><br><br><br></p>\n<blockquote><p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">MDN: Promise</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML\" target=\"_blank\" rel=\"external\">MDN: element.insertAdjacentHTML</a></p>\n</blockquote>\n<p>还未看:<br><a href=\"https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\" target=\"_blank\" rel=\"external\">We have a problem with promises</a></p>\n","excerpt":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>所谓 Promise, 简单说就是一个容器。里面保存着某个 <strong>未来</strong>才会 <em>结束的事件</em> ( 通常是一个异步操作 ) 的 <strong>结果</strong>。</p>\n<ul>\n<li><p>Promise 对象是一个 <strong>返回值的代理</strong>，这个返回值在 promise 对象创建时未必已知。</p>\n</li>\n<li><p>它允许你为异步操作的成功返回值 ／ 失败信息指定处理方法。</p>\n</li>\n<li><p>这使异步方法可以像同步方法那样返回值： 异步方法会返回一个包含原返回值的 promise 对象来替代原返回值</p>\n</li>\n</ul>","more":"<p>Promise 对象有以下几种状态：</p>\n<ul>\n<li>pending</li>\n<li>fufilled 成功的操作</li>\n<li>rejected 失败的操作</li>\n</ul>\n<p>pending 可转换带着 <strong>一个成功值的 fulfilled 状态</strong>,<br>也可变成一个 <strong>带着失败信息的 rejected 状态</strong></p>\n<ul>\n<li><p>当状态发生转换的时候， promise.then 绑定的方法就会被调用 </p>\n</li>\n<li><p>当绑定方法时， promise 对象已经处于 fulfilled / rejected 状态，则相应的方法会被 <strong>立刻调用</strong> </p>\n</li>\n<li><p>一个 promise 对象处在 fulfilled ／ rejected 状态时它也可以被称为 settled  状态。 ( resolved 表示 promise 对象处于 settled  状态，或 promise 对象被 <strong>锁定</strong>在调用链中 ) </p>\n</li>\n<li><p>因为 Promise.prototype.then 和 Promise.prototype.catch 方法 <strong>返回 promises  对象</strong>，所以它们可以被链式调用</p>\n</li>\n</ul>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>new Promise( executor );<br>new Promise(function(resolve, reject) {…} );</p>\n<p>参数：<br>executor</p>\n<ul>\n<li>函数</li>\n<li>默认有 resolve, reject 两个参数</li>\n<li>在创建 Promise 对象的时候会 <strong>立即执行</strong> ( 在 Promise 构造函数返回 Promise 对象之前就会被执行 )</li>\n<li>调用 resolve 和 reject 函数会分别触发  promise 的成功或者 失败。</li>\n<li>这个函数参数 通常被用来执行一些异步操作，操作完成后可以选择 调用 resolve 来触发 promise 的成功状态，或者，在出现错误的时候调用 reject 函数来触发 promise 的失败。</li>\n<li><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3></li>\n<li><p>Promise.prototype 表示 Promise 构造器的原型</p>\n</li>\n<li>Promise.length 长度：1 ( 构造器参数数目 )</li>\n</ul>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ul>\n<li><p>Promise.all( iterable )</p>\n<ul>\n<li><p>当 iterable 里的所有 promise 对象都成功的时候才会触发成功 </p>\n</li>\n<li><p>任何一个 iterable 里的 promise 失败都会立刻触发该 promise 对象的失败 </p>\n</li>\n<li><p>触发成功的状态后，会把一个 包含 iterable 里 <strong>所有</strong> promise <strong>返回值</strong> 的 <strong>数组</strong>作为成功回调的返回值 (顺序跟 iterable 的<strong>顺序保持一致</strong>)。</p>\n</li>\n<li><p>触发失败的状态后, 会 <strong>返回</strong> iterable 中<strong>第一个触发失败的 promise 对象</strong> 的 <strong>错误信息</strong>( 作为它的错误信息 ) </p>\n</li>\n</ul>\n</li>\n<li><p>Promise.race( iterable )<br>当 iterable 参数里的任意一个 promise 被成功或失败后，<br>父 promise 也会马上用子 promise 的成功返回值 或失败详情作为参数调用 父 promise 绑定的相应句柄, 并返回该 promise 对象。</p>\n</li>\n</ul>\n<p>NOTE !!! ： <strong>这个是 promises —&gt; Promise.all  实现的原理</strong></p>\n<ul>\n<li>Promise.reject( reason )</li>\n</ul>\n<p>返回一个 因为 reason 而被拒绝 (rejected) 的 Promise 对象</p>\n<ul>\n<li><p>Promise.resolve( value )</p>\n<ul>\n<li><p>Returns a <em>Promise</em> object that is resolved with the given value .  ( fulfill )</p>\n</li>\n<li><p>如果该 value 为 thenable ( 带有 then 方法 )</p>\n<ul>\n<li>返回的 Promise 对象会 “跟随” 这个value 并采用这个 value 的最终状态 </li>\n</ul>\n</li>\n<li><p>value 没有带 then 方法,  返回的 Promise will be fulfilled with the value</p>\n</li>\n<li><p>如果你不知道 value 是不是一个 promise, Promise.resolve( value )  it instead and work with the return value as a promise. </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"👆没有理解-看例子。。\"><a href=\"#👆没有理解-看例子。。\" class=\"headerlink\" title=\"👆没有理解!! 看例子。。\"></a>👆没有理解!! 看例子。。</h2><h3 id=\"Promise-prototype\"><a href=\"#Promise-prototype\" class=\"headerlink\" title=\"Promise prototype\"></a>Promise prototype</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>Promise.prototype.constructor</li>\n</ul>\n<p>返回 the function that created an instance’s prototype.<br>这个函数默认为是 <em>Promise function</em> </p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ul>\n<li><p>Promise.prototype.catch( onRejected )</p>\n<ul>\n<li><p>向当前promise 添加 处理 rejection 的一个回调函数 onRejected， </p>\n</li>\n<li><p>如果这个回调函数被调用，将返回一个<em> 新的 promise</em></p>\n</li>\n<li><p>这个 <em>新的 promise</em> 会 resolve ( 解析 ) 这个回调函数的 value.</p>\n</li>\n<li><p>如果 这个 <em>新的promise</em> 的状态为 fulfilled, 就会被 resolve 它最原始的 fulfilled 状态</p>\n</li>\n</ul>\n</li>\n<li><p>Promise.prototype.then(onFulfilles, onRejected )</p>\n<ul>\n<li><p>向当前的 promise 添加处理 fulfillment and rejection 的函数 onFulfiles, onRejected</p>\n</li>\n<li><p>并且 ( 这个 then 函数 ) 返回一个<em>新的 promise </em></p>\n</li>\n<li><p>这个<em>新的 promise</em> 解析 (resolving ) 处理函数 ( onFufilled / onRejected ) 的 返回值</p>\n</li>\n<li><p>或者 如果这个 promise 没有被处理 , <em>这个新的 promise</em> 解析成 它原来的 settled 值。 ( 比如说，相关的处理程序 onFulfilled 或者 onRejected 不是一个函数 )</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">let promiseCount = 0;</div><div class=\"line\"></div><div class=\"line\">// 执行三次函数 ( 三个 promise )</div><div class=\"line\">testPromise();</div><div class=\"line\">testPromise();</div><div class=\"line\">testPromise();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function testPromise() &#123;</div><div class=\"line\">  // 将全局的 count + 1 并赋值给自己的 小count</div><div class=\"line\">  let thisPromiseCount = ++promiseCount;</div><div class=\"line\"></div><div class=\"line\">  let log = document.getElementById(&apos;log&apos;);</div><div class=\"line\">  </div><div class=\"line\">  log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Start (&lt;small&gt; 同步数据开始啦~~ &lt;/small&gt;)&lt;br/&gt;` );</div><div class=\"line\">  </div><div class=\"line\">  // 声明一个 promise 对象</div><div class=\"line\">  let p1 = new Promise(</div><div class=\"line\">    // 立刻开始执行</div><div class=\"line\">    function(resolve, reject) &#123;</div><div class=\"line\">      </div><div class=\"line\">      log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Started (&lt;small&gt; promise 异步数据 开始啦！(-promise-) &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">      </div><div class=\"line\">      // 设置 *** 后 resolve, 传入 小count 作为参数</div><div class=\"line\">      window.setTimeout(</div><div class=\"line\">        function() &#123;</div><div class=\"line\">          resolve(thisPromiseCount);</div><div class=\"line\">          // reject(thisPromiseCount);</div><div class=\"line\">        &#125;, Math.random()*2000 + 1000);</div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">  );</div><div class=\"line\">  </div><div class=\"line\"></div><div class=\"line\">  p1.then(</div><div class=\"line\">    </div><div class=\"line\">    function(val) &#123;</div><div class=\"line\">      log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;val&#125; ) made (&lt;small&gt; promise 异步数据 快完了 (-then-) &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  )</div><div class=\"line\">  .catch(</div><div class=\"line\">    </div><div class=\"line\">    function(reason) &#123;</div><div class=\"line\">      log.insertAdjacentHTML( &apos;beforeend&apos; ,`我被 拒绝 了！！！ ಥ_ಥ  因为 $&#123;reason&#125; `);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">  );</div><div class=\"line\">  </div><div class=\"line\">  log.insertAdjacentHTML(&apos;beforeend&apos;, `( $&#123;thisPromiseCount&#125; ) Promise fulfilled!  (&lt;small&gt; 同步数据 最后～  &lt;/small&gt;)&lt;br/&gt;`);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果：<br>当 resolve 的时候:</p>\n<p><img src=\"http://img.jackon.me/promise-resolve.png\" alt=\"\"></p>\n<p>当 reject 的时候:<br><img src=\"http://img.jackon.me/promise-reject.png\" alt=\"\"></p>\n<p>– </p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充:\"></a>补充:</h3><p>element.insertAdjacentHTML</p>\n<h5 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h5><p>element.insertAdjacentHTML()</p>\n<ul>\n<li>将指定的文本解析为 <em>HTML 或 XML</em></li>\n<li>并将生成的节点 <strong>插入</strong>到指定位置的 <strong>DOM</strong> 树中。</li>\n<li>它不会<strong>重新</strong>解析它正在使用的元素, 因此它不会破环元素内的现有元素。这避免了 <strong>额外</strong>的序列化步骤，使其比直接 innerHTML <strong>操作更快</strong></li>\n</ul>\n<h5 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h5><p>element.insertAdjacentHTML( position, text );</p>\n<ul>\n<li><p>position 是想对于 元素 ( element ) 的 <strong>位置</strong>, 并且必须是以下 <em>字符串</em>之一:</p>\n<ul>\n<li>‘beforebegin’ 元素自身的前面</li>\n<li>‘afterbegin’ 插入元素内部的第一个子节点之前</li>\n<li>‘beforeend’ 插入元素内部的最后一个子节点之后</li>\n<li>‘afterend’ 元素自身的后面</li>\n</ul>\n</li>\n<li><p>text<br>要被解析成 HTML / XML, 并插入到 DOM 树中的字符</p>\n</li>\n</ul>\n<h2 id=\"位置名称的可视化：\"><a href=\"#位置名称的可视化：\" class=\"headerlink\" title=\"位置名称的可视化：\"></a>位置名称的可视化：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- beforebegin --&gt; </div><div class=\"line\">&lt;p&gt; </div><div class=\"line\">&lt;!-- afterbegin --&gt; </div><div class=\"line\">foo </div><div class=\"line\">&lt;!-- beforeend --&gt; </div><div class=\"line\">&lt;/p&gt; </div><div class=\"line\">&lt;!-- afterend --&gt;</div></pre></td></tr></table></figure>\n<p><br/><br><br/></p>\n<blockquote><p>参考：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN: Promise</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML\">MDN: element.insertAdjacentHTML</a></p>\n</blockquote>\n<p>还未看:<br><a href=\"https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\">We have a problem with promises</a></p>"},{"_content":"感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。\n","source":"_drafts/XMLHttpRequest.md","raw":"感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。\n","slug":"XMLHttpRequest","published":0,"date":"2016-12-16T13:40:04.000Z","updated":"2016-12-16T13:41:18.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwrufehg000ilvraxyq57z3b","content":"<p>感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。</p>\n","excerpt":"","more":"<p>感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。</p>\n"},{"title":"XMLHttpRequest","_content":"\n\n感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。\n\n\nAjax 技术的核心是 XMLHttpRequest 对象( 简称 XHR ),\n\n### 用法\n\n#### 初始化: xhr.open(_method, url, async, user, password_);\n\n- 接收 5 个参数:\n\n  + method: 要发送的请求类型\n  + url: 请求的 URL ( 相对路径的话是相对执行代码的当前页面, 也可以是绝对路径 )\n  + async: 是否异步发送请求\n  + user: 可选。用于身份验证的目的。默认值为 null\n  + password:可选。也是用于身份验证的目的。默认值为 null\n\n<!-- more -->\n当使用的是_同步_请求的时候，有如下_限制_ ( 否则会报错: _InvalidAccessError_ )：\n\n- xhr.timeout 必须为 0\n- xhr.withCredentials 必须为 false\n- xhr.responseType 必须为 \"\"\n\nNOTE:\n\n- 初始化一个请求，如果是本地代码，请使用 __openRequest()__代替\n\n- 在一个已经激活的 request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了__abort()__ 方法。\n\n```\nxhr.open( 'get', 'example.php', false );\n```\n\n#### GET请求\n\n最常用于向服务器查询某些信息。\n必要时，可以将查询字符串参数追加到 URL 末尾.\n\n对于 XHR，位于传入 open() 方法的 URL 末尾的查询字符串:\n- 必须要使用 __encodeURIComponent()__ 进行编码, 才能放到 URL 的末尾\n- 所有__名-值对__ 都必须 & 分隔。\n如下：\n\n```\nxhr.open(\"get\", \"example.php?name1=value&name2=value2\", true);\n\n// 这个函数可以辅助向现有 URL 的末尾添加查询字符串参数\n\nfunction addURLParam( url, name, value ) {\n  url += ( url.indexOf(\"?\") == -1 ? \"?\" : \"&\" );\n  url += encodeURIComponent( name ) + \"=\" + encodeURIComponent( value );\n  return url;\n}\n\n```\n#### POST 请求\n\n##### open()\n\n- 通常用于向服务器发送应该被保存的数据\n- POST 请求应该把数据作为请求主体提交。 send( data )\n- POST 请求的主体可以包含非常多的数据, 各式不限。\n\n```\nxhr.open( \"psot\", \"example.php\", true)\n```\n##### send()\n\n然后向 send() 方法中传入某些数据。\n\n__默认情况下__， 服务器对 __POST__ 请求和 提交 __Form__ 表单并不会__一视同仁__。所以服务器端必须要有程序来__读取__发送过来的原始数据，并从中__解析__出有用的部分。\n\n我们可以使用 _XHR 模仿_表单提交时的内容类型，其次是以__适当的格式__创建一个字符串。\n__POST 数据的格式与查询字符串格式相同__。\n\n```\nfunction submitData() {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = () => {\n    if( xhr.readyState == 4 ){\n      if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n        console.log(xhr.responseText);\n      } else {\n        console.log(\"Request was unsuccessful:\" + xhr.status);\n      }\n    }\n  }\n\n  xhr.open(\"POST\", \"postexample.php\", true );\n  // 表单提交时的内容类型\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\" );\n  var form = document.getElementById(\"user-info\");\n\n  // 将页面中的表单数据进行序列化\n  xhr.send( serialize( form ) );\n}\n```\n\n##### FormData 类型\n\n为序列化表单以及创建与表单格式相同的数据提供了便利。\n\n```\n// 第 1 种方法\nlet data = new FormData();\ndata.append(\"name\", \"Nicholas\");\n\n// 第 2 种方法\nlet data = new FormData(document.forms[0]);\n```\nappend 接收 2 个参数: 键和值\n- 可以通过 append 添加任意多个键值对。\n- 也可以通过向 FormData 构造函数中传入表单元素\n\n创建 FormData 的实例之后， 可以将它直接传给 XHR 的 send()\n\n```\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n      console.log(xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful:\" + xhr.status);\n    }\n  }\n}\n\nxhr.open(\"POST\", \"postexample.php\", true );\nvar form = document.getElementById(\"user-info\");\nxhr.send(new FormData(form) );\n\n```\n\n#### 发送请求: xhr.send( _data_ )\n\n- 接收 1 个参数：data\n  + 作为请求主体发送的数据\n\n- 参数 data 可以是以下几种类型：\n  + ArrayBuffer\n  + Blob\n  + Document\n  + DOMString\n  + FormData\n  + null\n\n- 如果不需要通过请求主体发送数据，需传入 null\n\n\nNOTE: 如果使用 _GET / HEAD_ 请求，参数 _data_ 会被设置为 _null_\n\n_data_ 参数的_数据类型_会__影响__请求头部的 __content-type__ 的 __默认值__：\n\n- data: __Document ( HTML Document 类型 )__，则 content-type: __text/html__;charset=UTF-8; 否则为 __application/xml__;charset=UTF-8\n- data: __DOMString__, content-type: __text/plain__;charset=UTF-8\n- data: __FormData__, content-type: __multipart/form-data__;boundary=[xxx]\n- data 是其他类型， 则__不会设置__ content-type 的默认值\n\n基本使用：\n\n```\nxhr.send();\n```\n\n在__断网__状态下调用 xhr.send(data), 会__抛错__：Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest' 。一旦程序抛错误，若不 catch 就无法继续执行后面的代码，所以调用 xhr.send(), 应该用 __try-catch__ 捕捉错误\n\n```\ntry {\n  xhr.send(data)\n} catch(e) {\n  //do something...\n}\n\n```\n\n#### 取消异步请求: xhr.abort()\n\n调用这个方法之后， XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。\n\n在_终止请求_之后，__还应该对 XHR 对象进行接引用操作__。由于内存原因, 不建议重用 XHR 对象。\n\n### 示例\n\n#### 同步请求\n\n- 调用 send() 之后，请求就会被分派到服务器\n\n```\nxhr.open( 'get', 'example.php', false );\nxhr.send();\n```\n👆的请求是 _同步_的，JS 代码会 _等到服务器响应之后_再继续执行。\n\n- 收到响应后，响应的 _数据_会自动填充 XHR 对象的属性，相关属性:   ( __具体可以看后面__ )\n\n  - responseText: 作为响应的主体背返回的文本。\n  - responseXML: 如果响应的内容类型是 \"text / xml\" 或者 \"application / xml\", 这个属性中将保存 _包含着响应数据的 XML DOM 文档_\n  - status: 响应的 HTTP 状态\n  - statusText: HTTP 状态的说明\n\n- 接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。\n\n  + 一般来说，可将 HTTP 状态代码为 __200__ 作为成功的标志\n  + 此时， responseText 属性内容已经就绪，而且在内容类型正确的情况下， responseXML 也应该能够访问了。\n\n  + 状态代码: __304__表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本, 当然也表示响应是有效的\n\n  + __为确保接收到适当的响应，应该像👇这样检查上述代码 (_不要依赖 statusText_) ：__\n\n```\nlet xhr = new XMLHttpRequest();\n\n// 我这里调用的是 github react/forks 的 API\nxhr.open(\"get\", \"https://api.github.com/repos/facebook/react/forks\", false);\nxhr.send(null);\n\nif((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n  console.log(xhr.responseText);\n} else {\n  console.log(\"Request was unsuccessful:\" + xhr.status);\n}\n```\n\n结果\n\n![](http://img.jackon.me/xhr1.png)\n\n\n##### 同步请求 NOTE:\n当 xhr 为同步时：\n\n- xhr.timeout: 需为 0\n- xhr.withCredentials: 需为 false\n- xhr.responseType: 需为 \"\"\n- 无法设置 请求超时 ( xhr.timeout )\n- xhr.upload.onprogress , xhr.onprogress 事件不会触发\n\n### HTTP 头部信息 ( 不太能用到 )\n\n每个 HTTP 请求和响应都会带有相应的头部信息( 并不一定都有用 )\nXHR 对象也提供了操作这两种头部 ( 即__请求头部和响应头部__ ) 信息的方法。\n\n默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息：\n\n- Accept: 浏览器能够处理的内容类型\n- Accept-Charset: 浏览器能够显示的字符集\n- Accept-Encoding: 浏览器能够处理的压缩编码\n- Accept-Language: 浏览器当前设置的语言\n- Connection: 浏览器与服务器之间连接的类型\n- Cookie: 当前页面设置的任何 Cookie\n- Host: 发送请的页面所在的域\n- Referer: 发送请求的页面的 URL。( 这个英文单词应该是 Referrer, 然而 HTTP 规范将这个词拼错了，所以只能讲错就错 )\n- User-Agent: 浏览器的用户代理字符串\n\n#### setRequestHeader( _DOMString header, DOMString value_ )\n\n使用 __setRequestHeader()__ 方法可以__设置__请求头部信息__\n\n  + 接受 2 个参数：头部字段的名称， 头部字段的值\n  + 要成功发送请求头部的信息，必须在调用 __open() 之后， send() 之前__ 调用 setRequestHeader()\n  + 可以多次调用, 最终的值不会采用覆盖 ( override ) 的方式, 而是采用追加 append 的方式。\n  + 建议使用 __自定义__头部字段名称，否则可能会影响服务器端的响应\n\n例子：\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      console.log( xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\n// 我这里调用的依旧是 github react/forks 的 API\nxhr.open(\"get\" , \"https://api.github.com/repos/facebook/react/forks\", true);\n\nxhr.setRequestHeader(\"MyHeader\", \"MyValue\");\nxhr.setRequestHeader(\"MyHeader\", \"HerValue\");\n// 最终的 header 中的 \"MyHeader\" 为 \"MyValue\", \"HerValue\"\nxhr.send(null);\n```\n\n#### 获取响应头部 ( _safe_ 的字段 )\n\n- getResponseHeader( _DOMString header_ )\n\n返回 __指定的响应的值__，如果响应头还没被接受或者响应头不存在，返回 __null__\n\n```\nlet myHeader = xhr.getResponseHeader(\"MyHeader\");\n```\n- getAllResponseHeaders()\n\n返回所有的响应头信息。如果响应头还没有接受，则返回 null.\n\nNOTE: For multipart requests, this returns the headers from the current part of the request, not from the original channel.\n\n```\nlet allHeaders = xhr.getAllResponseHeaders();\n```\nNOTE：\n\n- W3C 限制：客户端无法获取 response __Set-Cookie, Set-Cookie2__( xhr 标准 ); __跨域请求时__客户端允许获取 __simple response header,  Access-Control-Expose-Headers__( cors 标准 )\n\n- getAllResponseHeaders() __只能__ 拿到 __限制以外__( 被视为 _safe_ ) 的 header 字段 ( 第一条 )。\n\n- getResponseHeader( _header_ ) 方法时, header 参数必须是 __限制以外__的 header, 否则会报错: _Refused to get unsafe header_。 ( 第一条 )\n\n#### 指定 xhr.response 的数据类型\n\n- 使用 level 1 提供的 __overrideMimeType( )__ 方法\n\n比如：\n\n- 我们想要 server 点返回一个 DOM 对象, 就可以设置 __xhr.overrideMimeType('text/xml, charset = utf-8\")__。\n- xhr level 1 __不支持__直接传送 __blob__ 二进制数据, 可以利用 __overrideMimeType()__ 方法\n\n如下 level 1 获取 一张图片\n\n```\nlet xhr = new XMLHttpRequest();\n\n// 获取一张 图片\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\n// 将响应的数据按照纯文本来解析，字符集替换为用户自己定义的字符集\nxhr.overrideMimeType('text/plain; charset=x-user-defined');\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n\n      let blobStr = xhr.responseText;\n    // 逐个字节的还原成二进制数据, 顺序  blobStr[i] --> ASCII( 16 进制 ) -->  2 进制\n      for( let i=0, len = blobStr.length; i<len; ++i ) {\n        let c = blobStr.charCodeAt(i)\n        let byte = c&0xff;\n      }\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\nxhr.send(null);\n```\n通过设置 response 的 content-type 为 \"text/plain;charset=x-user-defined\" ，使 xhr 以纯文本格式解析接收到的 blob 数据, 然后再将其转换为 blob 数据\n\n- xhr.responseType\n\n指定 xhr.response 的数据类型，可以设置如下:\n\n- \"\"   ( String 字符串, 默认 )\n- \"text\"   ( String )\n- \"document\"   ( Document 对象，返回格式为 XML )\n- \"json\"    ( js 对象， __IE10, IE11 不支持__ )\n- \"blob\"\n- \"arrayBuffer\"\n\n获取图片\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\n// 可使用 blob 或者 arrayBuffer\n\nxhr.responseType = 'blob';\n// xhr.responseType = 'arrayBuffer';\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      let blobStr = xhr.response;\n      console.log( blobStr )\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\nxhr.send(null);\n```\n\n结果：\n\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%881.41.54.png)\n\n#### 获取 response 数据\n\n有 3 个属性可以获取返回的数据, 分别是： __xhr.response, xhr.reponseText, xhr.responseXML__\n\n- xhr.response\n  + 默认值: \"\"\n  + 请求__完成__时, 才有正确的值\n  + 请求未完成时,\n    - 当 responseText 为 \"\" 或 \"text\" 时, 值为 \"\"\n    - 当 responseText 为 其他值时, 值为 null\n\n- xhr.responseText\n  + 默认值: \"\"\n  + 只有当 responseType 为 __\"text\", \"\"__ 时, xhr 对象__才有此属性__，此时才能调用 xhr.responseText, 否则 _抛错_\n  + 只有当请求__成功__时, 才能拿到__正确值__。当请求__未完成__或者请求__失败__ 时 值都为 __\"\"__\n\n- xhr.responseXML\n  + 默认值: null\n  + 只有当 __responseType 为 \"text\", \"\",\"document\"__ 时, xhr 对象 __才有此属性__, 此时才能调用 __xhr.responseXML__, 否则抛错\n  + 只有当请求__成功__时, 才能拿到__正确值__。当请求__未完成__, 请求__失败__, 请求__成功但返回数据无法被正确解析__ 时 值都为 __null__\n\n#### 追踪 ajax 请求的当前状态: xhr.readyState\n\n当发送 __异步__请求，接收响应的时候，可以检测 XHR 对象的 __readyState__ 属性，该属性表示 __请求 ／ 响应过程的当前活动阶段__。这个属性可取的值如下：\n\n  - 0: 未初始化。尚未调用 open() 方法。\n  - 1: 启动。已经调用 open() 方法，但是尚未接收到响应。\n  - 2: 发送。已经调用 send() 方法，但尚未接收到响应。\n  - 3: 接收。已经接收到部分响应数据。\n  - __4__: 完成。已经接收到全部响应数据，而且已经可以在客户端使用。\n\n只要 __readyState__ 属性的值__改变__，__都会__触发一次 __readystatechange__ 事件。\n可以__利用__这个事件来__检测__每次__状态变化__后 __readyState__ 的值。\n\nNOTE!!!: 必须在调用 _open()_  __之前__指定 __onreadystatechange__ 事件处理程序才能__确保__跨浏览器__兼容性__。\n\n例子:\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      console.log( xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\n// 我这里调用的依旧是 github react/forks 的 API\nxhr.open(\"get\" , \"https://api.github.com/repos/facebook/react/forks\", true);\n\nxhr.send(null);\n```\n\n结果：\n\n![](http://img.jackon.me/xhr.png)\n\n#### 设置请求超时时间: xhr.timeout\n\n从__请求开始__算起, 若超过 timeout 时间请求还没有结束,  则会触发  ontimeout 事件, 主动结束该请求\n\n请求开始: xhr.onloadstart 事件触发的时候 ( 也就时调用 xhr.send() 的时候 )\n\n请求结束: xhr.loadend 事件触发的时候\n\n- 单位: 毫秒\n- 默认值：0\n\n NOTE:\n - 在 __send() 之后__ 再设置 timeout, 但__计时起点__ 仍旧为调用 __xhr.send()__ 方法的时刻\n - 当 时一个 __同步__ 请求时, xhr.timeout 必须设置为 0, 否则__抛错__\n\n### 进度事件\n\n有 6 个进度事件:\n\n- loadstart: 在接收到响应数据的第一个字节时触发\n- progress: 在接收响应期间持续不断触发\n- error: 在请求发生错误时触发\n- abort: 在因为调用 abort() 方法而终止连接时触发\n- load: 在接收到完整的响应数据时触发\n- loadend: 在通信完成或者触发 error, abort, load 事件中的一个\n\n每个请求都从触发 __loadstart__ 事件开始, 接下来是 __一个或者 多个__\n__progress__ 事件，然后以触发 __loadend__ 事件结束\n\nNOTE:\n- __lE8+ 只支持 load 事件。__\n- 没有浏览器支持 loadend 事件\n\n#### load 事件\n\n只要浏览器接收到服务器的响应，__不管其状态如何__，都会触发 load 事件。所以每次 __必须__ 检查 __status__ 属性, 才能__确定__数据是否真的已经可用。 Firefox, Opera, Chrome, Safari 都支持 load 事件\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\nxhr.responseType = 'arrayBuffer';\n\nxhr.onload = () => {\n  if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n    console.log(xhr.responseText );\n  } else {\n    console.log(\"Request was unsuccessful: \" + xhr.status);\n  }\n}\nxhr.send(null);\n```\n\n#### progress 事件\n 这个事件会在浏览器接收新数据期间周期性地触发，默认情况下这个事件__每 50ms__ 触发一次。\n\n __onprogress__ 事件处理程序会接收一个 __event__ 事件, 其 __target 属性__ 是 XHR 对象, 但包含着三个额外的属性:\n\n- lengthComputable: 表示进度信息是否可用的布尓值\n- position: __已经接收__的字节数\n- totalSize: 表示 根据 Content-length 响应头部确定的预期字节数.\n\n_上传，下载过程触发的是不同对象的 onprogress 事件_:\n\n- 上传: xhr.upload 对象的 onprogress 事件\n- 下载: xhr 对象的 onprogress 事件\n\n必须在调用 __open()__ 方法__之前__添加 onprogress 事件处理程序\n```\nlet log = document.querySelector(\"#log\")\n\nfunction downProgress(e) {\n   log.innerHTML = `Received <strong>${e.position}</strong> of <strong>${e.totalSize}</strong> bytes`\n}\n\nlet xhr = new XMLHttpRequest();\n\nxhr.onprogress = (e) => {\n  console.log( 'onprogress' )\n  if( e.lengthComputable ) {\n    downProgress(e)\n  }\n}\n\nxhr.onload = () => {\n  if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n    console.log(xhr.responseText );\n  } else {\n    console.log(\"Request was unsuccessful: \" + xhr.status);\n  }\n}\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\nxhr.responseType = 'arrayBuffer';\n\nxhr.send(null);\n```\n\n结果;\n\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%886.54.00.png)\n\n\n{% blockquote %}\n\n参考：\n\n[你真的会使用 XMLHttpRequest 吗？](https://segmentfault.com/a/1190000004322487)\n\n_JavaScript 高级程序设计_\n{% endblockquote %}\n\n","source":"_posts/XMLHttpRequest.md","raw":"---\ntitle: XMLHttpRequest\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- XMLHttpRequest\n- JS 基础\n---\n\n\n感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。\n\n\nAjax 技术的核心是 XMLHttpRequest 对象( 简称 XHR ),\n\n### 用法\n\n#### 初始化: xhr.open(_method, url, async, user, password_);\n\n- 接收 5 个参数:\n\n  + method: 要发送的请求类型\n  + url: 请求的 URL ( 相对路径的话是相对执行代码的当前页面, 也可以是绝对路径 )\n  + async: 是否异步发送请求\n  + user: 可选。用于身份验证的目的。默认值为 null\n  + password:可选。也是用于身份验证的目的。默认值为 null\n\n<!-- more -->\n当使用的是_同步_请求的时候，有如下_限制_ ( 否则会报错: _InvalidAccessError_ )：\n\n- xhr.timeout 必须为 0\n- xhr.withCredentials 必须为 false\n- xhr.responseType 必须为 \"\"\n\nNOTE:\n\n- 初始化一个请求，如果是本地代码，请使用 __openRequest()__代替\n\n- 在一个已经激活的 request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了__abort()__ 方法。\n\n```\nxhr.open( 'get', 'example.php', false );\n```\n\n#### GET请求\n\n最常用于向服务器查询某些信息。\n必要时，可以将查询字符串参数追加到 URL 末尾.\n\n对于 XHR，位于传入 open() 方法的 URL 末尾的查询字符串:\n- 必须要使用 __encodeURIComponent()__ 进行编码, 才能放到 URL 的末尾\n- 所有__名-值对__ 都必须 & 分隔。\n如下：\n\n```\nxhr.open(\"get\", \"example.php?name1=value&name2=value2\", true);\n\n// 这个函数可以辅助向现有 URL 的末尾添加查询字符串参数\n\nfunction addURLParam( url, name, value ) {\n  url += ( url.indexOf(\"?\") == -1 ? \"?\" : \"&\" );\n  url += encodeURIComponent( name ) + \"=\" + encodeURIComponent( value );\n  return url;\n}\n\n```\n#### POST 请求\n\n##### open()\n\n- 通常用于向服务器发送应该被保存的数据\n- POST 请求应该把数据作为请求主体提交。 send( data )\n- POST 请求的主体可以包含非常多的数据, 各式不限。\n\n```\nxhr.open( \"psot\", \"example.php\", true)\n```\n##### send()\n\n然后向 send() 方法中传入某些数据。\n\n__默认情况下__， 服务器对 __POST__ 请求和 提交 __Form__ 表单并不会__一视同仁__。所以服务器端必须要有程序来__读取__发送过来的原始数据，并从中__解析__出有用的部分。\n\n我们可以使用 _XHR 模仿_表单提交时的内容类型，其次是以__适当的格式__创建一个字符串。\n__POST 数据的格式与查询字符串格式相同__。\n\n```\nfunction submitData() {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange = () => {\n    if( xhr.readyState == 4 ){\n      if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n        console.log(xhr.responseText);\n      } else {\n        console.log(\"Request was unsuccessful:\" + xhr.status);\n      }\n    }\n  }\n\n  xhr.open(\"POST\", \"postexample.php\", true );\n  // 表单提交时的内容类型\n  xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\" );\n  var form = document.getElementById(\"user-info\");\n\n  // 将页面中的表单数据进行序列化\n  xhr.send( serialize( form ) );\n}\n```\n\n##### FormData 类型\n\n为序列化表单以及创建与表单格式相同的数据提供了便利。\n\n```\n// 第 1 种方法\nlet data = new FormData();\ndata.append(\"name\", \"Nicholas\");\n\n// 第 2 种方法\nlet data = new FormData(document.forms[0]);\n```\nappend 接收 2 个参数: 键和值\n- 可以通过 append 添加任意多个键值对。\n- 也可以通过向 FormData 构造函数中传入表单元素\n\n创建 FormData 的实例之后， 可以将它直接传给 XHR 的 send()\n\n```\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n      console.log(xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful:\" + xhr.status);\n    }\n  }\n}\n\nxhr.open(\"POST\", \"postexample.php\", true );\nvar form = document.getElementById(\"user-info\");\nxhr.send(new FormData(form) );\n\n```\n\n#### 发送请求: xhr.send( _data_ )\n\n- 接收 1 个参数：data\n  + 作为请求主体发送的数据\n\n- 参数 data 可以是以下几种类型：\n  + ArrayBuffer\n  + Blob\n  + Document\n  + DOMString\n  + FormData\n  + null\n\n- 如果不需要通过请求主体发送数据，需传入 null\n\n\nNOTE: 如果使用 _GET / HEAD_ 请求，参数 _data_ 会被设置为 _null_\n\n_data_ 参数的_数据类型_会__影响__请求头部的 __content-type__ 的 __默认值__：\n\n- data: __Document ( HTML Document 类型 )__，则 content-type: __text/html__;charset=UTF-8; 否则为 __application/xml__;charset=UTF-8\n- data: __DOMString__, content-type: __text/plain__;charset=UTF-8\n- data: __FormData__, content-type: __multipart/form-data__;boundary=[xxx]\n- data 是其他类型， 则__不会设置__ content-type 的默认值\n\n基本使用：\n\n```\nxhr.send();\n```\n\n在__断网__状态下调用 xhr.send(data), 会__抛错__：Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest' 。一旦程序抛错误，若不 catch 就无法继续执行后面的代码，所以调用 xhr.send(), 应该用 __try-catch__ 捕捉错误\n\n```\ntry {\n  xhr.send(data)\n} catch(e) {\n  //do something...\n}\n\n```\n\n#### 取消异步请求: xhr.abort()\n\n调用这个方法之后， XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。\n\n在_终止请求_之后，__还应该对 XHR 对象进行接引用操作__。由于内存原因, 不建议重用 XHR 对象。\n\n### 示例\n\n#### 同步请求\n\n- 调用 send() 之后，请求就会被分派到服务器\n\n```\nxhr.open( 'get', 'example.php', false );\nxhr.send();\n```\n👆的请求是 _同步_的，JS 代码会 _等到服务器响应之后_再继续执行。\n\n- 收到响应后，响应的 _数据_会自动填充 XHR 对象的属性，相关属性:   ( __具体可以看后面__ )\n\n  - responseText: 作为响应的主体背返回的文本。\n  - responseXML: 如果响应的内容类型是 \"text / xml\" 或者 \"application / xml\", 这个属性中将保存 _包含着响应数据的 XML DOM 文档_\n  - status: 响应的 HTTP 状态\n  - statusText: HTTP 状态的说明\n\n- 接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。\n\n  + 一般来说，可将 HTTP 状态代码为 __200__ 作为成功的标志\n  + 此时， responseText 属性内容已经就绪，而且在内容类型正确的情况下， responseXML 也应该能够访问了。\n\n  + 状态代码: __304__表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本, 当然也表示响应是有效的\n\n  + __为确保接收到适当的响应，应该像👇这样检查上述代码 (_不要依赖 statusText_) ：__\n\n```\nlet xhr = new XMLHttpRequest();\n\n// 我这里调用的是 github react/forks 的 API\nxhr.open(\"get\", \"https://api.github.com/repos/facebook/react/forks\", false);\nxhr.send(null);\n\nif((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 ) {\n  console.log(xhr.responseText);\n} else {\n  console.log(\"Request was unsuccessful:\" + xhr.status);\n}\n```\n\n结果\n\n![](http://img.jackon.me/xhr1.png)\n\n\n##### 同步请求 NOTE:\n当 xhr 为同步时：\n\n- xhr.timeout: 需为 0\n- xhr.withCredentials: 需为 false\n- xhr.responseType: 需为 \"\"\n- 无法设置 请求超时 ( xhr.timeout )\n- xhr.upload.onprogress , xhr.onprogress 事件不会触发\n\n### HTTP 头部信息 ( 不太能用到 )\n\n每个 HTTP 请求和响应都会带有相应的头部信息( 并不一定都有用 )\nXHR 对象也提供了操作这两种头部 ( 即__请求头部和响应头部__ ) 信息的方法。\n\n默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息：\n\n- Accept: 浏览器能够处理的内容类型\n- Accept-Charset: 浏览器能够显示的字符集\n- Accept-Encoding: 浏览器能够处理的压缩编码\n- Accept-Language: 浏览器当前设置的语言\n- Connection: 浏览器与服务器之间连接的类型\n- Cookie: 当前页面设置的任何 Cookie\n- Host: 发送请的页面所在的域\n- Referer: 发送请求的页面的 URL。( 这个英文单词应该是 Referrer, 然而 HTTP 规范将这个词拼错了，所以只能讲错就错 )\n- User-Agent: 浏览器的用户代理字符串\n\n#### setRequestHeader( _DOMString header, DOMString value_ )\n\n使用 __setRequestHeader()__ 方法可以__设置__请求头部信息__\n\n  + 接受 2 个参数：头部字段的名称， 头部字段的值\n  + 要成功发送请求头部的信息，必须在调用 __open() 之后， send() 之前__ 调用 setRequestHeader()\n  + 可以多次调用, 最终的值不会采用覆盖 ( override ) 的方式, 而是采用追加 append 的方式。\n  + 建议使用 __自定义__头部字段名称，否则可能会影响服务器端的响应\n\n例子：\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      console.log( xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\n// 我这里调用的依旧是 github react/forks 的 API\nxhr.open(\"get\" , \"https://api.github.com/repos/facebook/react/forks\", true);\n\nxhr.setRequestHeader(\"MyHeader\", \"MyValue\");\nxhr.setRequestHeader(\"MyHeader\", \"HerValue\");\n// 最终的 header 中的 \"MyHeader\" 为 \"MyValue\", \"HerValue\"\nxhr.send(null);\n```\n\n#### 获取响应头部 ( _safe_ 的字段 )\n\n- getResponseHeader( _DOMString header_ )\n\n返回 __指定的响应的值__，如果响应头还没被接受或者响应头不存在，返回 __null__\n\n```\nlet myHeader = xhr.getResponseHeader(\"MyHeader\");\n```\n- getAllResponseHeaders()\n\n返回所有的响应头信息。如果响应头还没有接受，则返回 null.\n\nNOTE: For multipart requests, this returns the headers from the current part of the request, not from the original channel.\n\n```\nlet allHeaders = xhr.getAllResponseHeaders();\n```\nNOTE：\n\n- W3C 限制：客户端无法获取 response __Set-Cookie, Set-Cookie2__( xhr 标准 ); __跨域请求时__客户端允许获取 __simple response header,  Access-Control-Expose-Headers__( cors 标准 )\n\n- getAllResponseHeaders() __只能__ 拿到 __限制以外__( 被视为 _safe_ ) 的 header 字段 ( 第一条 )。\n\n- getResponseHeader( _header_ ) 方法时, header 参数必须是 __限制以外__的 header, 否则会报错: _Refused to get unsafe header_。 ( 第一条 )\n\n#### 指定 xhr.response 的数据类型\n\n- 使用 level 1 提供的 __overrideMimeType( )__ 方法\n\n比如：\n\n- 我们想要 server 点返回一个 DOM 对象, 就可以设置 __xhr.overrideMimeType('text/xml, charset = utf-8\")__。\n- xhr level 1 __不支持__直接传送 __blob__ 二进制数据, 可以利用 __overrideMimeType()__ 方法\n\n如下 level 1 获取 一张图片\n\n```\nlet xhr = new XMLHttpRequest();\n\n// 获取一张 图片\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\n// 将响应的数据按照纯文本来解析，字符集替换为用户自己定义的字符集\nxhr.overrideMimeType('text/plain; charset=x-user-defined');\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n\n      let blobStr = xhr.responseText;\n    // 逐个字节的还原成二进制数据, 顺序  blobStr[i] --> ASCII( 16 进制 ) -->  2 进制\n      for( let i=0, len = blobStr.length; i<len; ++i ) {\n        let c = blobStr.charCodeAt(i)\n        let byte = c&0xff;\n      }\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\nxhr.send(null);\n```\n通过设置 response 的 content-type 为 \"text/plain;charset=x-user-defined\" ，使 xhr 以纯文本格式解析接收到的 blob 数据, 然后再将其转换为 blob 数据\n\n- xhr.responseType\n\n指定 xhr.response 的数据类型，可以设置如下:\n\n- \"\"   ( String 字符串, 默认 )\n- \"text\"   ( String )\n- \"document\"   ( Document 对象，返回格式为 XML )\n- \"json\"    ( js 对象， __IE10, IE11 不支持__ )\n- \"blob\"\n- \"arrayBuffer\"\n\n获取图片\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\n// 可使用 blob 或者 arrayBuffer\n\nxhr.responseType = 'blob';\n// xhr.responseType = 'arrayBuffer';\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      let blobStr = xhr.response;\n      console.log( blobStr )\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\nxhr.send(null);\n```\n\n结果：\n\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%881.41.54.png)\n\n#### 获取 response 数据\n\n有 3 个属性可以获取返回的数据, 分别是： __xhr.response, xhr.reponseText, xhr.responseXML__\n\n- xhr.response\n  + 默认值: \"\"\n  + 请求__完成__时, 才有正确的值\n  + 请求未完成时,\n    - 当 responseText 为 \"\" 或 \"text\" 时, 值为 \"\"\n    - 当 responseText 为 其他值时, 值为 null\n\n- xhr.responseText\n  + 默认值: \"\"\n  + 只有当 responseType 为 __\"text\", \"\"__ 时, xhr 对象__才有此属性__，此时才能调用 xhr.responseText, 否则 _抛错_\n  + 只有当请求__成功__时, 才能拿到__正确值__。当请求__未完成__或者请求__失败__ 时 值都为 __\"\"__\n\n- xhr.responseXML\n  + 默认值: null\n  + 只有当 __responseType 为 \"text\", \"\",\"document\"__ 时, xhr 对象 __才有此属性__, 此时才能调用 __xhr.responseXML__, 否则抛错\n  + 只有当请求__成功__时, 才能拿到__正确值__。当请求__未完成__, 请求__失败__, 请求__成功但返回数据无法被正确解析__ 时 值都为 __null__\n\n#### 追踪 ajax 请求的当前状态: xhr.readyState\n\n当发送 __异步__请求，接收响应的时候，可以检测 XHR 对象的 __readyState__ 属性，该属性表示 __请求 ／ 响应过程的当前活动阶段__。这个属性可取的值如下：\n\n  - 0: 未初始化。尚未调用 open() 方法。\n  - 1: 启动。已经调用 open() 方法，但是尚未接收到响应。\n  - 2: 发送。已经调用 send() 方法，但尚未接收到响应。\n  - 3: 接收。已经接收到部分响应数据。\n  - __4__: 完成。已经接收到全部响应数据，而且已经可以在客户端使用。\n\n只要 __readyState__ 属性的值__改变__，__都会__触发一次 __readystatechange__ 事件。\n可以__利用__这个事件来__检测__每次__状态变化__后 __readyState__ 的值。\n\nNOTE!!!: 必须在调用 _open()_  __之前__指定 __onreadystatechange__ 事件处理程序才能__确保__跨浏览器__兼容性__。\n\n例子:\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = () => {\n  if( xhr.readyState == 4 ){\n    if( (xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n      console.log( xhr.responseText);\n    } else {\n      console.log(\"Request was unsuccessful: \" + xhr.status);\n    }\n  }\n};\n\n// 我这里调用的依旧是 github react/forks 的 API\nxhr.open(\"get\" , \"https://api.github.com/repos/facebook/react/forks\", true);\n\nxhr.send(null);\n```\n\n结果：\n\n![](http://img.jackon.me/xhr.png)\n\n#### 设置请求超时时间: xhr.timeout\n\n从__请求开始__算起, 若超过 timeout 时间请求还没有结束,  则会触发  ontimeout 事件, 主动结束该请求\n\n请求开始: xhr.onloadstart 事件触发的时候 ( 也就时调用 xhr.send() 的时候 )\n\n请求结束: xhr.loadend 事件触发的时候\n\n- 单位: 毫秒\n- 默认值：0\n\n NOTE:\n - 在 __send() 之后__ 再设置 timeout, 但__计时起点__ 仍旧为调用 __xhr.send()__ 方法的时刻\n - 当 时一个 __同步__ 请求时, xhr.timeout 必须设置为 0, 否则__抛错__\n\n### 进度事件\n\n有 6 个进度事件:\n\n- loadstart: 在接收到响应数据的第一个字节时触发\n- progress: 在接收响应期间持续不断触发\n- error: 在请求发生错误时触发\n- abort: 在因为调用 abort() 方法而终止连接时触发\n- load: 在接收到完整的响应数据时触发\n- loadend: 在通信完成或者触发 error, abort, load 事件中的一个\n\n每个请求都从触发 __loadstart__ 事件开始, 接下来是 __一个或者 多个__\n__progress__ 事件，然后以触发 __loadend__ 事件结束\n\nNOTE:\n- __lE8+ 只支持 load 事件。__\n- 没有浏览器支持 loadend 事件\n\n#### load 事件\n\n只要浏览器接收到服务器的响应，__不管其状态如何__，都会触发 load 事件。所以每次 __必须__ 检查 __status__ 属性, 才能__确定__数据是否真的已经可用。 Firefox, Opera, Chrome, Safari 都支持 load 事件\n\n```\nlet xhr = new XMLHttpRequest();\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\nxhr.responseType = 'arrayBuffer';\n\nxhr.onload = () => {\n  if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n    console.log(xhr.responseText );\n  } else {\n    console.log(\"Request was unsuccessful: \" + xhr.status);\n  }\n}\nxhr.send(null);\n```\n\n#### progress 事件\n 这个事件会在浏览器接收新数据期间周期性地触发，默认情况下这个事件__每 50ms__ 触发一次。\n\n __onprogress__ 事件处理程序会接收一个 __event__ 事件, 其 __target 属性__ 是 XHR 对象, 但包含着三个额外的属性:\n\n- lengthComputable: 表示进度信息是否可用的布尓值\n- position: __已经接收__的字节数\n- totalSize: 表示 根据 Content-length 响应头部确定的预期字节数.\n\n_上传，下载过程触发的是不同对象的 onprogress 事件_:\n\n- 上传: xhr.upload 对象的 onprogress 事件\n- 下载: xhr 对象的 onprogress 事件\n\n必须在调用 __open()__ 方法__之前__添加 onprogress 事件处理程序\n```\nlet log = document.querySelector(\"#log\")\n\nfunction downProgress(e) {\n   log.innerHTML = `Received <strong>${e.position}</strong> of <strong>${e.totalSize}</strong> bytes`\n}\n\nlet xhr = new XMLHttpRequest();\n\nxhr.onprogress = (e) => {\n  console.log( 'onprogress' )\n  if( e.lengthComputable ) {\n    downProgress(e)\n  }\n}\n\nxhr.onload = () => {\n  if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n    console.log(xhr.responseText );\n  } else {\n    console.log(\"Request was unsuccessful: \" + xhr.status);\n  }\n}\n\nxhr.open(\"get\" , \"http://img.jackon.me/cheese.jpeg\", true);\n\nxhr.responseType = 'arrayBuffer';\n\nxhr.send(null);\n```\n\n结果;\n\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%886.54.00.png)\n\n\n{% blockquote %}\n\n参考：\n\n[你真的会使用 XMLHttpRequest 吗？](https://segmentfault.com/a/1190000004322487)\n\n_JavaScript 高级程序设计_\n{% endblockquote %}\n\n","slug":"XMLHttpRequest","published":1,"date":"2016-12-16T13:40:04.000Z","updated":"2016-12-18T17:12:53.000Z","_id":"ciwu3unnk00007qrauogb2v6r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。</p>\n<p>Ajax 技术的核心是 XMLHttpRequest 对象( 简称 XHR ),</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"初始化-xhr-open-method-url-async-user-password\"><a href=\"#初始化-xhr-open-method-url-async-user-password\" class=\"headerlink\" title=\"初始化: xhr.open(method, url, async, user, password);\"></a>初始化: xhr.open(<em>method, url, async, user, password</em>);</h4><ul>\n<li><p>接收 5 个参数:</p>\n<ul>\n<li>method: 要发送的请求类型</li>\n<li>url: 请求的 URL ( 相对路径的话是相对执行代码的当前页面, 也可以是绝对路径 )</li>\n<li>async: 是否异步发送请求</li>\n<li>user: 可选。用于身份验证的目的。默认值为 null</li>\n<li>password:可选。也是用于身份验证的目的。默认值为 null</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>当使用的是<em>同步</em>请求的时候，有如下<em>限制</em> ( 否则会报错: <em>InvalidAccessError</em> )：</p>\n<ul>\n<li>xhr.timeout 必须为 0</li>\n<li>xhr.withCredentials 必须为 false</li>\n<li>xhr.responseType 必须为 “”</li>\n</ul>\n<p>NOTE:</p>\n<ul>\n<li><p>初始化一个请求，如果是本地代码，请使用 <strong>openRequest()</strong>代替</p>\n</li>\n<li><p>在一个已经激活的 request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了<strong>abort()</strong> 方法。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &apos;get&apos;, &apos;example.php&apos;, false );</div></pre></td></tr></table></figure>\n<h4 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h4><p>最常用于向服务器查询某些信息。<br>必要时，可以将查询字符串参数追加到 URL 末尾.</p>\n<p>对于 XHR，位于传入 open() 方法的 URL 末尾的查询字符串:</p>\n<ul>\n<li>必须要使用 <strong>encodeURIComponent()</strong> 进行编码, 才能放到 URL 的末尾</li>\n<li>所有<strong>名-值对</strong> 都必须 &amp; 分隔。<br>如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open(&quot;get&quot;, &quot;example.php?name1=value&amp;name2=value2&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 这个函数可以辅助向现有 URL 的末尾添加查询字符串参数</div><div class=\"line\"></div><div class=\"line\">function addURLParam( url, name, value ) &#123;</div><div class=\"line\">  url += ( url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot; );</div><div class=\"line\">  url += encodeURIComponent( name ) + &quot;=&quot; + encodeURIComponent( value );</div><div class=\"line\">  return url;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"POST-请求\"><a href=\"#POST-请求\" class=\"headerlink\" title=\"POST 请求\"></a>POST 请求</h4><h5 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h5><ul>\n<li>通常用于向服务器发送应该被保存的数据</li>\n<li>POST 请求应该把数据作为请求主体提交。 send( data )</li>\n<li>POST 请求的主体可以包含非常多的数据, 各式不限。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &quot;psot&quot;, &quot;example.php&quot;, true)</div></pre></td></tr></table></figure>\n<h5 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h5><p>然后向 send() 方法中传入某些数据。</p>\n<p><strong>默认情况下</strong>， 服务器对 <strong>POST</strong> 请求和 提交 <strong>Form</strong> 表单并不会<strong>一视同仁</strong>。所以服务器端必须要有程序来<strong>读取</strong>发送过来的原始数据，并从中<strong>解析</strong>出有用的部分。</p>\n<p>我们可以使用 <em>XHR 模仿</em>表单提交时的内容类型，其次是以<strong>适当的格式</strong>创建一个字符串。<br><strong>POST 数据的格式与查询字符串格式相同</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">function submitData() &#123;</div><div class=\"line\">  var xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">  xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">    if( xhr.readyState == 4 )&#123;</div><div class=\"line\">      if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">        console.log(xhr.responseText);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  xhr.open(&quot;POST&quot;, &quot;postexample.php&quot;, true );</div><div class=\"line\">  // 表单提交时的内容类型</div><div class=\"line\">  xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot; );</div><div class=\"line\">  var form = document.getElementById(&quot;user-info&quot;);</div><div class=\"line\"></div><div class=\"line\">  // 将页面中的表单数据进行序列化</div><div class=\"line\">  xhr.send( serialize( form ) );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"FormData-类型\"><a href=\"#FormData-类型\" class=\"headerlink\" title=\"FormData 类型\"></a>FormData 类型</h5><p>为序列化表单以及创建与表单格式相同的数据提供了便利。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第 1 种方法</div><div class=\"line\">let data = new FormData();</div><div class=\"line\">data.append(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 第 2 种方法</div><div class=\"line\">let data = new FormData(document.forms[0]);</div></pre></td></tr></table></figure>\n<p>append 接收 2 个参数: 键和值</p>\n<ul>\n<li>可以通过 append 添加任意多个键值对。</li>\n<li>也可以通过向 FormData 构造函数中传入表单元素</li>\n</ul>\n<p>创建 FormData 的实例之后， 可以将它直接传给 XHR 的 send()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">      console.log(xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;POST&quot;, &quot;postexample.php&quot;, true );</div><div class=\"line\">var form = document.getElementById(&quot;user-info&quot;);</div><div class=\"line\">xhr.send(new FormData(form) );</div></pre></td></tr></table></figure>\n<h4 id=\"发送请求-xhr-send-data\"><a href=\"#发送请求-xhr-send-data\" class=\"headerlink\" title=\"发送请求: xhr.send( data )\"></a>发送请求: xhr.send( <em>data</em> )</h4><ul>\n<li><p>接收 1 个参数：data</p>\n<ul>\n<li>作为请求主体发送的数据</li>\n</ul>\n</li>\n<li><p>参数 data 可以是以下几种类型：</p>\n<ul>\n<li>ArrayBuffer</li>\n<li>Blob</li>\n<li>Document</li>\n<li>DOMString</li>\n<li>FormData</li>\n<li>null</li>\n</ul>\n</li>\n<li><p>如果不需要通过请求主体发送数据，需传入 null</p>\n</li>\n</ul>\n<p>NOTE: 如果使用 <em>GET / HEAD</em> 请求，参数 <em>data</em> 会被设置为 <em>null</em></p>\n<p><em>data</em> 参数的<em>数据类型</em>会<strong>影响</strong>请求头部的 <strong>content-type</strong> 的 <strong>默认值</strong>：</p>\n<ul>\n<li>data: <strong>Document ( HTML Document 类型 )</strong>，则 content-type: <strong>text/html</strong>;charset=UTF-8; 否则为 <strong>application/xml</strong>;charset=UTF-8</li>\n<li>data: <strong>DOMString</strong>, content-type: <strong>text/plain</strong>;charset=UTF-8</li>\n<li>data: <strong>FormData</strong>, content-type: <strong>multipart/form-data</strong>;boundary=[xxx]</li>\n<li>data 是其他类型， 则<strong>不会设置</strong> content-type 的默认值</li>\n</ul>\n<p>基本使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure>\n<p>在<strong>断网</strong>状态下调用 xhr.send(data), 会<strong>抛错</strong>：Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’ 。一旦程序抛错误，若不 catch 就无法继续执行后面的代码，所以调用 xhr.send(), 应该用 <strong>try-catch</strong> 捕捉错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">  xhr.send(data)</div><div class=\"line\">&#125; catch(e) &#123;</div><div class=\"line\">  //do something...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"取消异步请求-xhr-abort\"><a href=\"#取消异步请求-xhr-abort\" class=\"headerlink\" title=\"取消异步请求: xhr.abort()\"></a>取消异步请求: xhr.abort()</h4><p>调用这个方法之后， XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。</p>\n<p>在<em>终止请求</em>之后，<strong>还应该对 XHR 对象进行接引用操作</strong>。由于内存原因, 不建议重用 XHR 对象。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h4><ul>\n<li>调用 send() 之后，请求就会被分派到服务器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &apos;get&apos;, &apos;example.php&apos;, false );</div><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure>\n<p>👆的请求是 <em>同步</em>的，JS 代码会 <em>等到服务器响应之后</em>再继续执行。</p>\n<ul>\n<li><p>收到响应后，响应的 <em>数据</em>会自动填充 XHR 对象的属性，相关属性:   ( <strong>具体可以看后面</strong> )</p>\n<ul>\n<li>responseText: 作为响应的主体背返回的文本。</li>\n<li>responseXML: 如果响应的内容类型是 “text / xml” 或者 “application / xml”, 这个属性中将保存 <em>包含着响应数据的 XML DOM 文档</em></li>\n<li>status: 响应的 HTTP 状态</li>\n<li>statusText: HTTP 状态的说明</li>\n</ul>\n</li>\n<li><p>接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。</p>\n<ul>\n<li>一般来说，可将 HTTP 状态代码为 <strong>200</strong> 作为成功的标志</li>\n<li><p>此时， responseText 属性内容已经就绪，而且在内容类型正确的情况下， responseXML 也应该能够访问了。</p>\n</li>\n<li><p>状态代码: <strong>304</strong>表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本, 当然也表示响应是有效的</p>\n</li>\n<li><p><strong>为确保接收到适当的响应，应该像👇这样检查上述代码 (<em>不要依赖 statusText</em>) ：</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot;, &quot;https://api.github.com/repos/facebook/react/forks&quot;, false);</div><div class=\"line\">xhr.send(null);</div><div class=\"line\"></div><div class=\"line\">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">  console.log(xhr.responseText);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果</p>\n<p><img src=\"http://img.jackon.me/xhr1.png\" alt=\"\"></p>\n<h5 id=\"同步请求-NOTE\"><a href=\"#同步请求-NOTE\" class=\"headerlink\" title=\"同步请求 NOTE:\"></a>同步请求 NOTE:</h5><p>当 xhr 为同步时：</p>\n<ul>\n<li>xhr.timeout: 需为 0</li>\n<li>xhr.withCredentials: 需为 false</li>\n<li>xhr.responseType: 需为 “”</li>\n<li>无法设置 请求超时 ( xhr.timeout )</li>\n<li>xhr.upload.onprogress , xhr.onprogress 事件不会触发</li>\n</ul>\n<h3 id=\"HTTP-头部信息-不太能用到\"><a href=\"#HTTP-头部信息-不太能用到\" class=\"headerlink\" title=\"HTTP 头部信息 ( 不太能用到 )\"></a>HTTP 头部信息 ( 不太能用到 )</h3><p>每个 HTTP 请求和响应都会带有相应的头部信息( 并不一定都有用 )<br>XHR 对象也提供了操作这两种头部 ( 即<strong>请求头部和响应头部</strong> ) 信息的方法。</p>\n<p>默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息：</p>\n<ul>\n<li>Accept: 浏览器能够处理的内容类型</li>\n<li>Accept-Charset: 浏览器能够显示的字符集</li>\n<li>Accept-Encoding: 浏览器能够处理的压缩编码</li>\n<li>Accept-Language: 浏览器当前设置的语言</li>\n<li>Connection: 浏览器与服务器之间连接的类型</li>\n<li>Cookie: 当前页面设置的任何 Cookie</li>\n<li>Host: 发送请的页面所在的域</li>\n<li>Referer: 发送请求的页面的 URL。( 这个英文单词应该是 Referrer, 然而 HTTP 规范将这个词拼错了，所以只能讲错就错 )</li>\n<li>User-Agent: 浏览器的用户代理字符串</li>\n</ul>\n<h4 id=\"setRequestHeader-DOMString-header-DOMString-value\"><a href=\"#setRequestHeader-DOMString-header-DOMString-value\" class=\"headerlink\" title=\"setRequestHeader( DOMString header, DOMString value )\"></a>setRequestHeader( <em>DOMString header, DOMString value</em> )</h4><p>使用 <strong>setRequestHeader()</strong> 方法可以<strong>设置</strong>请求头部信息__</p>\n<ul>\n<li>接受 2 个参数：头部字段的名称， 头部字段的值</li>\n<li>要成功发送请求头部的信息，必须在调用 <strong>open() 之后， send() 之前</strong> 调用 setRequestHeader()</li>\n<li>可以多次调用, 最终的值不会采用覆盖 ( override ) 的方式, 而是采用追加 append 的方式。</li>\n<li>建议使用 <strong>自定义</strong>头部字段名称，否则可能会影响服务器端的响应</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      console.log( xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的依旧是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;https://api.github.com/repos/facebook/react/forks&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);</div><div class=\"line\">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;HerValue&quot;);</div><div class=\"line\">// 最终的 header 中的 &quot;MyHeader&quot; 为 &quot;MyValue&quot;, &quot;HerValue&quot;</div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<h4 id=\"获取响应头部-safe-的字段\"><a href=\"#获取响应头部-safe-的字段\" class=\"headerlink\" title=\"获取响应头部 ( safe 的字段 )\"></a>获取响应头部 ( <em>safe</em> 的字段 )</h4><ul>\n<li>getResponseHeader( <em>DOMString header</em> )</li>\n</ul>\n<p>返回 <strong>指定的响应的值</strong>，如果响应头还没被接受或者响应头不存在，返回 <strong>null</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li>getAllResponseHeaders()</li>\n</ul>\n<p>返回所有的响应头信息。如果响应头还没有接受，则返回 null.</p>\n<p>NOTE: For multipart requests, this returns the headers from the current part of the request, not from the original channel.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let allHeaders = xhr.getAllResponseHeaders();</div></pre></td></tr></table></figure>\n<p>NOTE：</p>\n<ul>\n<li><p>W3C 限制：客户端无法获取 response <strong>Set-Cookie, Set-Cookie2</strong>( xhr 标准 ); <strong>跨域请求时</strong>客户端允许获取 <strong>simple response header,  Access-Control-Expose-Headers</strong>( cors 标准 )</p>\n</li>\n<li><p>getAllResponseHeaders() <strong>只能</strong> 拿到 <strong>限制以外</strong>( 被视为 <em>safe</em> ) 的 header 字段 ( 第一条 )。</p>\n</li>\n<li><p>getResponseHeader( <em>header</em> ) 方法时, header 参数必须是 <strong>限制以外</strong>的 header, 否则会报错: <em>Refused to get unsafe header</em>。 ( 第一条 )</p>\n</li>\n</ul>\n<h4 id=\"指定-xhr-response-的数据类型\"><a href=\"#指定-xhr-response-的数据类型\" class=\"headerlink\" title=\"指定 xhr.response 的数据类型\"></a>指定 xhr.response 的数据类型</h4><ul>\n<li>使用 level 1 提供的 <strong>overrideMimeType( )</strong> 方法</li>\n</ul>\n<p>比如：</p>\n<ul>\n<li>我们想要 server 点返回一个 DOM 对象, 就可以设置 <strong>xhr.overrideMimeType(‘text/xml, charset = utf-8”)</strong>。</li>\n<li>xhr level 1 <strong>不支持</strong>直接传送 <strong>blob</strong> 二进制数据, 可以利用 <strong>overrideMimeType()</strong> 方法</li>\n</ul>\n<p>如下 level 1 获取 一张图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">// 获取一张 图片</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 将响应的数据按照纯文本来解析，字符集替换为用户自己定义的字符集</div><div class=\"line\">xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\"></div><div class=\"line\">      let blobStr = xhr.responseText;</div><div class=\"line\">    // 逐个字节的还原成二进制数据, 顺序  blobStr[i] --&gt; ASCII( 16 进制 ) --&gt;  2 进制</div><div class=\"line\">      for( let i=0, len = blobStr.length; i&lt;len; ++i ) &#123;</div><div class=\"line\">        let c = blobStr.charCodeAt(i)</div><div class=\"line\">        let byte = c&amp;0xff;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>通过设置 response 的 content-type 为 “text/plain;charset=x-user-defined” ，使 xhr 以纯文本格式解析接收到的 blob 数据, 然后再将其转换为 blob 数据</p>\n<ul>\n<li>xhr.responseType</li>\n</ul>\n<p>指定 xhr.response 的数据类型，可以设置如下:</p>\n<ul>\n<li>“”   ( String 字符串, 默认 )</li>\n<li>“text”   ( String )</li>\n<li>“document”   ( Document 对象，返回格式为 XML )</li>\n<li>“json”    ( js 对象， <strong>IE10, IE11 不支持</strong> )</li>\n<li>“blob”</li>\n<li>“arrayBuffer”</li>\n</ul>\n<p>获取图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 可使用 blob 或者 arrayBuffer</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;blob&apos;;</div><div class=\"line\">// xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      let blobStr = xhr.response;</div><div class=\"line\">      console.log( blobStr )</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%881.41.54.png\" alt=\"\"></p>\n<h4 id=\"获取-response-数据\"><a href=\"#获取-response-数据\" class=\"headerlink\" title=\"获取 response 数据\"></a>获取 response 数据</h4><p>有 3 个属性可以获取返回的数据, 分别是： <strong>xhr.response, xhr.reponseText, xhr.responseXML</strong></p>\n<ul>\n<li><p>xhr.response</p>\n<ul>\n<li>默认值: “”</li>\n<li>请求<strong>完成</strong>时, 才有正确的值</li>\n<li>请求未完成时,<ul>\n<li>当 responseText 为 “” 或 “text” 时, 值为 “”</li>\n<li>当 responseText 为 其他值时, 值为 null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>xhr.responseText</p>\n<ul>\n<li>默认值: “”</li>\n<li>只有当 responseType 为 <strong>“text”, “”</strong> 时, xhr 对象<strong>才有此属性</strong>，此时才能调用 xhr.responseText, 否则 <em>抛错</em></li>\n<li>只有当请求<strong>成功</strong>时, 才能拿到<strong>正确值</strong>。当请求<strong>未完成</strong>或者请求<strong>失败</strong> 时 值都为 <strong>“”</strong></li>\n</ul>\n</li>\n<li><p>xhr.responseXML</p>\n<ul>\n<li>默认值: null</li>\n<li>只有当 <strong>responseType 为 “text”, “”,”document”</strong> 时, xhr 对象 <strong>才有此属性</strong>, 此时才能调用 <strong>xhr.responseXML</strong>, 否则抛错</li>\n<li>只有当请求<strong>成功</strong>时, 才能拿到<strong>正确值</strong>。当请求<strong>未完成</strong>, 请求<strong>失败</strong>, 请求<strong>成功但返回数据无法被正确解析</strong> 时 值都为 <strong>null</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"追踪-ajax-请求的当前状态-xhr-readyState\"><a href=\"#追踪-ajax-请求的当前状态-xhr-readyState\" class=\"headerlink\" title=\"追踪 ajax 请求的当前状态: xhr.readyState\"></a>追踪 ajax 请求的当前状态: xhr.readyState</h4><p>当发送 <strong>异步</strong>请求，接收响应的时候，可以检测 XHR 对象的 <strong>readyState</strong> 属性，该属性表示 <strong>请求 ／ 响应过程的当前活动阶段</strong>。这个属性可取的值如下：</p>\n<ul>\n<li>0: 未初始化。尚未调用 open() 方法。</li>\n<li>1: 启动。已经调用 open() 方法，但是尚未接收到响应。</li>\n<li>2: 发送。已经调用 send() 方法，但尚未接收到响应。</li>\n<li>3: 接收。已经接收到部分响应数据。</li>\n<li><strong>4</strong>: 完成。已经接收到全部响应数据，而且已经可以在客户端使用。</li>\n</ul>\n<p>只要 <strong>readyState</strong> 属性的值<strong>改变</strong>，<strong>都会</strong>触发一次 <strong>readystatechange</strong> 事件。<br>可以<strong>利用</strong>这个事件来<strong>检测</strong>每次<strong>状态变化</strong>后 <strong>readyState</strong> 的值。</p>\n<p>NOTE!!!: 必须在调用 <em>open()</em>  <strong>之前</strong>指定 <strong>onreadystatechange</strong> 事件处理程序才能<strong>确保</strong>跨浏览器<strong>兼容性</strong>。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      console.log( xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的依旧是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;https://api.github.com/repos/facebook/react/forks&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/xhr.png\" alt=\"\"></p>\n<h4 id=\"设置请求超时时间-xhr-timeout\"><a href=\"#设置请求超时时间-xhr-timeout\" class=\"headerlink\" title=\"设置请求超时时间: xhr.timeout\"></a>设置请求超时时间: xhr.timeout</h4><p>从<strong>请求开始</strong>算起, 若超过 timeout 时间请求还没有结束,  则会触发  ontimeout 事件, 主动结束该请求</p>\n<p>请求开始: xhr.onloadstart 事件触发的时候 ( 也就时调用 xhr.send() 的时候 )</p>\n<p>请求结束: xhr.loadend 事件触发的时候</p>\n<ul>\n<li>单位: 毫秒</li>\n<li><p>默认值：0</p>\n<p>NOTE:</p>\n<ul>\n<li>在 <strong>send() 之后</strong> 再设置 timeout, 但<strong>计时起点</strong> 仍旧为调用 <strong>xhr.send()</strong> 方法的时刻</li>\n<li>当 时一个 <strong>同步</strong> 请求时, xhr.timeout 必须设置为 0, 否则<strong>抛错</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进度事件\"><a href=\"#进度事件\" class=\"headerlink\" title=\"进度事件\"></a>进度事件</h3><p>有 6 个进度事件:</p>\n<ul>\n<li>loadstart: 在接收到响应数据的第一个字节时触发</li>\n<li>progress: 在接收响应期间持续不断触发</li>\n<li>error: 在请求发生错误时触发</li>\n<li>abort: 在因为调用 abort() 方法而终止连接时触发</li>\n<li>load: 在接收到完整的响应数据时触发</li>\n<li>loadend: 在通信完成或者触发 error, abort, load 事件中的一个</li>\n</ul>\n<p>每个请求都从触发 <strong>loadstart</strong> 事件开始, 接下来是 <strong>一个或者 多个</strong><br><strong>progress</strong> 事件，然后以触发 <strong>loadend</strong> 事件结束</p>\n<p>NOTE:</p>\n<ul>\n<li><strong>lE8+ 只支持 load 事件。</strong></li>\n<li>没有浏览器支持 loadend 事件</li>\n</ul>\n<h4 id=\"load-事件\"><a href=\"#load-事件\" class=\"headerlink\" title=\"load 事件\"></a>load 事件</h4><p>只要浏览器接收到服务器的响应，<strong>不管其状态如何</strong>，都会触发 load 事件。所以每次 <strong>必须</strong> 检查 <strong>status</strong> 属性, 才能<strong>确定</strong>数据是否真的已经可用。 Firefox, Opera, Chrome, Safari 都支持 load 事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = () =&gt; &#123;</div><div class=\"line\">  if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">    console.log(xhr.responseText );</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<h4 id=\"progress-事件\"><a href=\"#progress-事件\" class=\"headerlink\" title=\"progress 事件\"></a>progress 事件</h4><p> 这个事件会在浏览器接收新数据期间周期性地触发，默认情况下这个事件<strong>每 50ms</strong> 触发一次。</p>\n<p> <strong>onprogress</strong> 事件处理程序会接收一个 <strong>event</strong> 事件, 其 <strong>target 属性</strong> 是 XHR 对象, 但包含着三个额外的属性:</p>\n<ul>\n<li>lengthComputable: 表示进度信息是否可用的布尓值</li>\n<li>position: <strong>已经接收</strong>的字节数</li>\n<li>totalSize: 表示 根据 Content-length 响应头部确定的预期字节数.</li>\n</ul>\n<p><em>上传，下载过程触发的是不同对象的 onprogress 事件</em>:</p>\n<ul>\n<li>上传: xhr.upload 对象的 onprogress 事件</li>\n<li>下载: xhr 对象的 onprogress 事件</li>\n</ul>\n<p>必须在调用 <strong>open()</strong> 方法<strong>之前</strong>添加 onprogress 事件处理程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">let log = document.querySelector(&quot;#log&quot;)</div><div class=\"line\"></div><div class=\"line\">function downProgress(e) &#123;</div><div class=\"line\">   log.innerHTML = `Received &lt;strong&gt;$&#123;e.position&#125;&lt;/strong&gt; of &lt;strong&gt;$&#123;e.totalSize&#125;&lt;/strong&gt; bytes`</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onprogress = (e) =&gt; &#123;</div><div class=\"line\">  console.log( &apos;onprogress&apos; )</div><div class=\"line\">  if( e.lengthComputable ) &#123;</div><div class=\"line\">    downProgress(e)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = () =&gt; &#123;</div><div class=\"line\">  if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">    console.log(xhr.responseText );</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure></p>\n<p>结果;</p>\n<p><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%886.54.00.png\" alt=\"\"></p>\n<blockquote><p>参考：</p>\n<p><a href=\"https://segmentfault.com/a/1190000004322487\" target=\"_blank\" rel=\"external\">你真的会使用 XMLHttpRequest 吗？</a></p>\n<p><em>JavaScript 高级程序设计</em></p>\n</blockquote>\n","excerpt":"<p>感觉很少仔细看部分，前两天面试的时候有问到，今天重新看下。</p>\n<p>Ajax 技术的核心是 XMLHttpRequest 对象( 简称 XHR ),</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"初始化-xhr-open-method-url-async-user-password\"><a href=\"#初始化-xhr-open-method-url-async-user-password\" class=\"headerlink\" title=\"初始化: xhr.open(method, url, async, user, password);\"></a>初始化: xhr.open(<em>method, url, async, user, password</em>);</h4><ul>\n<li><p>接收 5 个参数:</p>\n<ul>\n<li>method: 要发送的请求类型</li>\n<li>url: 请求的 URL ( 相对路径的话是相对执行代码的当前页面, 也可以是绝对路径 )</li>\n<li>async: 是否异步发送请求</li>\n<li>user: 可选。用于身份验证的目的。默认值为 null</li>\n<li>password:可选。也是用于身份验证的目的。默认值为 null</li>\n</ul>\n</li>\n</ul>","more":"<p>当使用的是<em>同步</em>请求的时候，有如下<em>限制</em> ( 否则会报错: <em>InvalidAccessError</em> )：</p>\n<ul>\n<li>xhr.timeout 必须为 0</li>\n<li>xhr.withCredentials 必须为 false</li>\n<li>xhr.responseType 必须为 “”</li>\n</ul>\n<p>NOTE:</p>\n<ul>\n<li><p>初始化一个请求，如果是本地代码，请使用 <strong>openRequest()</strong>代替</p>\n</li>\n<li><p>在一个已经激活的 request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了<strong>abort()</strong> 方法。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &apos;get&apos;, &apos;example.php&apos;, false );</div></pre></td></tr></table></figure>\n<h4 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h4><p>最常用于向服务器查询某些信息。<br>必要时，可以将查询字符串参数追加到 URL 末尾.</p>\n<p>对于 XHR，位于传入 open() 方法的 URL 末尾的查询字符串:</p>\n<ul>\n<li>必须要使用 <strong>encodeURIComponent()</strong> 进行编码, 才能放到 URL 的末尾</li>\n<li>所有<strong>名-值对</strong> 都必须 &amp; 分隔。<br>如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open(&quot;get&quot;, &quot;example.php?name1=value&amp;name2=value2&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 这个函数可以辅助向现有 URL 的末尾添加查询字符串参数</div><div class=\"line\"></div><div class=\"line\">function addURLParam( url, name, value ) &#123;</div><div class=\"line\">  url += ( url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot; );</div><div class=\"line\">  url += encodeURIComponent( name ) + &quot;=&quot; + encodeURIComponent( value );</div><div class=\"line\">  return url;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"POST-请求\"><a href=\"#POST-请求\" class=\"headerlink\" title=\"POST 请求\"></a>POST 请求</h4><h5 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h5><ul>\n<li>通常用于向服务器发送应该被保存的数据</li>\n<li>POST 请求应该把数据作为请求主体提交。 send( data )</li>\n<li>POST 请求的主体可以包含非常多的数据, 各式不限。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &quot;psot&quot;, &quot;example.php&quot;, true)</div></pre></td></tr></table></figure>\n<h5 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h5><p>然后向 send() 方法中传入某些数据。</p>\n<p><strong>默认情况下</strong>， 服务器对 <strong>POST</strong> 请求和 提交 <strong>Form</strong> 表单并不会<strong>一视同仁</strong>。所以服务器端必须要有程序来<strong>读取</strong>发送过来的原始数据，并从中<strong>解析</strong>出有用的部分。</p>\n<p>我们可以使用 <em>XHR 模仿</em>表单提交时的内容类型，其次是以<strong>适当的格式</strong>创建一个字符串。<br><strong>POST 数据的格式与查询字符串格式相同</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">function submitData() &#123;</div><div class=\"line\">  var xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">  xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">    if( xhr.readyState == 4 )&#123;</div><div class=\"line\">      if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">        console.log(xhr.responseText);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  xhr.open(&quot;POST&quot;, &quot;postexample.php&quot;, true );</div><div class=\"line\">  // 表单提交时的内容类型</div><div class=\"line\">  xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot; );</div><div class=\"line\">  var form = document.getElementById(&quot;user-info&quot;);</div><div class=\"line\"></div><div class=\"line\">  // 将页面中的表单数据进行序列化</div><div class=\"line\">  xhr.send( serialize( form ) );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"FormData-类型\"><a href=\"#FormData-类型\" class=\"headerlink\" title=\"FormData 类型\"></a>FormData 类型</h5><p>为序列化表单以及创建与表单格式相同的数据提供了便利。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第 1 种方法</div><div class=\"line\">let data = new FormData();</div><div class=\"line\">data.append(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class=\"line\"></div><div class=\"line\">// 第 2 种方法</div><div class=\"line\">let data = new FormData(document.forms[0]);</div></pre></td></tr></table></figure>\n<p>append 接收 2 个参数: 键和值</p>\n<ul>\n<li>可以通过 append 添加任意多个键值对。</li>\n<li>也可以通过向 FormData 构造函数中传入表单元素</li>\n</ul>\n<p>创建 FormData 的实例之后， 可以将它直接传给 XHR 的 send()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">      console.log(xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;POST&quot;, &quot;postexample.php&quot;, true );</div><div class=\"line\">var form = document.getElementById(&quot;user-info&quot;);</div><div class=\"line\">xhr.send(new FormData(form) );</div></pre></td></tr></table></figure>\n<h4 id=\"发送请求-xhr-send-data\"><a href=\"#发送请求-xhr-send-data\" class=\"headerlink\" title=\"发送请求: xhr.send( data )\"></a>发送请求: xhr.send( <em>data</em> )</h4><ul>\n<li><p>接收 1 个参数：data</p>\n<ul>\n<li>作为请求主体发送的数据</li>\n</ul>\n</li>\n<li><p>参数 data 可以是以下几种类型：</p>\n<ul>\n<li>ArrayBuffer</li>\n<li>Blob</li>\n<li>Document</li>\n<li>DOMString</li>\n<li>FormData</li>\n<li>null</li>\n</ul>\n</li>\n<li><p>如果不需要通过请求主体发送数据，需传入 null</p>\n</li>\n</ul>\n<p>NOTE: 如果使用 <em>GET / HEAD</em> 请求，参数 <em>data</em> 会被设置为 <em>null</em></p>\n<p><em>data</em> 参数的<em>数据类型</em>会<strong>影响</strong>请求头部的 <strong>content-type</strong> 的 <strong>默认值</strong>：</p>\n<ul>\n<li>data: <strong>Document ( HTML Document 类型 )</strong>，则 content-type: <strong>text/html</strong>;charset=UTF-8; 否则为 <strong>application/xml</strong>;charset=UTF-8</li>\n<li>data: <strong>DOMString</strong>, content-type: <strong>text/plain</strong>;charset=UTF-8</li>\n<li>data: <strong>FormData</strong>, content-type: <strong>multipart/form-data</strong>;boundary=[xxx]</li>\n<li>data 是其他类型， 则<strong>不会设置</strong> content-type 的默认值</li>\n</ul>\n<p>基本使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure>\n<p>在<strong>断网</strong>状态下调用 xhr.send(data), 会<strong>抛错</strong>：Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’ 。一旦程序抛错误，若不 catch 就无法继续执行后面的代码，所以调用 xhr.send(), 应该用 <strong>try-catch</strong> 捕捉错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">  xhr.send(data)</div><div class=\"line\">&#125; catch(e) &#123;</div><div class=\"line\">  //do something...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"取消异步请求-xhr-abort\"><a href=\"#取消异步请求-xhr-abort\" class=\"headerlink\" title=\"取消异步请求: xhr.abort()\"></a>取消异步请求: xhr.abort()</h4><p>调用这个方法之后， XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。</p>\n<p>在<em>终止请求</em>之后，<strong>还应该对 XHR 对象进行接引用操作</strong>。由于内存原因, 不建议重用 XHR 对象。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"同步请求\"><a href=\"#同步请求\" class=\"headerlink\" title=\"同步请求\"></a>同步请求</h4><ul>\n<li>调用 send() 之后，请求就会被分派到服务器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xhr.open( &apos;get&apos;, &apos;example.php&apos;, false );</div><div class=\"line\">xhr.send();</div></pre></td></tr></table></figure>\n<p>👆的请求是 <em>同步</em>的，JS 代码会 <em>等到服务器响应之后</em>再继续执行。</p>\n<ul>\n<li><p>收到响应后，响应的 <em>数据</em>会自动填充 XHR 对象的属性，相关属性:   ( <strong>具体可以看后面</strong> )</p>\n<ul>\n<li>responseText: 作为响应的主体背返回的文本。</li>\n<li>responseXML: 如果响应的内容类型是 “text / xml” 或者 “application / xml”, 这个属性中将保存 <em>包含着响应数据的 XML DOM 文档</em></li>\n<li>status: 响应的 HTTP 状态</li>\n<li>statusText: HTTP 状态的说明</li>\n</ul>\n</li>\n<li><p>接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。</p>\n<ul>\n<li>一般来说，可将 HTTP 状态代码为 <strong>200</strong> 作为成功的标志</li>\n<li><p>此时， responseText 属性内容已经就绪，而且在内容类型正确的情况下， responseXML 也应该能够访问了。</p>\n</li>\n<li><p>状态代码: <strong>304</strong>表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本, 当然也表示响应是有效的</p>\n</li>\n<li><p><strong>为确保接收到适当的响应，应该像👇这样检查上述代码 (<em>不要依赖 statusText</em>) ：</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot;, &quot;https://api.github.com/repos/facebook/react/forks&quot;, false);</div><div class=\"line\">xhr.send(null);</div><div class=\"line\"></div><div class=\"line\">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304 ) &#123;</div><div class=\"line\">  console.log(xhr.responseText);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果</p>\n<p><img src=\"http://img.jackon.me/xhr1.png\" alt=\"\"></p>\n<h5 id=\"同步请求-NOTE\"><a href=\"#同步请求-NOTE\" class=\"headerlink\" title=\"同步请求 NOTE:\"></a>同步请求 NOTE:</h5><p>当 xhr 为同步时：</p>\n<ul>\n<li>xhr.timeout: 需为 0</li>\n<li>xhr.withCredentials: 需为 false</li>\n<li>xhr.responseType: 需为 “”</li>\n<li>无法设置 请求超时 ( xhr.timeout )</li>\n<li>xhr.upload.onprogress , xhr.onprogress 事件不会触发</li>\n</ul>\n<h3 id=\"HTTP-头部信息-不太能用到\"><a href=\"#HTTP-头部信息-不太能用到\" class=\"headerlink\" title=\"HTTP 头部信息 ( 不太能用到 )\"></a>HTTP 头部信息 ( 不太能用到 )</h3><p>每个 HTTP 请求和响应都会带有相应的头部信息( 并不一定都有用 )<br>XHR 对象也提供了操作这两种头部 ( 即<strong>请求头部和响应头部</strong> ) 信息的方法。</p>\n<p>默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息：</p>\n<ul>\n<li>Accept: 浏览器能够处理的内容类型</li>\n<li>Accept-Charset: 浏览器能够显示的字符集</li>\n<li>Accept-Encoding: 浏览器能够处理的压缩编码</li>\n<li>Accept-Language: 浏览器当前设置的语言</li>\n<li>Connection: 浏览器与服务器之间连接的类型</li>\n<li>Cookie: 当前页面设置的任何 Cookie</li>\n<li>Host: 发送请的页面所在的域</li>\n<li>Referer: 发送请求的页面的 URL。( 这个英文单词应该是 Referrer, 然而 HTTP 规范将这个词拼错了，所以只能讲错就错 )</li>\n<li>User-Agent: 浏览器的用户代理字符串</li>\n</ul>\n<h4 id=\"setRequestHeader-DOMString-header-DOMString-value\"><a href=\"#setRequestHeader-DOMString-header-DOMString-value\" class=\"headerlink\" title=\"setRequestHeader( DOMString header, DOMString value )\"></a>setRequestHeader( <em>DOMString header, DOMString value</em> )</h4><p>使用 <strong>setRequestHeader()</strong> 方法可以<strong>设置</strong>请求头部信息__</p>\n<ul>\n<li>接受 2 个参数：头部字段的名称， 头部字段的值</li>\n<li>要成功发送请求头部的信息，必须在调用 <strong>open() 之后， send() 之前</strong> 调用 setRequestHeader()</li>\n<li>可以多次调用, 最终的值不会采用覆盖 ( override ) 的方式, 而是采用追加 append 的方式。</li>\n<li>建议使用 <strong>自定义</strong>头部字段名称，否则可能会影响服务器端的响应</li>\n</ul>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      console.log( xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的依旧是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;https://api.github.com/repos/facebook/react/forks&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);</div><div class=\"line\">xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;HerValue&quot;);</div><div class=\"line\">// 最终的 header 中的 &quot;MyHeader&quot; 为 &quot;MyValue&quot;, &quot;HerValue&quot;</div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<h4 id=\"获取响应头部-safe-的字段\"><a href=\"#获取响应头部-safe-的字段\" class=\"headerlink\" title=\"获取响应头部 ( safe 的字段 )\"></a>获取响应头部 ( <em>safe</em> 的字段 )</h4><ul>\n<li>getResponseHeader( <em>DOMString header</em> )</li>\n</ul>\n<p>返回 <strong>指定的响应的值</strong>，如果响应头还没被接受或者响应头不存在，返回 <strong>null</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);</div></pre></td></tr></table></figure>\n<ul>\n<li>getAllResponseHeaders()</li>\n</ul>\n<p>返回所有的响应头信息。如果响应头还没有接受，则返回 null.</p>\n<p>NOTE: For multipart requests, this returns the headers from the current part of the request, not from the original channel.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let allHeaders = xhr.getAllResponseHeaders();</div></pre></td></tr></table></figure>\n<p>NOTE：</p>\n<ul>\n<li><p>W3C 限制：客户端无法获取 response <strong>Set-Cookie, Set-Cookie2</strong>( xhr 标准 ); <strong>跨域请求时</strong>客户端允许获取 <strong>simple response header,  Access-Control-Expose-Headers</strong>( cors 标准 )</p>\n</li>\n<li><p>getAllResponseHeaders() <strong>只能</strong> 拿到 <strong>限制以外</strong>( 被视为 <em>safe</em> ) 的 header 字段 ( 第一条 )。</p>\n</li>\n<li><p>getResponseHeader( <em>header</em> ) 方法时, header 参数必须是 <strong>限制以外</strong>的 header, 否则会报错: <em>Refused to get unsafe header</em>。 ( 第一条 )</p>\n</li>\n</ul>\n<h4 id=\"指定-xhr-response-的数据类型\"><a href=\"#指定-xhr-response-的数据类型\" class=\"headerlink\" title=\"指定 xhr.response 的数据类型\"></a>指定 xhr.response 的数据类型</h4><ul>\n<li>使用 level 1 提供的 <strong>overrideMimeType( )</strong> 方法</li>\n</ul>\n<p>比如：</p>\n<ul>\n<li>我们想要 server 点返回一个 DOM 对象, 就可以设置 <strong>xhr.overrideMimeType(‘text/xml, charset = utf-8”)</strong>。</li>\n<li>xhr level 1 <strong>不支持</strong>直接传送 <strong>blob</strong> 二进制数据, 可以利用 <strong>overrideMimeType()</strong> 方法</li>\n</ul>\n<p>如下 level 1 获取 一张图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">// 获取一张 图片</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 将响应的数据按照纯文本来解析，字符集替换为用户自己定义的字符集</div><div class=\"line\">xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\"></div><div class=\"line\">      let blobStr = xhr.responseText;</div><div class=\"line\">    // 逐个字节的还原成二进制数据, 顺序  blobStr[i] --&gt; ASCII( 16 进制 ) --&gt;  2 进制</div><div class=\"line\">      for( let i=0, len = blobStr.length; i&lt;len; ++i ) &#123;</div><div class=\"line\">        let c = blobStr.charCodeAt(i)</div><div class=\"line\">        let byte = c&amp;0xff;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>通过设置 response 的 content-type 为 “text/plain;charset=x-user-defined” ，使 xhr 以纯文本格式解析接收到的 blob 数据, 然后再将其转换为 blob 数据</p>\n<ul>\n<li>xhr.responseType</li>\n</ul>\n<p>指定 xhr.response 的数据类型，可以设置如下:</p>\n<ul>\n<li>“”   ( String 字符串, 默认 )</li>\n<li>“text”   ( String )</li>\n<li>“document”   ( Document 对象，返回格式为 XML )</li>\n<li>“json”    ( js 对象， <strong>IE10, IE11 不支持</strong> )</li>\n<li>“blob”</li>\n<li>“arrayBuffer”</li>\n</ul>\n<p>获取图片</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">// 可使用 blob 或者 arrayBuffer</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;blob&apos;;</div><div class=\"line\">// xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      let blobStr = xhr.response;</div><div class=\"line\">      console.log( blobStr )</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%881.41.54.png\" alt=\"\"></p>\n<h4 id=\"获取-response-数据\"><a href=\"#获取-response-数据\" class=\"headerlink\" title=\"获取 response 数据\"></a>获取 response 数据</h4><p>有 3 个属性可以获取返回的数据, 分别是： <strong>xhr.response, xhr.reponseText, xhr.responseXML</strong></p>\n<ul>\n<li><p>xhr.response</p>\n<ul>\n<li>默认值: “”</li>\n<li>请求<strong>完成</strong>时, 才有正确的值</li>\n<li>请求未完成时,<ul>\n<li>当 responseText 为 “” 或 “text” 时, 值为 “”</li>\n<li>当 responseText 为 其他值时, 值为 null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>xhr.responseText</p>\n<ul>\n<li>默认值: “”</li>\n<li>只有当 responseType 为 <strong>“text”, “”</strong> 时, xhr 对象<strong>才有此属性</strong>，此时才能调用 xhr.responseText, 否则 <em>抛错</em></li>\n<li>只有当请求<strong>成功</strong>时, 才能拿到<strong>正确值</strong>。当请求<strong>未完成</strong>或者请求<strong>失败</strong> 时 值都为 <strong>“”</strong></li>\n</ul>\n</li>\n<li><p>xhr.responseXML</p>\n<ul>\n<li>默认值: null</li>\n<li>只有当 <strong>responseType 为 “text”, “”,”document”</strong> 时, xhr 对象 <strong>才有此属性</strong>, 此时才能调用 <strong>xhr.responseXML</strong>, 否则抛错</li>\n<li>只有当请求<strong>成功</strong>时, 才能拿到<strong>正确值</strong>。当请求<strong>未完成</strong>, 请求<strong>失败</strong>, 请求<strong>成功但返回数据无法被正确解析</strong> 时 值都为 <strong>null</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"追踪-ajax-请求的当前状态-xhr-readyState\"><a href=\"#追踪-ajax-请求的当前状态-xhr-readyState\" class=\"headerlink\" title=\"追踪 ajax 请求的当前状态: xhr.readyState\"></a>追踪 ajax 请求的当前状态: xhr.readyState</h4><p>当发送 <strong>异步</strong>请求，接收响应的时候，可以检测 XHR 对象的 <strong>readyState</strong> 属性，该属性表示 <strong>请求 ／ 响应过程的当前活动阶段</strong>。这个属性可取的值如下：</p>\n<ul>\n<li>0: 未初始化。尚未调用 open() 方法。</li>\n<li>1: 启动。已经调用 open() 方法，但是尚未接收到响应。</li>\n<li>2: 发送。已经调用 send() 方法，但尚未接收到响应。</li>\n<li>3: 接收。已经接收到部分响应数据。</li>\n<li><strong>4</strong>: 完成。已经接收到全部响应数据，而且已经可以在客户端使用。</li>\n</ul>\n<p>只要 <strong>readyState</strong> 属性的值<strong>改变</strong>，<strong>都会</strong>触发一次 <strong>readystatechange</strong> 事件。<br>可以<strong>利用</strong>这个事件来<strong>检测</strong>每次<strong>状态变化</strong>后 <strong>readyState</strong> 的值。</p>\n<p>NOTE!!!: 必须在调用 <em>open()</em>  <strong>之前</strong>指定 <strong>onreadystatechange</strong> 事件处理程序才能<strong>确保</strong>跨浏览器<strong>兼容性</strong>。</p>\n<p>例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</div><div class=\"line\">  if( xhr.readyState == 4 )&#123;</div><div class=\"line\">    if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">      console.log( xhr.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 我这里调用的依旧是 github react/forks 的 API</div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;https://api.github.com/repos/facebook/react/forks&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/xhr.png\" alt=\"\"></p>\n<h4 id=\"设置请求超时时间-xhr-timeout\"><a href=\"#设置请求超时时间-xhr-timeout\" class=\"headerlink\" title=\"设置请求超时时间: xhr.timeout\"></a>设置请求超时时间: xhr.timeout</h4><p>从<strong>请求开始</strong>算起, 若超过 timeout 时间请求还没有结束,  则会触发  ontimeout 事件, 主动结束该请求</p>\n<p>请求开始: xhr.onloadstart 事件触发的时候 ( 也就时调用 xhr.send() 的时候 )</p>\n<p>请求结束: xhr.loadend 事件触发的时候</p>\n<ul>\n<li>单位: 毫秒</li>\n<li><p>默认值：0</p>\n<p>NOTE:</p>\n<ul>\n<li>在 <strong>send() 之后</strong> 再设置 timeout, 但<strong>计时起点</strong> 仍旧为调用 <strong>xhr.send()</strong> 方法的时刻</li>\n<li>当 时一个 <strong>同步</strong> 请求时, xhr.timeout 必须设置为 0, 否则<strong>抛错</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进度事件\"><a href=\"#进度事件\" class=\"headerlink\" title=\"进度事件\"></a>进度事件</h3><p>有 6 个进度事件:</p>\n<ul>\n<li>loadstart: 在接收到响应数据的第一个字节时触发</li>\n<li>progress: 在接收响应期间持续不断触发</li>\n<li>error: 在请求发生错误时触发</li>\n<li>abort: 在因为调用 abort() 方法而终止连接时触发</li>\n<li>load: 在接收到完整的响应数据时触发</li>\n<li>loadend: 在通信完成或者触发 error, abort, load 事件中的一个</li>\n</ul>\n<p>每个请求都从触发 <strong>loadstart</strong> 事件开始, 接下来是 <strong>一个或者 多个</strong><br><strong>progress</strong> 事件，然后以触发 <strong>loadend</strong> 事件结束</p>\n<p>NOTE:</p>\n<ul>\n<li><strong>lE8+ 只支持 load 事件。</strong></li>\n<li>没有浏览器支持 loadend 事件</li>\n</ul>\n<h4 id=\"load-事件\"><a href=\"#load-事件\" class=\"headerlink\" title=\"load 事件\"></a>load 事件</h4><p>只要浏览器接收到服务器的响应，<strong>不管其状态如何</strong>，都会触发 load 事件。所以每次 <strong>必须</strong> 检查 <strong>status</strong> 属性, 才能<strong>确定</strong>数据是否真的已经可用。 Firefox, Opera, Chrome, Safari 都支持 load 事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = () =&gt; &#123;</div><div class=\"line\">  if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">    console.log(xhr.responseText );</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure>\n<h4 id=\"progress-事件\"><a href=\"#progress-事件\" class=\"headerlink\" title=\"progress 事件\"></a>progress 事件</h4><p> 这个事件会在浏览器接收新数据期间周期性地触发，默认情况下这个事件<strong>每 50ms</strong> 触发一次。</p>\n<p> <strong>onprogress</strong> 事件处理程序会接收一个 <strong>event</strong> 事件, 其 <strong>target 属性</strong> 是 XHR 对象, 但包含着三个额外的属性:</p>\n<ul>\n<li>lengthComputable: 表示进度信息是否可用的布尓值</li>\n<li>position: <strong>已经接收</strong>的字节数</li>\n<li>totalSize: 表示 根据 Content-length 响应头部确定的预期字节数.</li>\n</ul>\n<p><em>上传，下载过程触发的是不同对象的 onprogress 事件</em>:</p>\n<ul>\n<li>上传: xhr.upload 对象的 onprogress 事件</li>\n<li>下载: xhr 对象的 onprogress 事件</li>\n</ul>\n<p>必须在调用 <strong>open()</strong> 方法<strong>之前</strong>添加 onprogress 事件处理程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">let log = document.querySelector(&quot;#log&quot;)</div><div class=\"line\"></div><div class=\"line\">function downProgress(e) &#123;</div><div class=\"line\">   log.innerHTML = `Received &lt;strong&gt;$&#123;e.position&#125;&lt;/strong&gt; of &lt;strong&gt;$&#123;e.totalSize&#125;&lt;/strong&gt; bytes`</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">xhr.onprogress = (e) =&gt; &#123;</div><div class=\"line\">  console.log( &apos;onprogress&apos; )</div><div class=\"line\">  if( e.lengthComputable ) &#123;</div><div class=\"line\">    downProgress(e)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.onload = () =&gt; &#123;</div><div class=\"line\">  if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class=\"line\">    console.log(xhr.responseText );</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">xhr.open(&quot;get&quot; , &quot;http://img.jackon.me/cheese.jpeg&quot;, true);</div><div class=\"line\"></div><div class=\"line\">xhr.responseType = &apos;arrayBuffer&apos;;</div><div class=\"line\"></div><div class=\"line\">xhr.send(null);</div></pre></td></tr></table></figure></p>\n<p>结果;</p>\n<p><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-18%20%E4%B8%8B%E5%8D%886.54.00.png\" alt=\"\"></p>\n<blockquote><p>参考：</p>\n<p><a href=\"https://segmentfault.com/a/1190000004322487\">你真的会使用 XMLHttpRequest 吗？</a></p>\n<p><em>JavaScript 高级程序设计</em></p>\n</blockquote>"},{"_content":"Jackon Yang 的思想发展史\n\n1. 还没有入职，就主动给你升工资-----公司对自己的器重\n2. CEO 找你谈了两次话 ---- 7月----CEO 对自己的期望\n3. 管理 Team--- 9 月带团队\n4. 第一参加 PC 的会议 --- Simon 也很牛，大家都很牛，\n5. PI pro --- Simon 估时间---表示怀疑\n6. PC 之后 --- Simon 预估时间\n7. Simon 的开发进度\n8. gary 带你 两次 commerail ---11月\n9. 第二次commercial会议 --- CEO 找谈第二次话----CEO 对自己的期望\n10. 和 liji 参与到 PI pro ，Simon 反对 ----- 这个时候想要帮助 Simon 完成feature, 以便 commercial team 卖产品\n11. rena modern Simon 答应要做完 --- Simon 未做完，对 Rena 卖产品表示担心，对整个 Teck Team 对公司的贡献而不安，抱歉\n12. all heads rena 讨论公司的文化，一个词 proactive, initiative--- 上周三，反思自己的行为\n13. 周四 产品会议 --- 产品经理 PI pro 的进度，继续延期----更加不安，不满意，更加想要改变\n14. 发微信----- 尝试赌一下\n15. Simon 炸了---- 改变失败\n\n为什么不敢和 Simon 冲突呢？ 因为喜欢这个公司，不想从这个公司离职\n\n让 liji 搞了好久的音频分析，没有结果。现在又让实习生去做。但是他们现在的这种思路是解决不了问题。在这个战略方向上盲目的投入是很不好的\n\n微信小程序的窗口， 十一的时候就想让他推这个，但是他不推\n\nci\n\n","source":"_drafts/Jackon Yang 的思想发展史.md","raw":"Jackon Yang 的思想发展史\n\n1. 还没有入职，就主动给你升工资-----公司对自己的器重\n2. CEO 找你谈了两次话 ---- 7月----CEO 对自己的期望\n3. 管理 Team--- 9 月带团队\n4. 第一参加 PC 的会议 --- Simon 也很牛，大家都很牛，\n5. PI pro --- Simon 估时间---表示怀疑\n6. PC 之后 --- Simon 预估时间\n7. Simon 的开发进度\n8. gary 带你 两次 commerail ---11月\n9. 第二次commercial会议 --- CEO 找谈第二次话----CEO 对自己的期望\n10. 和 liji 参与到 PI pro ，Simon 反对 ----- 这个时候想要帮助 Simon 完成feature, 以便 commercial team 卖产品\n11. rena modern Simon 答应要做完 --- Simon 未做完，对 Rena 卖产品表示担心，对整个 Teck Team 对公司的贡献而不安，抱歉\n12. all heads rena 讨论公司的文化，一个词 proactive, initiative--- 上周三，反思自己的行为\n13. 周四 产品会议 --- 产品经理 PI pro 的进度，继续延期----更加不安，不满意，更加想要改变\n14. 发微信----- 尝试赌一下\n15. Simon 炸了---- 改变失败\n\n为什么不敢和 Simon 冲突呢？ 因为喜欢这个公司，不想从这个公司离职\n\n让 liji 搞了好久的音频分析，没有结果。现在又让实习生去做。但是他们现在的这种思路是解决不了问题。在这个战略方向上盲目的投入是很不好的\n\n微信小程序的窗口， 十一的时候就想让他推这个，但是他不推\n\nci\n\n","slug":"Jackon Yang 的思想发展史","published":0,"date":"2016-12-17T13:44:05.000Z","updated":"2016-12-18T03:40:02.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwu3uno000017qrayxhrfgsn","content":"<p>Jackon Yang 的思想发展史</p>\n<ol>\n<li>还没有入职，就主动给你升工资—–公司对自己的器重</li>\n<li>CEO 找你谈了两次话 —- 7月—-CEO 对自己的期望</li>\n<li>管理 Team— 9 月带团队</li>\n<li>第一参加 PC 的会议 — Simon 也很牛，大家都很牛，</li>\n<li>PI pro — Simon 估时间—表示怀疑</li>\n<li>PC 之后 — Simon 预估时间</li>\n<li>Simon 的开发进度</li>\n<li>gary 带你 两次 commerail —11月</li>\n<li>第二次commercial会议 — CEO 找谈第二次话—-CEO 对自己的期望</li>\n<li>和 liji 参与到 PI pro ，Simon 反对 —– 这个时候想要帮助 Simon 完成feature, 以便 commercial team 卖产品</li>\n<li>rena modern Simon 答应要做完 — Simon 未做完，对 Rena 卖产品表示担心，对整个 Teck Team 对公司的贡献而不安，抱歉</li>\n<li>all heads rena 讨论公司的文化，一个词 proactive, initiative— 上周三，反思自己的行为</li>\n<li>周四 产品会议 — 产品经理 PI pro 的进度，继续延期—-更加不安，不满意，更加想要改变</li>\n<li>发微信—– 尝试赌一下</li>\n<li>Simon 炸了—- 改变失败</li>\n</ol>\n<p>为什么不敢和 Simon 冲突呢？ 因为喜欢这个公司，不想从这个公司离职</p>\n<p>让 liji 搞了好久的音频分析，没有结果。现在又让实习生去做。但是他们现在的这种思路是解决不了问题。在这个战略方向上盲目的投入是很不好的</p>\n<p>微信小程序的窗口， 十一的时候就想让他推这个，但是他不推</p>\n<p>ci</p>\n","excerpt":"","more":"<p>Jackon Yang 的思想发展史</p>\n<ol>\n<li>还没有入职，就主动给你升工资—–公司对自己的器重</li>\n<li>CEO 找你谈了两次话 —- 7月—-CEO 对自己的期望</li>\n<li>管理 Team— 9 月带团队</li>\n<li>第一参加 PC 的会议 — Simon 也很牛，大家都很牛，</li>\n<li>PI pro — Simon 估时间—表示怀疑</li>\n<li>PC 之后 — Simon 预估时间</li>\n<li>Simon 的开发进度</li>\n<li>gary 带你 两次 commerail —11月</li>\n<li>第二次commercial会议 — CEO 找谈第二次话—-CEO 对自己的期望</li>\n<li>和 liji 参与到 PI pro ，Simon 反对 —– 这个时候想要帮助 Simon 完成feature, 以便 commercial team 卖产品</li>\n<li>rena modern Simon 答应要做完 — Simon 未做完，对 Rena 卖产品表示担心，对整个 Teck Team 对公司的贡献而不安，抱歉</li>\n<li>all heads rena 讨论公司的文化，一个词 proactive, initiative— 上周三，反思自己的行为</li>\n<li>周四 产品会议 — 产品经理 PI pro 的进度，继续延期—-更加不安，不满意，更加想要改变</li>\n<li>发微信—– 尝试赌一下</li>\n<li>Simon 炸了—- 改变失败</li>\n</ol>\n<p>为什么不敢和 Simon 冲突呢？ 因为喜欢这个公司，不想从这个公司离职</p>\n<p>让 liji 搞了好久的音频分析，没有结果。现在又让实习生去做。但是他们现在的这种思路是解决不了问题。在这个战略方向上盲目的投入是很不好的</p>\n<p>微信小程序的窗口， 十一的时候就想让他推这个，但是他不推</p>\n<p>ci</p>\n"},{"title":"面试","_content":"\n\n一面的三个题\n\n虐，没有实际操作的结果就是概念不清\n\n<!-- more -->\n\n1. XMLHttpRequest && Promise\n\n做了 2/3 吧\n```\nconst inputDiv = document.querySelector(\"#input\");\nconst rest = document.querySelector(\"#rest\");\n\nfunction showText(data) {\n  rest.innerHTML = data;\n//  rest.insertAdjacentHTML(\"beforeend\",data);\n}\n\nfunction getTips(url, str){\n  console.log('get')\n  let count = 0;\n  let p1 = new Promise((resolve,rejext)=>{\n    count += 1;\n    let xhr = new XMLHttpRequest();\n\n    xhr.onload = ()=>{\n      if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){\n        resolve(xhr.responseText.slice(0,20));\n      }else{\n        console.log(`something wrong ${xhr.status}`)\n        reject(Error(`fufilled reason: ${xhr.status}`))\n      }\n    }\n\n//   url += (url.indexOf('?') == -1) ? '?' : '&';\n//   url += encodeURIComponent('value') + '=' + encodeURIComponent(str);\n\n    xhr.open(\"get\", url, true);\n    xhr.send(str);\n  });\n\n  p1\n    .then((val)=>{\n    showText(val);\n  })\n    .catch((reason)=>{\n     console.log( `I was fulfilled ,reason: ${reason}` )\n  })\n}\n\ninputDiv.onkeyup = function(e){\n\n  getTips( 'https://api.github.com/repos/facebook/react/forks',this.value );\n  console.log(this.value);\n}\n\n```\n\n[demo](http://jsbin.com/dilukoy/8/edit?js,console,output)\n\n2. 判断类型\n```\nlet arrayTest = [\n  1,\n  'str',\n  true,\n  null,\n  undefined,\n  function sayHi(){},\n  [1,3,4],\n  {\n    name: '',\n    age: ''\n  }\n]\n\nlet testResult = arrayTest.map((item, idx, array)=>{\n  return Object.prototype.toString.call(item).slice(8,-1);\n})\n\nconsole.log( testResult );\n\n// [\"Number\", \"String\", \"Boolean\", \"Null\", \"Undefined\", \"Function\", \"Array\", \"Object\"]\n```\n\n[jsbin demo](http://jsbin.com/dilukoy/3/edit?js,console)\n\n3. 数组，重复的项,  排序\n\n```\nlet arrayOne = [1,4,5]\nlet arrayTwo = arrayOne;\nlet arrayThree = arrayTwo;\nlet numa = 1;\nlet numb = 1;\nlet arrayTest = [\n  1,\n  'str',\n  true,\n  null,\n  undefined,\n  function sayHi(){},\n  [1,3,4],\n  {\n    name: '',\n    age: ''\n  },\n  numa,\n  numb,\n  arrayOne,\n  arrayTwo,\n  arrayThree\n\n]\n/*\n[\n  {\n    item: xxx,\n    count: 1\n  }\n]\n\n*/\n\n\nlet result = arrayTest.reduce((pre, cur, idx, array)=>{\n  let rightCount = -1;\n  pre.some((ele, index)=>{\n    rightCount = ele.item === cur ? index : -1;\n    return ele.item === cur;\n  })\n  console.log( rightCount )\n\n  if(rightCount !== -1){\n    pre[rightCount].count += 1;\n  } else {\n    pre.push({\n      item: cur,\n      count: 1\n    })\n  }\n  return pre;\n}, [])\n\nconsole.log(result);\n\nresult.sort((a, b)=>{\n  return b.count - a.count\n})\n\nconsole.log(result);\n```\n\n[demo](http://jsbin.com/dilukoy/2/edit?js,console)\n\n\n二面:\n\n1. 做一个绕着大圆圆心旋转的小圆，小圆中的文字方向不会变化。\n\n参考：[CSS 秘密花园 W3plus](http://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html)\n\n第一种实现方法 ( 利用两个元素 ) ：\n在字体元素上使用 相反的 animation ( animation-direction: reverse )\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/#&togetherjs=Rk7DRlE27r)\n\n第二种实现方法 ( 利用 1 个元素):\n实现原理是:\n{% blockquote %}\ntransform-origin就是一个语法糖。你可以使用translate()替代。—— @Aryeh Gregor\n{% endblockquote %}\n\n这个意思大概是这样的:\n```\n   transform: rotate( 30deg); \n   transform-origin: 50% 150px; \n```\n上面这个跟下面这个相等\n```\n  transform: translateX( 50%) translateY(150px) rotate(30deg) translateX(-50%) translateY(-150px);\n  transform-origin: 0 0;\n```\n相当于, 先将 元素 平移到 圆点位置，然后在做需要的变换，最后在 反向平移回去。\n\n而最重要的一点在于：transform 属性不仅应用在元素上，而且应用到了元素所在的整个 __坐标系统__。这也说明为什么不同的transfrom顺序很重要，不同顺序的相同转换可能前生的结果会完全不同。\n\n首先，__不运用 animation-direction__ 的 __2__ 个 元素合作的解决方法\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/#&togetherjs=Rk7DRlE27r)\n\n因为是同样的 __transform-origin__ ,  我们可以将 __两个元素的 transform 放！一！块！__\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/1/#&togetherjs=Rk7DRlE27r)\n\n由于是一直转圈的，所以可以将相邻的， translateX 和 translateY 合并，抵消。\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&togetherjs=Rk7DRlE27r)\n\n可以把要旋转的元素，直接放到中心点去( margin )，这样就不用先将它移到中心点，因此可以少两个 translateY()\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&togetherjs=Rk7DRlE27r)\n\n最终的 @keyframes\n```\n@keyframes circle {\n  from {\n    transform: rotate(0turn) translateY( -150px )\n    translateY( 50% ) rotate(1turn);\n  }  \n  to {\n    transform: rotate(1turn) translateY(-150px )\n    translateY( 50% ) rotate(0turn) ;\n  }\n}\n```\n\n其中: transform 最后一部分 即 (  from 中的 rotate(1turn) , to 中的 rotate(0turn) 是对 文字部分的调整 )\n\n\n2. 使用 css 选择最后一行的元素\n如图：\n\n![](http://img.jackon.me/flex.png)\n\n主要是利用 伪类的连用\n\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/3/#&togetherjs=Rk7DRlE27r)\n\n3. JS 执行进程 && promise\n在网上查找相关信息，发现 _JavaScript 高级程序设计_ 里有讲一点这一部分，在 __高级技巧__ 中的 _高级定时器_ !\n\n简单来说，是 JS 是运行在单线程的环境中，它的进程会阻塞其他的页面处理，所以必须有小间隔来防止用户界面被锁定。( 代码长时间运行中可能出现 )\n\n","source":"_posts/interview.md","raw":"---\ntitle: 面试\ncategories:\n- 编程\ntags:\n- 总结\n- JS 基础\n---\n\n\n一面的三个题\n\n虐，没有实际操作的结果就是概念不清\n\n<!-- more -->\n\n1. XMLHttpRequest && Promise\n\n做了 2/3 吧\n```\nconst inputDiv = document.querySelector(\"#input\");\nconst rest = document.querySelector(\"#rest\");\n\nfunction showText(data) {\n  rest.innerHTML = data;\n//  rest.insertAdjacentHTML(\"beforeend\",data);\n}\n\nfunction getTips(url, str){\n  console.log('get')\n  let count = 0;\n  let p1 = new Promise((resolve,rejext)=>{\n    count += 1;\n    let xhr = new XMLHttpRequest();\n\n    xhr.onload = ()=>{\n      if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){\n        resolve(xhr.responseText.slice(0,20));\n      }else{\n        console.log(`something wrong ${xhr.status}`)\n        reject(Error(`fufilled reason: ${xhr.status}`))\n      }\n    }\n\n//   url += (url.indexOf('?') == -1) ? '?' : '&';\n//   url += encodeURIComponent('value') + '=' + encodeURIComponent(str);\n\n    xhr.open(\"get\", url, true);\n    xhr.send(str);\n  });\n\n  p1\n    .then((val)=>{\n    showText(val);\n  })\n    .catch((reason)=>{\n     console.log( `I was fulfilled ,reason: ${reason}` )\n  })\n}\n\ninputDiv.onkeyup = function(e){\n\n  getTips( 'https://api.github.com/repos/facebook/react/forks',this.value );\n  console.log(this.value);\n}\n\n```\n\n[demo](http://jsbin.com/dilukoy/8/edit?js,console,output)\n\n2. 判断类型\n```\nlet arrayTest = [\n  1,\n  'str',\n  true,\n  null,\n  undefined,\n  function sayHi(){},\n  [1,3,4],\n  {\n    name: '',\n    age: ''\n  }\n]\n\nlet testResult = arrayTest.map((item, idx, array)=>{\n  return Object.prototype.toString.call(item).slice(8,-1);\n})\n\nconsole.log( testResult );\n\n// [\"Number\", \"String\", \"Boolean\", \"Null\", \"Undefined\", \"Function\", \"Array\", \"Object\"]\n```\n\n[jsbin demo](http://jsbin.com/dilukoy/3/edit?js,console)\n\n3. 数组，重复的项,  排序\n\n```\nlet arrayOne = [1,4,5]\nlet arrayTwo = arrayOne;\nlet arrayThree = arrayTwo;\nlet numa = 1;\nlet numb = 1;\nlet arrayTest = [\n  1,\n  'str',\n  true,\n  null,\n  undefined,\n  function sayHi(){},\n  [1,3,4],\n  {\n    name: '',\n    age: ''\n  },\n  numa,\n  numb,\n  arrayOne,\n  arrayTwo,\n  arrayThree\n\n]\n/*\n[\n  {\n    item: xxx,\n    count: 1\n  }\n]\n\n*/\n\n\nlet result = arrayTest.reduce((pre, cur, idx, array)=>{\n  let rightCount = -1;\n  pre.some((ele, index)=>{\n    rightCount = ele.item === cur ? index : -1;\n    return ele.item === cur;\n  })\n  console.log( rightCount )\n\n  if(rightCount !== -1){\n    pre[rightCount].count += 1;\n  } else {\n    pre.push({\n      item: cur,\n      count: 1\n    })\n  }\n  return pre;\n}, [])\n\nconsole.log(result);\n\nresult.sort((a, b)=>{\n  return b.count - a.count\n})\n\nconsole.log(result);\n```\n\n[demo](http://jsbin.com/dilukoy/2/edit?js,console)\n\n\n二面:\n\n1. 做一个绕着大圆圆心旋转的小圆，小圆中的文字方向不会变化。\n\n参考：[CSS 秘密花园 W3plus](http://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html)\n\n第一种实现方法 ( 利用两个元素 ) ：\n在字体元素上使用 相反的 animation ( animation-direction: reverse )\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/#&togetherjs=Rk7DRlE27r)\n\n第二种实现方法 ( 利用 1 个元素):\n实现原理是:\n{% blockquote %}\ntransform-origin就是一个语法糖。你可以使用translate()替代。—— @Aryeh Gregor\n{% endblockquote %}\n\n这个意思大概是这样的:\n```\n   transform: rotate( 30deg); \n   transform-origin: 50% 150px; \n```\n上面这个跟下面这个相等\n```\n  transform: translateX( 50%) translateY(150px) rotate(30deg) translateX(-50%) translateY(-150px);\n  transform-origin: 0 0;\n```\n相当于, 先将 元素 平移到 圆点位置，然后在做需要的变换，最后在 反向平移回去。\n\n而最重要的一点在于：transform 属性不仅应用在元素上，而且应用到了元素所在的整个 __坐标系统__。这也说明为什么不同的transfrom顺序很重要，不同顺序的相同转换可能前生的结果会完全不同。\n\n首先，__不运用 animation-direction__ 的 __2__ 个 元素合作的解决方法\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/#&togetherjs=Rk7DRlE27r)\n\n因为是同样的 __transform-origin__ ,  我们可以将 __两个元素的 transform 放！一！块！__\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/1/#&togetherjs=Rk7DRlE27r)\n\n由于是一直转圈的，所以可以将相邻的， translateX 和 translateY 合并，抵消。\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&togetherjs=Rk7DRlE27r)\n\n可以把要旋转的元素，直接放到中心点去( margin )，这样就不用先将它移到中心点，因此可以少两个 translateY()\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&togetherjs=Rk7DRlE27r)\n\n最终的 @keyframes\n```\n@keyframes circle {\n  from {\n    transform: rotate(0turn) translateY( -150px )\n    translateY( 50% ) rotate(1turn);\n  }  \n  to {\n    transform: rotate(1turn) translateY(-150px )\n    translateY( 50% ) rotate(0turn) ;\n  }\n}\n```\n\n其中: transform 最后一部分 即 (  from 中的 rotate(1turn) , to 中的 rotate(0turn) 是对 文字部分的调整 )\n\n\n2. 使用 css 选择最后一行的元素\n如图：\n\n![](http://img.jackon.me/flex.png)\n\n主要是利用 伪类的连用\n\n[demo](https://jsfiddle.net/vivian_xu/r91j1wc8/3/#&togetherjs=Rk7DRlE27r)\n\n3. JS 执行进程 && promise\n在网上查找相关信息，发现 _JavaScript 高级程序设计_ 里有讲一点这一部分，在 __高级技巧__ 中的 _高级定时器_ !\n\n简单来说，是 JS 是运行在单线程的环境中，它的进程会阻塞其他的页面处理，所以必须有小间隔来防止用户界面被锁定。( 代码长时间运行中可能出现 )\n\n","slug":"interview","published":1,"date":"2016-12-18T14:03:47.000Z","updated":"2016-12-23T10:39:04.000Z","_id":"ciwuq4a3d0005yira7xqvvwek","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一面的三个题</p>\n<p>虐，没有实际操作的结果就是概念不清</p>\n<a id=\"more\"></a>\n<ol>\n<li>XMLHttpRequest &amp;&amp; Promise</li>\n</ol>\n<p>做了 2/3 吧<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">const inputDiv = document.querySelector(&quot;#input&quot;);</div><div class=\"line\">const rest = document.querySelector(&quot;#rest&quot;);</div><div class=\"line\"></div><div class=\"line\">function showText(data) &#123;</div><div class=\"line\">  rest.innerHTML = data;</div><div class=\"line\">//  rest.insertAdjacentHTML(&quot;beforeend&quot;,data);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function getTips(url, str)&#123;</div><div class=\"line\">  console.log(&apos;get&apos;)</div><div class=\"line\">  let count = 0;</div><div class=\"line\">  let p1 = new Promise((resolve,rejext)=&gt;&#123;</div><div class=\"line\">    count += 1;</div><div class=\"line\">    let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">    xhr.onload = ()=&gt;&#123;</div><div class=\"line\">      if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</div><div class=\"line\">        resolve(xhr.responseText.slice(0,20));</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        console.log(`something wrong $&#123;xhr.status&#125;`)</div><div class=\"line\">        reject(Error(`fufilled reason: $&#123;xhr.status&#125;`))</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//   url += (url.indexOf(&apos;?&apos;) == -1) ? &apos;?&apos; : &apos;&amp;&apos;;</div><div class=\"line\">//   url += encodeURIComponent(&apos;value&apos;) + &apos;=&apos; + encodeURIComponent(str);</div><div class=\"line\"></div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.send(str);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  p1</div><div class=\"line\">    .then((val)=&gt;&#123;</div><div class=\"line\">    showText(val);</div><div class=\"line\">  &#125;)</div><div class=\"line\">    .catch((reason)=&gt;&#123;</div><div class=\"line\">     console.log( `I was fulfilled ,reason: $&#123;reason&#125;` )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">inputDiv.onkeyup = function(e)&#123;</div><div class=\"line\"></div><div class=\"line\">  getTips( &apos;https://api.github.com/repos/facebook/react/forks&apos;,this.value );</div><div class=\"line\">  console.log(this.value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsbin.com/dilukoy/8/edit?js,console,output\" target=\"_blank\" rel=\"external\">demo</a></p>\n<ol>\n<li>判断类型<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">let arrayTest = [</div><div class=\"line\">  1,</div><div class=\"line\">  &apos;str&apos;,</div><div class=\"line\">  true,</div><div class=\"line\">  null,</div><div class=\"line\">  undefined,</div><div class=\"line\">  function sayHi()&#123;&#125;,</div><div class=\"line\">  [1,3,4],</div><div class=\"line\">  &#123;</div><div class=\"line\">    name: &apos;&apos;,</div><div class=\"line\">    age: &apos;&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">let testResult = arrayTest.map((item, idx, array)=&gt;&#123;</div><div class=\"line\">  return Object.prototype.toString.call(item).slice(8,-1);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log( testResult );</div><div class=\"line\"></div><div class=\"line\">// [&quot;Number&quot;, &quot;String&quot;, &quot;Boolean&quot;, &quot;Null&quot;, &quot;Undefined&quot;, &quot;Function&quot;, &quot;Array&quot;, &quot;Object&quot;]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"http://jsbin.com/dilukoy/3/edit?js,console\" target=\"_blank\" rel=\"external\">jsbin demo</a></p>\n<ol>\n<li>数组，重复的项,  排序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">let arrayOne = [1,4,5]</div><div class=\"line\">let arrayTwo = arrayOne;</div><div class=\"line\">let arrayThree = arrayTwo;</div><div class=\"line\">let numa = 1;</div><div class=\"line\">let numb = 1;</div><div class=\"line\">let arrayTest = [</div><div class=\"line\">  1,</div><div class=\"line\">  &apos;str&apos;,</div><div class=\"line\">  true,</div><div class=\"line\">  null,</div><div class=\"line\">  undefined,</div><div class=\"line\">  function sayHi()&#123;&#125;,</div><div class=\"line\">  [1,3,4],</div><div class=\"line\">  &#123;</div><div class=\"line\">    name: &apos;&apos;,</div><div class=\"line\">    age: &apos;&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  numa,</div><div class=\"line\">  numb,</div><div class=\"line\">  arrayOne,</div><div class=\"line\">  arrayTwo,</div><div class=\"line\">  arrayThree</div><div class=\"line\"></div><div class=\"line\">]</div><div class=\"line\">/*</div><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    item: xxx,</div><div class=\"line\">    count: 1</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">let result = arrayTest.reduce((pre, cur, idx, array)=&gt;&#123;</div><div class=\"line\">  let rightCount = -1;</div><div class=\"line\">  pre.some((ele, index)=&gt;&#123;</div><div class=\"line\">    rightCount = ele.item === cur ? index : -1;</div><div class=\"line\">    return ele.item === cur;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  console.log( rightCount )</div><div class=\"line\"></div><div class=\"line\">  if(rightCount !== -1)&#123;</div><div class=\"line\">    pre[rightCount].count += 1;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pre.push(&#123;</div><div class=\"line\">      item: cur,</div><div class=\"line\">      count: 1</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pre;</div><div class=\"line\">&#125;, [])</div><div class=\"line\"></div><div class=\"line\">console.log(result);</div><div class=\"line\"></div><div class=\"line\">result.sort((a, b)=&gt;&#123;</div><div class=\"line\">  return b.count - a.count</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(result);</div></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/dilukoy/2/edit?js,console\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>二面:</p>\n<ol>\n<li>做一个绕着大圆圆心旋转的小圆，小圆中的文字方向不会变化。</li>\n</ol>\n<p>参考：<a href=\"http://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html\" target=\"_blank\" rel=\"external\">CSS 秘密花园 W3plus</a></p>\n<p>第一种实现方法 ( 利用两个元素 ) ：<br>在字体元素上使用 相反的 animation ( animation-direction: reverse )<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>第二种实现方法 ( 利用 1 个元素):<br>实现原理是:<br><blockquote><p>transform-origin就是一个语法糖。你可以使用translate()替代。—— @Aryeh Gregor</p>\n</blockquote></p>\n<p>这个意思大概是这样的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">transform: rotate( 30deg); </div><div class=\"line\">transform-origin: 50% 150px;</div></pre></td></tr></table></figure></p>\n<p>上面这个跟下面这个相等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">transform: translateX( 50%) translateY(150px) rotate(30deg) translateX(-50%) translateY(-150px);</div><div class=\"line\">transform-origin: 0 0;</div></pre></td></tr></table></figure></p>\n<p>相当于, 先将 元素 平移到 圆点位置，然后在做需要的变换，最后在 反向平移回去。</p>\n<p>而最重要的一点在于：transform 属性不仅应用在元素上，而且应用到了元素所在的整个 <strong>坐标系统</strong>。这也说明为什么不同的transfrom顺序很重要，不同顺序的相同转换可能前生的结果会完全不同。</p>\n<p>首先，<strong>不运用 animation-direction</strong> 的 <strong>2</strong> 个 元素合作的解决方法<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>因为是同样的 <strong>transform-origin</strong> ,  我们可以将 <strong>两个元素的 transform 放！一！块！</strong><br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/1/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>由于是一直转圈的，所以可以将相邻的， translateX 和 translateY 合并，抵消。<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>可以把要旋转的元素，直接放到中心点去( margin )，这样就不用先将它移到中心点，因此可以少两个 translateY()<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<p>最终的 @keyframes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes circle &#123;</div><div class=\"line\">  from &#123;</div><div class=\"line\">    transform: rotate(0turn) translateY( -150px )</div><div class=\"line\">    translateY( 50% ) rotate(1turn);</div><div class=\"line\">  &#125;  </div><div class=\"line\">  to &#123;</div><div class=\"line\">    transform: rotate(1turn) translateY(-150px )</div><div class=\"line\">    translateY( 50% ) rotate(0turn) ;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中: transform 最后一部分 即 (  from 中的 rotate(1turn) , to 中的 rotate(0turn) 是对 文字部分的调整 )</p>\n<ol>\n<li>使用 css 选择最后一行的元素<br>如图：</li>\n</ol>\n<p><img src=\"http://img.jackon.me/flex.png\" alt=\"\"></p>\n<p>主要是利用 伪类的连用</p>\n<p><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/3/#&amp;togetherjs=Rk7DRlE27r\" target=\"_blank\" rel=\"external\">demo</a></p>\n<ol>\n<li>JS 执行进程 &amp;&amp; promise<br>在网上查找相关信息，发现 <em>JavaScript 高级程序设计</em> 里有讲一点这一部分，在 <strong>高级技巧</strong> 中的 <em>高级定时器</em> !</li>\n</ol>\n<p>简单来说，是 JS 是运行在单线程的环境中，它的进程会阻塞其他的页面处理，所以必须有小间隔来防止用户界面被锁定。( 代码长时间运行中可能出现 )</p>\n","excerpt":"<p>一面的三个题</p>\n<p>虐，没有实际操作的结果就是概念不清</p>","more":"<ol>\n<li>XMLHttpRequest &amp;&amp; Promise</li>\n</ol>\n<p>做了 2/3 吧<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">const inputDiv = document.querySelector(&quot;#input&quot;);</div><div class=\"line\">const rest = document.querySelector(&quot;#rest&quot;);</div><div class=\"line\"></div><div class=\"line\">function showText(data) &#123;</div><div class=\"line\">  rest.innerHTML = data;</div><div class=\"line\">//  rest.insertAdjacentHTML(&quot;beforeend&quot;,data);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function getTips(url, str)&#123;</div><div class=\"line\">  console.log(&apos;get&apos;)</div><div class=\"line\">  let count = 0;</div><div class=\"line\">  let p1 = new Promise((resolve,rejext)=&gt;&#123;</div><div class=\"line\">    count += 1;</div><div class=\"line\">    let xhr = new XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">    xhr.onload = ()=&gt;&#123;</div><div class=\"line\">      if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</div><div class=\"line\">        resolve(xhr.responseText.slice(0,20));</div><div class=\"line\">      &#125;else&#123;</div><div class=\"line\">        console.log(`something wrong $&#123;xhr.status&#125;`)</div><div class=\"line\">        reject(Error(`fufilled reason: $&#123;xhr.status&#125;`))</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">//   url += (url.indexOf(&apos;?&apos;) == -1) ? &apos;?&apos; : &apos;&amp;&apos;;</div><div class=\"line\">//   url += encodeURIComponent(&apos;value&apos;) + &apos;=&apos; + encodeURIComponent(str);</div><div class=\"line\"></div><div class=\"line\">    xhr.open(&quot;get&quot;, url, true);</div><div class=\"line\">    xhr.send(str);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  p1</div><div class=\"line\">    .then((val)=&gt;&#123;</div><div class=\"line\">    showText(val);</div><div class=\"line\">  &#125;)</div><div class=\"line\">    .catch((reason)=&gt;&#123;</div><div class=\"line\">     console.log( `I was fulfilled ,reason: $&#123;reason&#125;` )</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">inputDiv.onkeyup = function(e)&#123;</div><div class=\"line\"></div><div class=\"line\">  getTips( &apos;https://api.github.com/repos/facebook/react/forks&apos;,this.value );</div><div class=\"line\">  console.log(this.value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://jsbin.com/dilukoy/8/edit?js,console,output\">demo</a></p>\n<ol>\n<li>判断类型<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">let arrayTest = [</div><div class=\"line\">  1,</div><div class=\"line\">  &apos;str&apos;,</div><div class=\"line\">  true,</div><div class=\"line\">  null,</div><div class=\"line\">  undefined,</div><div class=\"line\">  function sayHi()&#123;&#125;,</div><div class=\"line\">  [1,3,4],</div><div class=\"line\">  &#123;</div><div class=\"line\">    name: &apos;&apos;,</div><div class=\"line\">    age: &apos;&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">let testResult = arrayTest.map((item, idx, array)=&gt;&#123;</div><div class=\"line\">  return Object.prototype.toString.call(item).slice(8,-1);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log( testResult );</div><div class=\"line\"></div><div class=\"line\">// [&quot;Number&quot;, &quot;String&quot;, &quot;Boolean&quot;, &quot;Null&quot;, &quot;Undefined&quot;, &quot;Function&quot;, &quot;Array&quot;, &quot;Object&quot;]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"http://jsbin.com/dilukoy/3/edit?js,console\">jsbin demo</a></p>\n<ol>\n<li>数组，重复的项,  排序</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">let arrayOne = [1,4,5]</div><div class=\"line\">let arrayTwo = arrayOne;</div><div class=\"line\">let arrayThree = arrayTwo;</div><div class=\"line\">let numa = 1;</div><div class=\"line\">let numb = 1;</div><div class=\"line\">let arrayTest = [</div><div class=\"line\">  1,</div><div class=\"line\">  &apos;str&apos;,</div><div class=\"line\">  true,</div><div class=\"line\">  null,</div><div class=\"line\">  undefined,</div><div class=\"line\">  function sayHi()&#123;&#125;,</div><div class=\"line\">  [1,3,4],</div><div class=\"line\">  &#123;</div><div class=\"line\">    name: &apos;&apos;,</div><div class=\"line\">    age: &apos;&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  numa,</div><div class=\"line\">  numb,</div><div class=\"line\">  arrayOne,</div><div class=\"line\">  arrayTwo,</div><div class=\"line\">  arrayThree</div><div class=\"line\"></div><div class=\"line\">]</div><div class=\"line\">/*</div><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    item: xxx,</div><div class=\"line\">    count: 1</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">let result = arrayTest.reduce((pre, cur, idx, array)=&gt;&#123;</div><div class=\"line\">  let rightCount = -1;</div><div class=\"line\">  pre.some((ele, index)=&gt;&#123;</div><div class=\"line\">    rightCount = ele.item === cur ? index : -1;</div><div class=\"line\">    return ele.item === cur;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  console.log( rightCount )</div><div class=\"line\"></div><div class=\"line\">  if(rightCount !== -1)&#123;</div><div class=\"line\">    pre[rightCount].count += 1;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pre.push(&#123;</div><div class=\"line\">      item: cur,</div><div class=\"line\">      count: 1</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">  return pre;</div><div class=\"line\">&#125;, [])</div><div class=\"line\"></div><div class=\"line\">console.log(result);</div><div class=\"line\"></div><div class=\"line\">result.sort((a, b)=&gt;&#123;</div><div class=\"line\">  return b.count - a.count</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(result);</div></pre></td></tr></table></figure>\n<p><a href=\"http://jsbin.com/dilukoy/2/edit?js,console\">demo</a></p>\n<p>二面:</p>\n<ol>\n<li>做一个绕着大圆圆心旋转的小圆，小圆中的文字方向不会变化。</li>\n</ol>\n<p>参考：<a href=\"http://www.w3cplus.com/css3/css-secrets/animation-along-a-circular-path.html\">CSS 秘密花园 W3plus</a></p>\n<p>第一种实现方法 ( 利用两个元素 ) ：<br>在字体元素上使用 相反的 animation ( animation-direction: reverse )<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<p>第二种实现方法 ( 利用 1 个元素):<br>实现原理是:<br><blockquote><p>transform-origin就是一个语法糖。你可以使用translate()替代。—— @Aryeh Gregor</p>\n</blockquote></p>\n<p>这个意思大概是这样的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">transform: rotate( 30deg); </div><div class=\"line\">transform-origin: 50% 150px;</div></pre></td></tr></table></figure></p>\n<p>上面这个跟下面这个相等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">transform: translateX( 50%) translateY(150px) rotate(30deg) translateX(-50%) translateY(-150px);</div><div class=\"line\">transform-origin: 0 0;</div></pre></td></tr></table></figure></p>\n<p>相当于, 先将 元素 平移到 圆点位置，然后在做需要的变换，最后在 反向平移回去。</p>\n<p>而最重要的一点在于：transform 属性不仅应用在元素上，而且应用到了元素所在的整个 <strong>坐标系统</strong>。这也说明为什么不同的transfrom顺序很重要，不同顺序的相同转换可能前生的结果会完全不同。</p>\n<p>首先，<strong>不运用 animation-direction</strong> 的 <strong>2</strong> 个 元素合作的解决方法<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<p>因为是同样的 <strong>transform-origin</strong> ,  我们可以将 <strong>两个元素的 transform 放！一！块！</strong><br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/1/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<p>由于是一直转圈的，所以可以将相邻的， translateX 和 translateY 合并，抵消。<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<p>可以把要旋转的元素，直接放到中心点去( margin )，这样就不用先将它移到中心点，因此可以少两个 translateY()<br><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/2/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<p>最终的 @keyframes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes circle &#123;</div><div class=\"line\">  from &#123;</div><div class=\"line\">    transform: rotate(0turn) translateY( -150px )</div><div class=\"line\">    translateY( 50% ) rotate(1turn);</div><div class=\"line\">  &#125;  </div><div class=\"line\">  to &#123;</div><div class=\"line\">    transform: rotate(1turn) translateY(-150px )</div><div class=\"line\">    translateY( 50% ) rotate(0turn) ;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中: transform 最后一部分 即 (  from 中的 rotate(1turn) , to 中的 rotate(0turn) 是对 文字部分的调整 )</p>\n<ol>\n<li>使用 css 选择最后一行的元素<br>如图：</li>\n</ol>\n<p><img src=\"http://img.jackon.me/flex.png\" alt=\"\"></p>\n<p>主要是利用 伪类的连用</p>\n<p><a href=\"https://jsfiddle.net/vivian_xu/r91j1wc8/3/#&amp;togetherjs=Rk7DRlE27r\">demo</a></p>\n<ol>\n<li>JS 执行进程 &amp;&amp; promise<br>在网上查找相关信息，发现 <em>JavaScript 高级程序设计</em> 里有讲一点这一部分，在 <strong>高级技巧</strong> 中的 <em>高级定时器</em> !</li>\n</ol>\n<p>简单来说，是 JS 是运行在单线程的环境中，它的进程会阻塞其他的页面处理，所以必须有小间隔来防止用户界面被锁定。( 代码长时间运行中可能出现 )</p>"},{"title":"原型","_content":"\n这块好难理解，\n从最基础的开始,\n为了便于自己以后还能想起来，多写了很多废话\n\n###  构造函数，原型，实例\n\n- 构造函数都有一个 __原型对象( 原型 )__ prototype\n\n- 构造函数的 原型对象 ( prototype ) 里，都包含了一个指向 __构造函数__的指针 ( constructor )\n\n- 由于每个对象都有一原型， prototype 也有一个指向它的原型的指针( `__proto__` )\n\n- 实例都包含了一个指向 __原型对象( prototype )内部__的指针 (`__proto__`)。\n\n\n<!-- more  -->\n\n_**NOTE**_:\nconstructor:\n为了让每个对象知道 创造它的构造函数是谁，所以每一个 构造函数的 原型对象( prototype , 继承下去的 )  上都有一个 constructor 指向 它( 构造函数  ) 自己。( 心机 )\n\n\n下来看下实验\n\n```\n// 构造函数 createA\n// createA 的原型对象( prototype ) 有一个属性是 constructor,  constructor 是指向 createA 的\n\nfunction createA() {}\n\nconsole.log('function createA()');\nconsole.log( `createA.prototype: ${createA.prototype}` );\nconsole.log( `createA.prototype.constructor: ${createA.prototype.constructor}` );\n\n// objectA 是 createA 的一个实例\n// objectA 有一个 __proto__ 属性是指向 objectA.prototype ( 构造函数的原型对象 ) __内部__ 的\n\nlet objectA = new createA();\n\n// objectB 也有一个 __proto__ 属性，指向哪里呢？\n\nlet objectB = objectA;\n\nconsole.log('objectA');\nconsole.log('objectB');\n\nconsole.log( `objectA: ${objectA}` );\nconsole.log( `objectB: ${objectB}` );\n\nconsole.log(`objectA.__proto__: ${objectA.__proto__}`);\nconsole.log( `objectB.__proto__: ${objectB.__proto__}` );\n\nconsole.log(`objectA.__proto__.constructor: ${objectA.__proto__.constructor}`);\nconsole.log( `objectB.__proto__.constructor: ${objectB.__proto__.constructor}` );\n```\n\n结果:\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-16%20%E4%B8%8A%E5%8D%881.48.19.png)\n\n也就是说：\n\n`objectA = objectB`, A 就是 B 就是 A, 所以  __构造函数__ 之下就只有一层, 也就是 构造函数 这个 _爸爸/ 妈妈_ __只有__ 儿女，_没有_ 孙子 / 孙女 或者  孙孙子 / 孙孙女 。。。。之类\n\n\n那么，__构造函数 的原型对象__ (createA.prototype) 也是一个 _对象_，那么 这个_对象_的 原型 ( `createA.prototype.__proto__` ) 是什么？\n如果把它 (构造函数 的原型对象) 看成 实例的话，那么 它的 原型 (`__proto__`) 应该指向 它的 构造函数的原型对象 ( 也就是说 `createA.prototype.__proto__.constructor` `应该指向它的构造函数 ) 。那么这个构造函数是什么呢?\n\n测试一下\n\n```\nfunction createA() {}\n\nconsole.log('function createA()');\nconsole.log( `createA.prototype: ${createA.prototype}` );\n\nconsole.log( `createA.prototype.constructor: ${createA.prototype.constructor}` );\n\nconsole.log( `createA.prototype.__proto__: ${createA.prototype.__proto__}` );\n\nconsole.log( `createA.prototype.__proto__.constructor: ${createA.prototype.__proto__.constructor}` );\n\nconsole.log( `createA.prototype.__proto__._proto__: ${createA.prototype.__proto__.__proto__}` );\n```\n结果：\n\n![](http://img.jackon.me/proto_null.png)\n\n看到结果想起来，每个 __函数__都是 __对象__，\n所以 函数的 原型对象的 构造函数 ( `createA.prototype.__proto__.constructor`) 是 function object( ){ } ( JS 默认的所有对象的构造函数 ),\n因为函数都有对象原型 (function object() {} 的 对象原型，也就是`createA.prototype.__proto__` ) ，\n-所以 这个对象原型的 `__proto__` 是什么呢？\n 答案是 __null__。JS 中所有的原型链的最终都是 __null__\n\n\n#### 小小的总结一下\n\nJS 数据类型分为两种, 一种是 __基本数据类型( 数值字面量, 不是 object )__。\n\n第二种就是 __Object (复杂数据类型, 引用类型值，对象 ) 类型__。\n\n而 Object 中包括了许多类型 ( Array, Function, RegExp )\n\n而这些__复杂数据类型__ _每一个_ 都代表着_一个_ __构造函数__。\n也就是说,\n__每一个 数组 都是 Function Array ( Array 构造函数 )的实例，__ 每一个实例都是 它的构造函数的\n\n每一个 __非 Function 类型的对象__ 的 __原型__ 都指向着 相应 的__构造函数的 原型对象__ ( 比如  `array.__prop__` --> Array.prototype ( function Array), `string.__proto__ --> Object.prototype (function Object)` )。\n\n而 function 类型的原型对象 ( prototype ) 是 function Object。\n\n而最终 __function Object__ 的原型对象 ( prototype ) 是 __null__\n\n ! ! NOTE:\n 这里没有 函数类型的原型 --> function function (function 构造函数) 之说。\n\n### 原型链\n\n#### 概念\n\n- 是实现 _继承__ 的主要方法\n- 基本思想是利用 _原型_让一个 _引用类型_ __继承__另一个_引用类型_的 __属性和方法__。\n\n- 假如，我们让 原型对象 等于 另一个类型的 _实例_，此时的原型对象将包含一个指向 另一个原型对象 (prototype) 的指针(`__proto__`)。相应的，另一个原型对象 ( __prototype__) 中也包含着一个指向另一个构造函数(__constructor__) 的指针。\n\n👆的看得不是很懂。。。\n\n\n上个星期写到了这里，写不下去了。。\n\n昨天晚上向男票寻求帮助，感觉差不多了， 但是。。。 要先去面试，回来再补\n\n----\nupdate\n\n#### 我的理解\n\n原型链可以这样理解:\n\n每一个对象都是一个 container , 这个 container 里面都是些 key:value ( 键值对 )。 container 分为两部分，__第一部分__ 是自身包含的属性，方法。__第二部分__ 就是一个指向原型的指针 (prototype / _prop_)。\n\n而最重要的区别就是，寻找一个 key 的顺序。\n\n当我们寻找一个 key 的时候。首先，程序会从这个对象 ( container ) 的第一部分找起, 如果第一部分没有，则到 __第二部分__，根据指针到它所指的地址的对象 ( 原型对象 ) 上找。同样，原型对象也是一个 container, 它的结构跟之前的对象结构完全一样，所以在它的第一部分找不到的时候，程序会到它的第二部分的指针所指的对象 ( 原型对象 ) 上去找，而这个对象与前两个的结构也完全一样...... 就这样不停的寻找，直到找到寻找的 key, 完。\n\n而在这个寻找的过程中, 一个对象与另一个对象相连，形成的 __链__。\n而，基本上每一个 container 的第二部分的指针都是指向 __它的原型对象__ ( _这个对象往往也是 构造它自己的__构造函数__的 __原型对象___ ) 。\n而通过理论知识我们知道 ( 还有上面的实验 )。 最终这个链是 __止__ 于 __null__ 的。\n\n\n__如何能使这个链条更长呢? 使某一个__\n\n看到上面的 Object 类型, 所有 非 function Object 的 function 类型的 原型指针 都指向了 function Object 的原型对象。\n\n**也就是 __function__ 类型的, 可以将 原型链 连起来～**\n\n那么怎么连起来呢？\n\n假设，我们有 function A(){} ,  function B(){}\n\n我想到了 2 种方法:\n\n- 直接使 它们两个的 prototype 相等，即：\n\n```\n  A.prototype = B.prototype;\n```\n\n根据 JS 的引用赋值, 我们知道，A.prototype 与 B.prototype 现在指向的是同一个地址。\n\n当任何一方改动这个 地址的值，另一方取得的值也改变了。\n\n而且 指向 __构造函数 A__ 的指针( construct ) 指向了 __B__, ( 实例找不到爸爸了！ ), 而且！ 我们还不能改！\n\n- 使 A.prototype 的 __原型__ 指向 B.prototype，也就是 `A.prototype.__proto__` --> B.prototype\n\n我们知道, 一个 __构造函数__ 的 __实例__ 的 __原型__指针 (`__proto__`) 指向 __构造函数__的 __原型对象__( prototype )。\n\n```\nA.prototype = new B();\n```\n这样相当于， `A.prototype.__proto__` --> B.prototype,\n\n当我们改变 A.prototype 的值的时候 B.prototype 并不会受影响\n\n但是，由于 A.prototype 被覆盖( __重写__ ), __A.prototype.construct__ 也没有了, 但是！ 我们可以__手动添加__！ 并__不会__影响到 B.prototype！\n\n```\nA.prototype.construct = A;\n```\n\n综上，第二种方法，明显优于第一种。\n而且第二种方法还有什么好处呢？\n\n__我们不仅可以取到 B.prototype 里的各种方法, 属性。 而且，由于 A.prototype 是 B 的实例，A.prototype 的自身已经有了在 B 中声明的方法和属性。 这也就是我们所说的 继承。 __\n\n\n---\n写完这个, 想通了好多以前不理解的，开心Y(^_^)Y_)\n\n写博客真好～\n\n一定要坚持下去！！\n\n{% blockquote %}\n\n参考：\n_JavaScript 高级程序设计_\n\n{% endblockquote %}\n\n","source":"_posts/prototype.md","raw":"---\ntitle: 原型\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- 总结\n- 原型\n- prototype\n- JS 基础\n---\n\n这块好难理解，\n从最基础的开始,\n为了便于自己以后还能想起来，多写了很多废话\n\n###  构造函数，原型，实例\n\n- 构造函数都有一个 __原型对象( 原型 )__ prototype\n\n- 构造函数的 原型对象 ( prototype ) 里，都包含了一个指向 __构造函数__的指针 ( constructor )\n\n- 由于每个对象都有一原型， prototype 也有一个指向它的原型的指针( `__proto__` )\n\n- 实例都包含了一个指向 __原型对象( prototype )内部__的指针 (`__proto__`)。\n\n\n<!-- more  -->\n\n_**NOTE**_:\nconstructor:\n为了让每个对象知道 创造它的构造函数是谁，所以每一个 构造函数的 原型对象( prototype , 继承下去的 )  上都有一个 constructor 指向 它( 构造函数  ) 自己。( 心机 )\n\n\n下来看下实验\n\n```\n// 构造函数 createA\n// createA 的原型对象( prototype ) 有一个属性是 constructor,  constructor 是指向 createA 的\n\nfunction createA() {}\n\nconsole.log('function createA()');\nconsole.log( `createA.prototype: ${createA.prototype}` );\nconsole.log( `createA.prototype.constructor: ${createA.prototype.constructor}` );\n\n// objectA 是 createA 的一个实例\n// objectA 有一个 __proto__ 属性是指向 objectA.prototype ( 构造函数的原型对象 ) __内部__ 的\n\nlet objectA = new createA();\n\n// objectB 也有一个 __proto__ 属性，指向哪里呢？\n\nlet objectB = objectA;\n\nconsole.log('objectA');\nconsole.log('objectB');\n\nconsole.log( `objectA: ${objectA}` );\nconsole.log( `objectB: ${objectB}` );\n\nconsole.log(`objectA.__proto__: ${objectA.__proto__}`);\nconsole.log( `objectB.__proto__: ${objectB.__proto__}` );\n\nconsole.log(`objectA.__proto__.constructor: ${objectA.__proto__.constructor}`);\nconsole.log( `objectB.__proto__.constructor: ${objectB.__proto__.constructor}` );\n```\n\n结果:\n![](http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-16%20%E4%B8%8A%E5%8D%881.48.19.png)\n\n也就是说：\n\n`objectA = objectB`, A 就是 B 就是 A, 所以  __构造函数__ 之下就只有一层, 也就是 构造函数 这个 _爸爸/ 妈妈_ __只有__ 儿女，_没有_ 孙子 / 孙女 或者  孙孙子 / 孙孙女 。。。。之类\n\n\n那么，__构造函数 的原型对象__ (createA.prototype) 也是一个 _对象_，那么 这个_对象_的 原型 ( `createA.prototype.__proto__` ) 是什么？\n如果把它 (构造函数 的原型对象) 看成 实例的话，那么 它的 原型 (`__proto__`) 应该指向 它的 构造函数的原型对象 ( 也就是说 `createA.prototype.__proto__.constructor` `应该指向它的构造函数 ) 。那么这个构造函数是什么呢?\n\n测试一下\n\n```\nfunction createA() {}\n\nconsole.log('function createA()');\nconsole.log( `createA.prototype: ${createA.prototype}` );\n\nconsole.log( `createA.prototype.constructor: ${createA.prototype.constructor}` );\n\nconsole.log( `createA.prototype.__proto__: ${createA.prototype.__proto__}` );\n\nconsole.log( `createA.prototype.__proto__.constructor: ${createA.prototype.__proto__.constructor}` );\n\nconsole.log( `createA.prototype.__proto__._proto__: ${createA.prototype.__proto__.__proto__}` );\n```\n结果：\n\n![](http://img.jackon.me/proto_null.png)\n\n看到结果想起来，每个 __函数__都是 __对象__，\n所以 函数的 原型对象的 构造函数 ( `createA.prototype.__proto__.constructor`) 是 function object( ){ } ( JS 默认的所有对象的构造函数 ),\n因为函数都有对象原型 (function object() {} 的 对象原型，也就是`createA.prototype.__proto__` ) ，\n-所以 这个对象原型的 `__proto__` 是什么呢？\n 答案是 __null__。JS 中所有的原型链的最终都是 __null__\n\n\n#### 小小的总结一下\n\nJS 数据类型分为两种, 一种是 __基本数据类型( 数值字面量, 不是 object )__。\n\n第二种就是 __Object (复杂数据类型, 引用类型值，对象 ) 类型__。\n\n而 Object 中包括了许多类型 ( Array, Function, RegExp )\n\n而这些__复杂数据类型__ _每一个_ 都代表着_一个_ __构造函数__。\n也就是说,\n__每一个 数组 都是 Function Array ( Array 构造函数 )的实例，__ 每一个实例都是 它的构造函数的\n\n每一个 __非 Function 类型的对象__ 的 __原型__ 都指向着 相应 的__构造函数的 原型对象__ ( 比如  `array.__prop__` --> Array.prototype ( function Array), `string.__proto__ --> Object.prototype (function Object)` )。\n\n而 function 类型的原型对象 ( prototype ) 是 function Object。\n\n而最终 __function Object__ 的原型对象 ( prototype ) 是 __null__\n\n ! ! NOTE:\n 这里没有 函数类型的原型 --> function function (function 构造函数) 之说。\n\n### 原型链\n\n#### 概念\n\n- 是实现 _继承__ 的主要方法\n- 基本思想是利用 _原型_让一个 _引用类型_ __继承__另一个_引用类型_的 __属性和方法__。\n\n- 假如，我们让 原型对象 等于 另一个类型的 _实例_，此时的原型对象将包含一个指向 另一个原型对象 (prototype) 的指针(`__proto__`)。相应的，另一个原型对象 ( __prototype__) 中也包含着一个指向另一个构造函数(__constructor__) 的指针。\n\n👆的看得不是很懂。。。\n\n\n上个星期写到了这里，写不下去了。。\n\n昨天晚上向男票寻求帮助，感觉差不多了， 但是。。。 要先去面试，回来再补\n\n----\nupdate\n\n#### 我的理解\n\n原型链可以这样理解:\n\n每一个对象都是一个 container , 这个 container 里面都是些 key:value ( 键值对 )。 container 分为两部分，__第一部分__ 是自身包含的属性，方法。__第二部分__ 就是一个指向原型的指针 (prototype / _prop_)。\n\n而最重要的区别就是，寻找一个 key 的顺序。\n\n当我们寻找一个 key 的时候。首先，程序会从这个对象 ( container ) 的第一部分找起, 如果第一部分没有，则到 __第二部分__，根据指针到它所指的地址的对象 ( 原型对象 ) 上找。同样，原型对象也是一个 container, 它的结构跟之前的对象结构完全一样，所以在它的第一部分找不到的时候，程序会到它的第二部分的指针所指的对象 ( 原型对象 ) 上去找，而这个对象与前两个的结构也完全一样...... 就这样不停的寻找，直到找到寻找的 key, 完。\n\n而在这个寻找的过程中, 一个对象与另一个对象相连，形成的 __链__。\n而，基本上每一个 container 的第二部分的指针都是指向 __它的原型对象__ ( _这个对象往往也是 构造它自己的__构造函数__的 __原型对象___ ) 。\n而通过理论知识我们知道 ( 还有上面的实验 )。 最终这个链是 __止__ 于 __null__ 的。\n\n\n__如何能使这个链条更长呢? 使某一个__\n\n看到上面的 Object 类型, 所有 非 function Object 的 function 类型的 原型指针 都指向了 function Object 的原型对象。\n\n**也就是 __function__ 类型的, 可以将 原型链 连起来～**\n\n那么怎么连起来呢？\n\n假设，我们有 function A(){} ,  function B(){}\n\n我想到了 2 种方法:\n\n- 直接使 它们两个的 prototype 相等，即：\n\n```\n  A.prototype = B.prototype;\n```\n\n根据 JS 的引用赋值, 我们知道，A.prototype 与 B.prototype 现在指向的是同一个地址。\n\n当任何一方改动这个 地址的值，另一方取得的值也改变了。\n\n而且 指向 __构造函数 A__ 的指针( construct ) 指向了 __B__, ( 实例找不到爸爸了！ ), 而且！ 我们还不能改！\n\n- 使 A.prototype 的 __原型__ 指向 B.prototype，也就是 `A.prototype.__proto__` --> B.prototype\n\n我们知道, 一个 __构造函数__ 的 __实例__ 的 __原型__指针 (`__proto__`) 指向 __构造函数__的 __原型对象__( prototype )。\n\n```\nA.prototype = new B();\n```\n这样相当于， `A.prototype.__proto__` --> B.prototype,\n\n当我们改变 A.prototype 的值的时候 B.prototype 并不会受影响\n\n但是，由于 A.prototype 被覆盖( __重写__ ), __A.prototype.construct__ 也没有了, 但是！ 我们可以__手动添加__！ 并__不会__影响到 B.prototype！\n\n```\nA.prototype.construct = A;\n```\n\n综上，第二种方法，明显优于第一种。\n而且第二种方法还有什么好处呢？\n\n__我们不仅可以取到 B.prototype 里的各种方法, 属性。 而且，由于 A.prototype 是 B 的实例，A.prototype 的自身已经有了在 B 中声明的方法和属性。 这也就是我们所说的 继承。 __\n\n\n---\n写完这个, 想通了好多以前不理解的，开心Y(^_^)Y_)\n\n写博客真好～\n\n一定要坚持下去！！\n\n{% blockquote %}\n\n参考：\n_JavaScript 高级程序设计_\n\n{% endblockquote %}\n\n","slug":"prototype","published":1,"date":"2016-12-15T15:26:15.000Z","updated":"2016-12-22T15:49:18.000Z","_id":"ciwuvvoef0006yira2jazxsy0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这块好难理解，<br>从最基础的开始,<br>为了便于自己以后还能想起来，多写了很多废话</p>\n<h3 id=\"构造函数，原型，实例\"><a href=\"#构造函数，原型，实例\" class=\"headerlink\" title=\"构造函数，原型，实例\"></a>构造函数，原型，实例</h3><ul>\n<li><p>构造函数都有一个 <strong>原型对象( 原型 )</strong> prototype</p>\n</li>\n<li><p>构造函数的 原型对象 ( prototype ) 里，都包含了一个指向 <strong>构造函数</strong>的指针 ( constructor )</p>\n</li>\n<li><p>由于每个对象都有一原型， prototype 也有一个指向它的原型的指针( <code>__proto__</code> )</p>\n</li>\n<li><p>实例都包含了一个指向 <strong>原型对象( prototype )内部</strong>的指针 (<code>__proto__</code>)。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p><em><strong>NOTE</strong></em>:<br>constructor:<br>为了让每个对象知道 创造它的构造函数是谁，所以每一个 构造函数的 原型对象( prototype , 继承下去的 )  上都有一个 constructor 指向 它( 构造函数  ) 自己。( 心机 )</p>\n<p>下来看下实验</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 构造函数 createA</div><div class=\"line\">// createA 的原型对象( prototype ) 有一个属性是 constructor,  constructor 是指向 createA 的</div><div class=\"line\"></div><div class=\"line\">function createA() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;function createA()&apos;);</div><div class=\"line\">console.log( `createA.prototype: $&#123;createA.prototype&#125;` );</div><div class=\"line\">console.log( `createA.prototype.constructor: $&#123;createA.prototype.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">// objectA 是 createA 的一个实例</div><div class=\"line\">// objectA 有一个 __proto__ 属性是指向 objectA.prototype ( 构造函数的原型对象 ) __内部__ 的</div><div class=\"line\"></div><div class=\"line\">let objectA = new createA();</div><div class=\"line\"></div><div class=\"line\">// objectB 也有一个 __proto__ 属性，指向哪里呢？</div><div class=\"line\"></div><div class=\"line\">let objectB = objectA;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;objectA&apos;);</div><div class=\"line\">console.log(&apos;objectB&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log( `objectA: $&#123;objectA&#125;` );</div><div class=\"line\">console.log( `objectB: $&#123;objectB&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log(`objectA.__proto__: $&#123;objectA.__proto__&#125;`);</div><div class=\"line\">console.log( `objectB.__proto__: $&#123;objectB.__proto__&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log(`objectA.__proto__.constructor: $&#123;objectA.__proto__.constructor&#125;`);</div><div class=\"line\">console.log( `objectB.__proto__.constructor: $&#123;objectB.__proto__.constructor&#125;` );</div></pre></td></tr></table></figure>\n<p>结果:<br><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-16%20%E4%B8%8A%E5%8D%881.48.19.png\" alt=\"\"></p>\n<p>也就是说：</p>\n<p><code>objectA = objectB</code>, A 就是 B 就是 A, 所以  <strong>构造函数</strong> 之下就只有一层, 也就是 构造函数 这个 <em>爸爸/ 妈妈</em> <strong>只有</strong> 儿女，<em>没有</em> 孙子 / 孙女 或者  孙孙子 / 孙孙女 。。。。之类</p>\n<p>那么，<strong>构造函数 的原型对象</strong> (createA.prototype) 也是一个 <em>对象</em>，那么 这个<em>对象</em>的 原型 ( <code>createA.prototype.__proto__</code> ) 是什么？<br>如果把它 (构造函数 的原型对象) 看成 实例的话，那么 它的 原型 (<code>__proto__</code>) 应该指向 它的 构造函数的原型对象 ( 也就是说 <code>createA.prototype.__proto__.constructor</code> `应该指向它的构造函数 ) 。那么这个构造函数是什么呢?</p>\n<p>测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createA() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;function createA()&apos;);</div><div class=\"line\">console.log( `createA.prototype: $&#123;createA.prototype&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.constructor: $&#123;createA.prototype.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__: $&#123;createA.prototype.__proto__&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__.constructor: $&#123;createA.prototype.__proto__.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__._proto__: $&#123;createA.prototype.__proto__.__proto__&#125;` );</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/proto_null.png\" alt=\"\"></p>\n<p>看到结果想起来，每个 <strong>函数</strong>都是 <strong>对象</strong>，<br>所以 函数的 原型对象的 构造函数 ( <code>createA.prototype.__proto__.constructor</code>) 是 function object( ){ } ( JS 默认的所有对象的构造函数 ),<br>因为函数都有对象原型 (function object() {} 的 对象原型，也就是<code>createA.prototype.__proto__</code> ) ，<br>-所以 这个对象原型的 <code>__proto__</code> 是什么呢？<br> 答案是 <strong>null</strong>。JS 中所有的原型链的最终都是 <strong>null</strong></p>\n<h4 id=\"小小的总结一下\"><a href=\"#小小的总结一下\" class=\"headerlink\" title=\"小小的总结一下\"></a>小小的总结一下</h4><p>JS 数据类型分为两种, 一种是 <strong>基本数据类型( 数值字面量, 不是 object )</strong>。</p>\n<p>第二种就是 <strong>Object (复杂数据类型, 引用类型值，对象 ) 类型</strong>。</p>\n<p>而 Object 中包括了许多类型 ( Array, Function, RegExp )</p>\n<p>而这些<strong>复杂数据类型</strong> <em>每一个</em> 都代表着<em>一个</em> <strong>构造函数</strong>。<br>也就是说,<br><strong>每一个 数组 都是 Function Array ( Array 构造函数 )的实例，</strong> 每一个实例都是 它的构造函数的</p>\n<p>每一个 <strong>非 Function 类型的对象</strong> 的 <strong>原型</strong> 都指向着 相应 的<strong>构造函数的 原型对象</strong> ( 比如  <code>array.__prop__</code> –&gt; Array.prototype ( function Array), <code>string.__proto__ --&gt; Object.prototype (function Object)</code> )。</p>\n<p>而 function 类型的原型对象 ( prototype ) 是 function Object。</p>\n<p>而最终 <strong>function Object</strong> 的原型对象 ( prototype ) 是 <strong>null</strong></p>\n<p> ! ! NOTE:<br> 这里没有 函数类型的原型 –&gt; function function (function 构造函数) 之说。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li>是实现 _继承__ 的主要方法</li>\n<li><p>基本思想是利用 <em>原型</em>让一个 <em>引用类型</em> <strong>继承</strong>另一个<em>引用类型</em>的 <strong>属性和方法</strong>。</p>\n</li>\n<li><p>假如，我们让 原型对象 等于 另一个类型的 <em>实例</em>，此时的原型对象将包含一个指向 另一个原型对象 (prototype) 的指针(<code>__proto__</code>)。相应的，另一个原型对象 ( <strong>prototype</strong>) 中也包含着一个指向另一个构造函数(<strong>constructor</strong>) 的指针。</p>\n</li>\n</ul>\n<p>👆的看得不是很懂。。。</p>\n<p>上个星期写到了这里，写不下去了。。</p>\n<p>昨天晚上向男票寻求帮助，感觉差不多了， 但是。。。 要先去面试，回来再补</p>\n<hr>\n<p>update</p>\n<h4 id=\"我的理解\"><a href=\"#我的理解\" class=\"headerlink\" title=\"我的理解\"></a>我的理解</h4><p>原型链可以这样理解:</p>\n<p>每一个对象都是一个 container , 这个 container 里面都是些 key:value ( 键值对 )。 container 分为两部分，<strong>第一部分</strong> 是自身包含的属性，方法。<strong>第二部分</strong> 就是一个指向原型的指针 (prototype / <em>prop</em>)。</p>\n<p>而最重要的区别就是，寻找一个 key 的顺序。</p>\n<p>当我们寻找一个 key 的时候。首先，程序会从这个对象 ( container ) 的第一部分找起, 如果第一部分没有，则到 <strong>第二部分</strong>，根据指针到它所指的地址的对象 ( 原型对象 ) 上找。同样，原型对象也是一个 container, 它的结构跟之前的对象结构完全一样，所以在它的第一部分找不到的时候，程序会到它的第二部分的指针所指的对象 ( 原型对象 ) 上去找，而这个对象与前两个的结构也完全一样…… 就这样不停的寻找，直到找到寻找的 key, 完。</p>\n<p>而在这个寻找的过程中, 一个对象与另一个对象相连，形成的 <strong>链</strong>。<br>而，基本上每一个 container 的第二部分的指针都是指向 <strong>它的原型对象</strong> ( <em>这个对象往往也是 构造它自己的<strong>构造函数</strong>的 <strong>原型对象</strong></em> ) 。<br>而通过理论知识我们知道 ( 还有上面的实验 )。 最终这个链是 <strong>止</strong> 于 <strong>null</strong> 的。</p>\n<p><strong>如何能使这个链条更长呢? 使某一个</strong></p>\n<p>看到上面的 Object 类型, 所有 非 function Object 的 function 类型的 原型指针 都指向了 function Object 的原型对象。</p>\n<p><strong>也就是 <strong>function</strong> 类型的, 可以将 原型链 连起来～</strong></p>\n<p>那么怎么连起来呢？</p>\n<p>假设，我们有 function A(){} ,  function B(){}</p>\n<p>我想到了 2 种方法:</p>\n<ul>\n<li>直接使 它们两个的 prototype 相等，即：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype = B.prototype;</div></pre></td></tr></table></figure>\n<p>根据 JS 的引用赋值, 我们知道，A.prototype 与 B.prototype 现在指向的是同一个地址。</p>\n<p>当任何一方改动这个 地址的值，另一方取得的值也改变了。</p>\n<p>而且 指向 <strong>构造函数 A</strong> 的指针( construct ) 指向了 <strong>B</strong>, ( 实例找不到爸爸了！ ), 而且！ 我们还不能改！</p>\n<ul>\n<li>使 A.prototype 的 <strong>原型</strong> 指向 B.prototype，也就是 <code>A.prototype.__proto__</code> –&gt; B.prototype</li>\n</ul>\n<p>我们知道, 一个 <strong>构造函数</strong> 的 <strong>实例</strong> 的 <strong>原型</strong>指针 (<code>__proto__</code>) 指向 <strong>构造函数</strong>的 <strong>原型对象</strong>( prototype )。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype = new B();</div></pre></td></tr></table></figure>\n<p>这样相当于， <code>A.prototype.__proto__</code> –&gt; B.prototype,</p>\n<p>当我们改变 A.prototype 的值的时候 B.prototype 并不会受影响</p>\n<p>但是，由于 A.prototype 被覆盖( <strong>重写</strong> ), <strong>A.prototype.construct</strong> 也没有了, 但是！ 我们可以<strong>手动添加</strong>！ 并<strong>不会</strong>影响到 B.prototype！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype.construct = A;</div></pre></td></tr></table></figure>\n<p>综上，第二种方法，明显优于第一种。<br>而且第二种方法还有什么好处呢？</p>\n<p><strong>我们不仅可以取到 B.prototype 里的各种方法, 属性。 而且，由于 A.prototype 是 B 的实例，A.prototype 的自身已经有了在 B 中声明的方法和属性。 这也就是我们所说的 继承。 </strong></p>\n<hr>\n<p>写完这个, 想通了好多以前不理解的，开心Y(^<em>^)Y</em>)</p>\n<p>写博客真好～</p>\n<p>一定要坚持下去！！</p>\n<blockquote><p>参考：<br><em>JavaScript 高级程序设计</em></p>\n</blockquote>\n","excerpt":"<p>这块好难理解，<br>从最基础的开始,<br>为了便于自己以后还能想起来，多写了很多废话</p>\n<h3 id=\"构造函数，原型，实例\"><a href=\"#构造函数，原型，实例\" class=\"headerlink\" title=\"构造函数，原型，实例\"></a>构造函数，原型，实例</h3><ul>\n<li><p>构造函数都有一个 <strong>原型对象( 原型 )</strong> prototype</p>\n</li>\n<li><p>构造函数的 原型对象 ( prototype ) 里，都包含了一个指向 <strong>构造函数</strong>的指针 ( constructor )</p>\n</li>\n<li><p>由于每个对象都有一原型， prototype 也有一个指向它的原型的指针( <code>__proto__</code> )</p>\n</li>\n<li><p>实例都包含了一个指向 <strong>原型对象( prototype )内部</strong>的指针 (<code>__proto__</code>)。</p>\n</li>\n</ul>","more":"<p><em><strong>NOTE</strong></em>:<br>constructor:<br>为了让每个对象知道 创造它的构造函数是谁，所以每一个 构造函数的 原型对象( prototype , 继承下去的 )  上都有一个 constructor 指向 它( 构造函数  ) 自己。( 心机 )</p>\n<p>下来看下实验</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 构造函数 createA</div><div class=\"line\">// createA 的原型对象( prototype ) 有一个属性是 constructor,  constructor 是指向 createA 的</div><div class=\"line\"></div><div class=\"line\">function createA() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;function createA()&apos;);</div><div class=\"line\">console.log( `createA.prototype: $&#123;createA.prototype&#125;` );</div><div class=\"line\">console.log( `createA.prototype.constructor: $&#123;createA.prototype.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">// objectA 是 createA 的一个实例</div><div class=\"line\">// objectA 有一个 __proto__ 属性是指向 objectA.prototype ( 构造函数的原型对象 ) __内部__ 的</div><div class=\"line\"></div><div class=\"line\">let objectA = new createA();</div><div class=\"line\"></div><div class=\"line\">// objectB 也有一个 __proto__ 属性，指向哪里呢？</div><div class=\"line\"></div><div class=\"line\">let objectB = objectA;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;objectA&apos;);</div><div class=\"line\">console.log(&apos;objectB&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log( `objectA: $&#123;objectA&#125;` );</div><div class=\"line\">console.log( `objectB: $&#123;objectB&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log(`objectA.__proto__: $&#123;objectA.__proto__&#125;`);</div><div class=\"line\">console.log( `objectB.__proto__: $&#123;objectB.__proto__&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log(`objectA.__proto__.constructor: $&#123;objectA.__proto__.constructor&#125;`);</div><div class=\"line\">console.log( `objectB.__proto__.constructor: $&#123;objectB.__proto__.constructor&#125;` );</div></pre></td></tr></table></figure>\n<p>结果:<br><img src=\"http://img.jackon.me/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-16%20%E4%B8%8A%E5%8D%881.48.19.png\" alt=\"\"></p>\n<p>也就是说：</p>\n<p><code>objectA = objectB</code>, A 就是 B 就是 A, 所以  <strong>构造函数</strong> 之下就只有一层, 也就是 构造函数 这个 <em>爸爸/ 妈妈</em> <strong>只有</strong> 儿女，<em>没有</em> 孙子 / 孙女 或者  孙孙子 / 孙孙女 。。。。之类</p>\n<p>那么，<strong>构造函数 的原型对象</strong> (createA.prototype) 也是一个 <em>对象</em>，那么 这个<em>对象</em>的 原型 ( <code>createA.prototype.__proto__</code> ) 是什么？<br>如果把它 (构造函数 的原型对象) 看成 实例的话，那么 它的 原型 (<code>__proto__</code>) 应该指向 它的 构造函数的原型对象 ( 也就是说 <code>createA.prototype.__proto__.constructor</code> `应该指向它的构造函数 ) 。那么这个构造函数是什么呢?</p>\n<p>测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createA() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;function createA()&apos;);</div><div class=\"line\">console.log( `createA.prototype: $&#123;createA.prototype&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.constructor: $&#123;createA.prototype.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__: $&#123;createA.prototype.__proto__&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__.constructor: $&#123;createA.prototype.__proto__.constructor&#125;` );</div><div class=\"line\"></div><div class=\"line\">console.log( `createA.prototype.__proto__._proto__: $&#123;createA.prototype.__proto__.__proto__&#125;` );</div></pre></td></tr></table></figure>\n<p>结果：</p>\n<p><img src=\"http://img.jackon.me/proto_null.png\" alt=\"\"></p>\n<p>看到结果想起来，每个 <strong>函数</strong>都是 <strong>对象</strong>，<br>所以 函数的 原型对象的 构造函数 ( <code>createA.prototype.__proto__.constructor</code>) 是 function object( ){ } ( JS 默认的所有对象的构造函数 ),<br>因为函数都有对象原型 (function object() {} 的 对象原型，也就是<code>createA.prototype.__proto__</code> ) ，<br>-所以 这个对象原型的 <code>__proto__</code> 是什么呢？<br> 答案是 <strong>null</strong>。JS 中所有的原型链的最终都是 <strong>null</strong></p>\n<h4 id=\"小小的总结一下\"><a href=\"#小小的总结一下\" class=\"headerlink\" title=\"小小的总结一下\"></a>小小的总结一下</h4><p>JS 数据类型分为两种, 一种是 <strong>基本数据类型( 数值字面量, 不是 object )</strong>。</p>\n<p>第二种就是 <strong>Object (复杂数据类型, 引用类型值，对象 ) 类型</strong>。</p>\n<p>而 Object 中包括了许多类型 ( Array, Function, RegExp )</p>\n<p>而这些<strong>复杂数据类型</strong> <em>每一个</em> 都代表着<em>一个</em> <strong>构造函数</strong>。<br>也就是说,<br><strong>每一个 数组 都是 Function Array ( Array 构造函数 )的实例，</strong> 每一个实例都是 它的构造函数的</p>\n<p>每一个 <strong>非 Function 类型的对象</strong> 的 <strong>原型</strong> 都指向着 相应 的<strong>构造函数的 原型对象</strong> ( 比如  <code>array.__prop__</code> –&gt; Array.prototype ( function Array), <code>string.__proto__ --&gt; Object.prototype (function Object)</code> )。</p>\n<p>而 function 类型的原型对象 ( prototype ) 是 function Object。</p>\n<p>而最终 <strong>function Object</strong> 的原型对象 ( prototype ) 是 <strong>null</strong></p>\n<p> ! ! NOTE:<br> 这里没有 函数类型的原型 –&gt; function function (function 构造函数) 之说。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li>是实现 _继承__ 的主要方法</li>\n<li><p>基本思想是利用 <em>原型</em>让一个 <em>引用类型</em> <strong>继承</strong>另一个<em>引用类型</em>的 <strong>属性和方法</strong>。</p>\n</li>\n<li><p>假如，我们让 原型对象 等于 另一个类型的 <em>实例</em>，此时的原型对象将包含一个指向 另一个原型对象 (prototype) 的指针(<code>__proto__</code>)。相应的，另一个原型对象 ( <strong>prototype</strong>) 中也包含着一个指向另一个构造函数(<strong>constructor</strong>) 的指针。</p>\n</li>\n</ul>\n<p>👆的看得不是很懂。。。</p>\n<p>上个星期写到了这里，写不下去了。。</p>\n<p>昨天晚上向男票寻求帮助，感觉差不多了， 但是。。。 要先去面试，回来再补</p>\n<hr>\n<p>update</p>\n<h4 id=\"我的理解\"><a href=\"#我的理解\" class=\"headerlink\" title=\"我的理解\"></a>我的理解</h4><p>原型链可以这样理解:</p>\n<p>每一个对象都是一个 container , 这个 container 里面都是些 key:value ( 键值对 )。 container 分为两部分，<strong>第一部分</strong> 是自身包含的属性，方法。<strong>第二部分</strong> 就是一个指向原型的指针 (prototype / <em>prop</em>)。</p>\n<p>而最重要的区别就是，寻找一个 key 的顺序。</p>\n<p>当我们寻找一个 key 的时候。首先，程序会从这个对象 ( container ) 的第一部分找起, 如果第一部分没有，则到 <strong>第二部分</strong>，根据指针到它所指的地址的对象 ( 原型对象 ) 上找。同样，原型对象也是一个 container, 它的结构跟之前的对象结构完全一样，所以在它的第一部分找不到的时候，程序会到它的第二部分的指针所指的对象 ( 原型对象 ) 上去找，而这个对象与前两个的结构也完全一样…… 就这样不停的寻找，直到找到寻找的 key, 完。</p>\n<p>而在这个寻找的过程中, 一个对象与另一个对象相连，形成的 <strong>链</strong>。<br>而，基本上每一个 container 的第二部分的指针都是指向 <strong>它的原型对象</strong> ( <em>这个对象往往也是 构造它自己的<strong>构造函数</strong>的 <strong>原型对象</strong></em> ) 。<br>而通过理论知识我们知道 ( 还有上面的实验 )。 最终这个链是 <strong>止</strong> 于 <strong>null</strong> 的。</p>\n<p><strong>如何能使这个链条更长呢? 使某一个</strong></p>\n<p>看到上面的 Object 类型, 所有 非 function Object 的 function 类型的 原型指针 都指向了 function Object 的原型对象。</p>\n<p><strong>也就是 <strong>function</strong> 类型的, 可以将 原型链 连起来～</strong></p>\n<p>那么怎么连起来呢？</p>\n<p>假设，我们有 function A(){} ,  function B(){}</p>\n<p>我想到了 2 种方法:</p>\n<ul>\n<li>直接使 它们两个的 prototype 相等，即：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype = B.prototype;</div></pre></td></tr></table></figure>\n<p>根据 JS 的引用赋值, 我们知道，A.prototype 与 B.prototype 现在指向的是同一个地址。</p>\n<p>当任何一方改动这个 地址的值，另一方取得的值也改变了。</p>\n<p>而且 指向 <strong>构造函数 A</strong> 的指针( construct ) 指向了 <strong>B</strong>, ( 实例找不到爸爸了！ ), 而且！ 我们还不能改！</p>\n<ul>\n<li>使 A.prototype 的 <strong>原型</strong> 指向 B.prototype，也就是 <code>A.prototype.__proto__</code> –&gt; B.prototype</li>\n</ul>\n<p>我们知道, 一个 <strong>构造函数</strong> 的 <strong>实例</strong> 的 <strong>原型</strong>指针 (<code>__proto__</code>) 指向 <strong>构造函数</strong>的 <strong>原型对象</strong>( prototype )。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype = new B();</div></pre></td></tr></table></figure>\n<p>这样相当于， <code>A.prototype.__proto__</code> –&gt; B.prototype,</p>\n<p>当我们改变 A.prototype 的值的时候 B.prototype 并不会受影响</p>\n<p>但是，由于 A.prototype 被覆盖( <strong>重写</strong> ), <strong>A.prototype.construct</strong> 也没有了, 但是！ 我们可以<strong>手动添加</strong>！ 并<strong>不会</strong>影响到 B.prototype！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.prototype.construct = A;</div></pre></td></tr></table></figure>\n<p>综上，第二种方法，明显优于第一种。<br>而且第二种方法还有什么好处呢？</p>\n<p><strong>我们不仅可以取到 B.prototype 里的各种方法, 属性。 而且，由于 A.prototype 是 B 的实例，A.prototype 的自身已经有了在 B 中声明的方法和属性。 这也就是我们所说的 继承。 </strong></p>\n<hr>\n<p>写完这个, 想通了好多以前不理解的，开心Y(^<em>^)Y</em>)</p>\n<p>写博客真好～</p>\n<p>一定要坚持下去！！</p>\n<blockquote><p>参考：<br><em>JavaScript 高级程序设计</em></p>\n</blockquote>"},{"title":"BFC ( Block Formatting Context )","auto_spacing":true,"_content":"\n#### 表现\n\n- 在创建了 Block Formatting Context 的元素中，\n\n 垂直方向上：其子元素会一个接一个地放置，他们的起点是一个 BFC 的顶部，两个相邻元素的块级元素的垂直边距会 __折叠__。\n  水平方向上：每一个盒子的左外边缘 ( margin-left ) 会触碰到容器的左边缘 ( border-left )（ 从右到左则是右边缘 ），即使存在浮动也是如此，除非这个元素也创建了一个新\n  的 BFC\n- BFC 元素的布局是不受外界的影响，容器里面的子元素也不会影响到外面的元素的 ( 常用此来清除浮动 )\n\n- 计算高度的时候，浮动元素也会算在其中\n\n#### 创建 BFC\n\nFloats, absolutely positioned elements, block containers that are not block  boxes,\nblock boxes with 'overflow' oter than 'visible' establish new block formatting contexts for their __contents__.\n\n- 根元素或其它包含它的元素\n- 浮动\n- 绝对定位  ( position 为 absolute 或 fixed)\n- 非块级盒子的块级容器。 ( inline-block, table-cell, table-captions )\n- overflow 不是 visible 的块极盒子。\n- 弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)\n\n\n<!-- more -->\n\n#### 利用 BFC\n\n- 清除浮动\n\n```\n.clearfix {\n    *zoom: 1;\n}\n.clearfix:after {\n    content: '';\n    display: table;\n    clear: both;\n}\n```\n\n- float ( 左边 ) + padding／margin ( 在 float 元素上 )  + BFC ( 右边 ) 实现自适应布局，无需担心元素宽度\n\n    - overflow:auto/hidden  IE7+\n    - display: inline-block  IE6/IE7\n    - display: table-cell  IE8+\n\n- 两栏／多栏自适应布局的通用类语句 ( block 水平的标签 ！ 需要配合 浮动 ) ( 要清除浮动哦 )\n\n```\n.cell {\n    display: table-cell;\n    width: 9999px;\n    *display: inline-block;\n    *width: auto;\n}\n```\n\n\n{% blockquote %}\n\n参考：\n\n[张鑫旭:CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)\n\n[W3help:KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n\n[KB010: 常规流( Normal flow )](http://w3help.org/zh-cn/kb/010/)\n\n{% endblockquote %}\n","source":"_posts/BFC.md","raw":"---\ntitle: BFC ( Block Formatting Context )\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- CSS 布局\n- BFC\nauto_spacing: true\n---\n\n#### 表现\n\n- 在创建了 Block Formatting Context 的元素中，\n\n 垂直方向上：其子元素会一个接一个地放置，他们的起点是一个 BFC 的顶部，两个相邻元素的块级元素的垂直边距会 __折叠__。\n  水平方向上：每一个盒子的左外边缘 ( margin-left ) 会触碰到容器的左边缘 ( border-left )（ 从右到左则是右边缘 ），即使存在浮动也是如此，除非这个元素也创建了一个新\n  的 BFC\n- BFC 元素的布局是不受外界的影响，容器里面的子元素也不会影响到外面的元素的 ( 常用此来清除浮动 )\n\n- 计算高度的时候，浮动元素也会算在其中\n\n#### 创建 BFC\n\nFloats, absolutely positioned elements, block containers that are not block  boxes,\nblock boxes with 'overflow' oter than 'visible' establish new block formatting contexts for their __contents__.\n\n- 根元素或其它包含它的元素\n- 浮动\n- 绝对定位  ( position 为 absolute 或 fixed)\n- 非块级盒子的块级容器。 ( inline-block, table-cell, table-captions )\n- overflow 不是 visible 的块极盒子。\n- 弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)\n\n\n<!-- more -->\n\n#### 利用 BFC\n\n- 清除浮动\n\n```\n.clearfix {\n    *zoom: 1;\n}\n.clearfix:after {\n    content: '';\n    display: table;\n    clear: both;\n}\n```\n\n- float ( 左边 ) + padding／margin ( 在 float 元素上 )  + BFC ( 右边 ) 实现自适应布局，无需担心元素宽度\n\n    - overflow:auto/hidden  IE7+\n    - display: inline-block  IE6/IE7\n    - display: table-cell  IE8+\n\n- 两栏／多栏自适应布局的通用类语句 ( block 水平的标签 ！ 需要配合 浮动 ) ( 要清除浮动哦 )\n\n```\n.cell {\n    display: table-cell;\n    width: 9999px;\n    *display: inline-block;\n    *width: auto;\n}\n```\n\n\n{% blockquote %}\n\n参考：\n\n[张鑫旭:CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)\n\n[W3help:KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n\n[KB010: 常规流( Normal flow )](http://w3help.org/zh-cn/kb/010/)\n\n{% endblockquote %}\n","slug":"BFC","published":1,"date":"2016-12-10T13:25:43.000Z","updated":"2016-12-19T03:31:46.000Z","_id":"ciwvin0nj000ayiraff3i7vml","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h4><ul>\n<li><p>在创建了 Block Formatting Context 的元素中，</p>\n<p>垂直方向上：其子元素会一个接一个地放置，他们的起点是一个 BFC 的顶部，两个相邻元素的块级元素的垂直边距会 <strong>折叠</strong>。<br>水平方向上：每一个盒子的左外边缘 ( margin-left ) 会触碰到容器的左边缘 ( border-left )（ 从右到左则是右边缘 ），即使存在浮动也是如此，除非这个元素也创建了一个新<br>的 BFC</p>\n</li>\n<li><p>BFC 元素的布局是不受外界的影响，容器里面的子元素也不会影响到外面的元素的 ( 常用此来清除浮动 )</p>\n</li>\n<li><p>计算高度的时候，浮动元素也会算在其中</p>\n</li>\n</ul>\n<h4 id=\"创建-BFC\"><a href=\"#创建-BFC\" class=\"headerlink\" title=\"创建 BFC\"></a>创建 BFC</h4><p>Floats, absolutely positioned elements, block containers that are not block  boxes,<br>block boxes with ‘overflow’ oter than ‘visible’ establish new block formatting contexts for their <strong>contents</strong>.</p>\n<ul>\n<li>根元素或其它包含它的元素</li>\n<li>浮动</li>\n<li>绝对定位  ( position 为 absolute 或 fixed)</li>\n<li>非块级盒子的块级容器。 ( inline-block, table-cell, table-captions )</li>\n<li>overflow 不是 visible 的块极盒子。</li>\n<li>弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"利用-BFC\"><a href=\"#利用-BFC\" class=\"headerlink\" title=\"利用 BFC\"></a>利用 BFC</h4><ul>\n<li>清除浮动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.clearfix &#123;</div><div class=\"line\">    *zoom: 1;</div><div class=\"line\">&#125;</div><div class=\"line\">.clearfix:after &#123;</div><div class=\"line\">    content: &apos;&apos;;</div><div class=\"line\">    display: table;</div><div class=\"line\">    clear: both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>float ( 左边 ) + padding／margin ( 在 float 元素上 )  + BFC ( 右边 ) 实现自适应布局，无需担心元素宽度</p>\n<ul>\n<li>overflow:auto/hidden  IE7+</li>\n<li>display: inline-block  IE6/IE7</li>\n<li>display: table-cell  IE8+</li>\n</ul>\n</li>\n<li><p>两栏／多栏自适应布局的通用类语句 ( block 水平的标签 ！ 需要配合 浮动 ) ( 要清除浮动哦 )</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    width: 9999px;</div><div class=\"line\">    *display: inline-block;</div><div class=\"line\">    *width: auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote><p>参考：</p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\" target=\"_blank\" rel=\"external\">张鑫旭:CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/\" target=\"_blank\" rel=\"external\">W3help:KB006: CSS 框模型( Box module )</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/010/\" target=\"_blank\" rel=\"external\">KB010: 常规流( Normal flow )</a></p>\n</blockquote>\n","excerpt":"<h4 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h4><ul>\n<li><p>在创建了 Block Formatting Context 的元素中，</p>\n<p>垂直方向上：其子元素会一个接一个地放置，他们的起点是一个 BFC 的顶部，两个相邻元素的块级元素的垂直边距会 <strong>折叠</strong>。<br>水平方向上：每一个盒子的左外边缘 ( margin-left ) 会触碰到容器的左边缘 ( border-left )（ 从右到左则是右边缘 ），即使存在浮动也是如此，除非这个元素也创建了一个新<br>的 BFC</p>\n</li>\n<li><p>BFC 元素的布局是不受外界的影响，容器里面的子元素也不会影响到外面的元素的 ( 常用此来清除浮动 )</p>\n</li>\n<li><p>计算高度的时候，浮动元素也会算在其中</p>\n</li>\n</ul>\n<h4 id=\"创建-BFC\"><a href=\"#创建-BFC\" class=\"headerlink\" title=\"创建 BFC\"></a>创建 BFC</h4><p>Floats, absolutely positioned elements, block containers that are not block  boxes,<br>block boxes with ‘overflow’ oter than ‘visible’ establish new block formatting contexts for their <strong>contents</strong>.</p>\n<ul>\n<li>根元素或其它包含它的元素</li>\n<li>浮动</li>\n<li>绝对定位  ( position 为 absolute 或 fixed)</li>\n<li>非块级盒子的块级容器。 ( inline-block, table-cell, table-captions )</li>\n<li>overflow 不是 visible 的块极盒子。</li>\n<li>弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)</li>\n</ul>","more":"<h4 id=\"利用-BFC\"><a href=\"#利用-BFC\" class=\"headerlink\" title=\"利用 BFC\"></a>利用 BFC</h4><ul>\n<li>清除浮动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.clearfix &#123;</div><div class=\"line\">    *zoom: 1;</div><div class=\"line\">&#125;</div><div class=\"line\">.clearfix:after &#123;</div><div class=\"line\">    content: &apos;&apos;;</div><div class=\"line\">    display: table;</div><div class=\"line\">    clear: both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>float ( 左边 ) + padding／margin ( 在 float 元素上 )  + BFC ( 右边 ) 实现自适应布局，无需担心元素宽度</p>\n<ul>\n<li>overflow:auto/hidden  IE7+</li>\n<li>display: inline-block  IE6/IE7</li>\n<li>display: table-cell  IE8+</li>\n</ul>\n</li>\n<li><p>两栏／多栏自适应布局的通用类语句 ( block 水平的标签 ！ 需要配合 浮动 ) ( 要清除浮动哦 )</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    width: 9999px;</div><div class=\"line\">    *display: inline-block;</div><div class=\"line\">    *width: auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote><p>参考：</p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\">张鑫旭:CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/\">W3help:KB006: CSS 框模型( Box module )</a></p>\n<p><a href=\"http://w3help.org/zh-cn/kb/010/\">KB010: 常规流( Normal flow )</a></p>\n</blockquote>"},{"title":"这是一篇需要置顶，还未置顶的文章","_content":"\n这篇会写我需要做的事 ( 想要做的 )\n1. 我的空手道！！！ 梦到好多次。。😢。。 犹豫要不要去 上海部。。。离家近的有一个 泰拳 可以考虑。。 纠结。。。\n2. 尝试一下 HTTP2\n3. 尝试一下 PWA / srivce-works\n4. Angular 2.0\n5. leetcode 学算法！--- 当然这是一个漫长的过程，一天一个只要坚持下来就好了。。。\n6. 整理 CSS 基础知识----从普通流开始\n7. 博客置顶\n8. 优化博客\n<!-- more -->\n","source":"_posts/top.md","raw":"---\ntitle: 这是一篇需要置顶，还未置顶的文章\ncategories:\n- 生活\ntags:\n- 总结\n- lists\n---\n\n这篇会写我需要做的事 ( 想要做的 )\n1. 我的空手道！！！ 梦到好多次。。😢。。 犹豫要不要去 上海部。。。离家近的有一个 泰拳 可以考虑。。 纠结。。。\n2. 尝试一下 HTTP2\n3. 尝试一下 PWA / srivce-works\n4. Angular 2.0\n5. leetcode 学算法！--- 当然这是一个漫长的过程，一天一个只要坚持下来就好了。。。\n6. 整理 CSS 基础知识----从普通流开始\n7. 博客置顶\n8. 优化博客\n<!-- more -->\n","slug":"top","published":1,"date":"2016-12-19T03:31:58.000Z","updated":"2016-12-19T03:51:45.000Z","_id":"ciwviz9kr000myirak7j3suzs","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇会写我需要做的事 ( 想要做的 )</p>\n<ol>\n<li>我的空手道！！！ 梦到好多次。。😢。。 犹豫要不要去 上海部。。。离家近的有一个 泰拳 可以考虑。。 纠结。。。</li>\n<li>尝试一下 HTTP2</li>\n<li>尝试一下 PWA / srivce-works</li>\n<li>Angular 2.0</li>\n<li>leetcode 学算法！— 当然这是一个漫长的过程，一天一个只要坚持下来就好了。。。</li>\n<li>整理 CSS 基础知识—-从普通流开始</li>\n<li>博客置顶</li>\n<li>优化博客<a id=\"more\"></a>\n</li>\n</ol>\n","excerpt":"<p>这篇会写我需要做的事 ( 想要做的 )</p>\n<ol>\n<li>我的空手道！！！ 梦到好多次。。😢。。 犹豫要不要去 上海部。。。离家近的有一个 泰拳 可以考虑。。 纠结。。。</li>\n<li>尝试一下 HTTP2</li>\n<li>尝试一下 PWA / srivce-works</li>\n<li>Angular 2.0</li>\n<li>leetcode 学算法！— 当然这是一个漫长的过程，一天一个只要坚持下来就好了。。。</li>\n<li>整理 CSS 基础知识—-从普通流开始</li>\n<li>博客置顶</li>\n<li>优化博客","more":"</li>\n</ol>"},{"title":"JS 定时器","_content":"\n假设没有 Web Works\n\n### 基本知识\n\nJavaScript 的运行是 __单线程__的，而定时器只是 __计划__ 代码在未来某个时间执行。 而执行的时机是__不能__保证的。\n\n因为在页面的使命周期中，不同的时间可能有其他的代码在控制 ( 我的理解是 _占用_ ) JavaScript 进程 。\n\n在页面下载完成后的代码运行，事件处理程序，Ajax __回调函数__都必须在同一个线程中执行。\n\n__实际上，浏览器负责进行排序，指派某段代码在某个时间点上运行的优先级。__\n\n可以把 JS 想象成在时间线 ( __一维__ ) 上运行的。\n当页面载入时, 首先执行的是任何包含在 <script> 元素中的代码, 通常是页面生命周期后面要用到的一些简单的函数和变量的声明, 不过有时候也包含一些初始数据的处理。 在这之后， JS 进程将等待更多代码执行。__当进程空闲的时候，下一个代码会被触发并立刻执行。__ 例如，当点击某个按钮时，当 JS 进程处于空闲状态， onclick 事件处理程序会立刻执行。\n\n除了主 JS 执行进程外，还有一个需要在进程下一次空闲时执行的 __代码队列__。\n例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到 __队列__ 中，并在下一个可能的时间里执行。当接收到某个 __Ajax__ 响应时，__回调函数__ 的代码会被添加到__队列__。\n\n**在 JS 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行** 。\n\n![](http://img.jackon.me/js.svg)\n\n虽然 JS 的引擎是单线程的，但是 JS 的运行环境往往不是单线程的。\n比如，浏览器。浏览器有 Javascript 引擎线程 ( 用于处理 JS )，浏览器事件触发线程 ( 用于控制交互 )，Http 请求线程，GUI 界面渲染线程 ( 用于页面渲染 ) 等。\n\n- JS 引擎是基于事件驱动的，采用的是单线程运行机制。即 JS 引擎只会顺序的从任务列表中取任务执行。\n- 浏览器事件触发线程：当一个事件被触发的时候，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。\n- GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘( Repaint ) 或由于某种操作引发回流 ( Reflow ) 时，该线程就会执行。\nNOTE: GUI 渲染线程与 JS 引擎是 __互斥__的。因为 JS 可以操作 DOM 元素，会影响 GUI 的渲染结果。所以当 __JS  引擎__执行时 __ GUI 线程__就会被 __挂起__， __GUI 更新__会被保存在一个__队列__中等到 JS 引擎空闲时立即被执行。\n\n#### 定时器 setTimeout()\n\n- 定时器的工作方式是，__当特定的时间过去后，将代码插入到队列( 并不意味着立刻执行 )。__\n\n- 关于定时器 __最重要的事情__是, __指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。__\n\n- __由于 JS 进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定( 代码长时间运行中可能出现 )。__\n\n设置一个定时器，确保在定时器代码执行前至少有一个 __进程间隔__\n\n#### 重复的定时器 setInterval()\n\n使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列。\n\n但是，这样定时器代码再次被被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次。\n\n所以，__ 当使用 setInteval() 时，仅当没有该定时器的任何代码实例时，才将定时器代码添加到队列中。__\n\n这样确保了定时器代码加入到队列中的__最小时间间隔__为__指定间隔__。\n\n但是这种重复定时器的规则有两个问题：第 1 个问题，某些间隔会被跳过。第 2 个问题，多个定时器的代码执行之间的间隔会比预期的小。\n\n比如：某个 onclick 事件处理程序使用 setInterval() 设置了一个 200ms 间隔的重复定时器。如果事件处理程序花了 300ms 完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器的代码的情况。\n\n_为了避免 setInterval() 的重复定时器的这 2 个缺点，你可以通过用如下模式使用链式 setTimeout() 调用。_\n\n```\nsetTimeout(()=>{\n  // do somethings\n\n  setTimeout(arguments.callee, interval);\n}, interval);\n```\n\n这个模式链式调用了  setTimeout(), 每次函数执行的时候都会创建一个新的定时器。第二个 setTimeout() 调用使用了 arguments.callee 来获取对当前执行的函数的引用，并为其设置另外一个定时器。\n\n这样做的好处是：\n\n- 在前一个定时器代码执行完成之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。\n\n- 它可以保证在下一次定时器代码执行之前，__至少__要等待指定的间隔，__避免了连续的运行。__\n\n这个模式主要用于重复定时器，如下：\n\n```\nsetTimeout(()=>{\n  let div = document.getElementById('myDiv');\n  left = parseInt(div.style.left) + 5;\n  div.style.left = left + \"px\";\n\n  if( left < 200 ) {\n    setTimeout(arguments.callee, 50);\n  }\n}, 50 );\n```\n这段定时器代码每次执行的时候将一个 <div> 元素向右移动，当左坐标在 200 像素的时候停止。\n\nNOTE：\n每个浏览器窗口，标签页，或者  frame 都有其各自的代码执行队列。这意味着，进行跨  frame 或者 跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。无论何时需要使用这种通信类型，最好是在接收懂  frame 或者 窗口中创建一个定时器来执行代码。\n\n理解这个图就 ok 了！\n![](http://img.jackon.me/Timers.png)\n\n###  Yielding Processes\n\n运行在浏览器中的 JavaScript 都会被分配一个确定数量的资源。并且 浏览器严格限制了 JavaScript 需要的内存大小和处理时间。\n其中一个限制是长时间运行脚本的限制，如果代码运行超过了特定的时间或者特定的语句数量，就会弹出一个浏览器错误的对话框，告诉用户，某个脚本会用过长的时间执行，询问是否允许继续执行。\n所有 JavaScript 开发人员的目标就是确保用户永远不会在浏览器中看到这个对话框。\n\n定时器是绕开此限制的方法之一。\n\n脚本长时间运行的问题通常是由两个原因之一造成的： 过长的，过深嵌套的函数调用，或者是 进行大量处理的循环。\n这两者中，后者是比较容易解决的。\n长时间的循环通畅遵循以下模式：\n\n```\nfor (var i=0, len = data.length; i<len; i++ ){\n  process( data[i] );\n}\n```\n\n这个模式问题在于  __要处理的项目的数量__ 在运行前是 __不可知的__。 数组中的的项目数量之间关系到该数组循环的时间长度。同时由于 JS 的执行是一个 __阻塞操作__，脚本运行花费的时间越久，用户__无法__与页面交互的时间越久。\n\n 在展开该循环前，你需要回答这两个问题：\n\n- 该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。不过，如果你的回答是__否__, 那么可以将某些处理推迟。\n\n- 数据是否必须按顺序完成？如果项目的顺序不是非常 重要，可能可以将某些处理推迟。\n\n当你发现某个循环占用了大量的时间，同时对于上述的两个问题，你的回答都是 __否__, 那么你就可以使用 __定时器分割这个循环__。\n这是一种叫做 __数组分块__ 的技术。小块小块的处理数组。\n基本思路就是为要处理的项目 __创建一个队列__, 然后使用 __定时器__ 取出下一个要处理的项目进行处理，接着在 __设置另一个定时器__。基本模式如下：\n\n```\nsetTimeout( ()=>{\n\n  var item = array.shift();\n  process( item );\n\n  if( array.length > 0 ) {\n    setTimeout(arguments.callee, 100);\n  }\n} , 100);\n```\n\n在这个模式中， array 变量本质上就是一个 “待办事宜” 列表，它包含了要处理的项目。 使用 shift() 方法可以获取队列中的下一个要处理的项目，然后将其传递给某个函数。如果队列中还有项目，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。\n\n要实现数组分块可以使用以下函数：\n\n```\n/**\n * @ array 要处理的项目的数组\n * @ process 处理项目的函数\n * @ context 运行该函数的执行环境\n */\n\nfunction chunk(array, process, context) {\n  setTimeout( ()=>{\n    var item = array.shift();\n    process.call( context, item);\n\n    if( array.length > 0 ) {\n      setTimeout( arguments.callee, 100 );\n    }\n  }, 100);\n}\n```\n定时器的时间间隔设置了 100 ms , 使得在  JS 进程在处理项目的时间 间 转入空闲。\n\n__ NOTE: __\nchunk() 是会 __改变__ 传递进来的数组的。所以你想保持原数组不变，则应该将该数组的副本 传递给 chunk() , 如:\n\n```\nchunk( data.concat(), printValue );\n```\n\n数据分块的__重要性__在于：它可以将多个项目的处理在 __执行队列上分开__，在每个项目处理之后，__给予其他__的浏览器__处理机会__，_这样就可能避免长时间运行脚本的错误_。\n\nNOTE:\n一旦某函数需要花 __50ms__  以上的时间完成，那么最好看看是否能将任务分割。\n\n\n#### 函数节流\n\n浏览器中某些计算和处理要比其他的耗内存很多。例如： __DOM 操作__比起非 DOM 交互需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM 操作，可能会导致浏览器挂起，甚至崩溃。\n\n尤其在 IE 中使用 onresize 事件处理 ( 调整浏览器大小的时候，会连续触发 )，并在其内部尝试进行 DOM 操作，其高频的更改可能会让浏览器崩溃。\n\n为了这个问题，可以使用定时器对该函数进行 __节流__。\n\n函数节流的基本思想就是 ，__某些代码__不可以在没有间断的情况 __连续重复__执行。\n\n第一次调用函数，创建一个定时器，在指定的时间间隔后运行代码。\n\n第二次调用函数，__先清除前一次的定时器__，然后设置另一个。\n如果前一次的定时器还没有执行，就相当于将其替换为一个新的定时器。\n\n目的在于 只有在执行函数的请求 __停止了一段时间后__才__开始执行__。\n\n以下是该模式的基本形式：\n\n```\nvar processor = {\n  timeoutId: null,\n\n  performProcessing: function() {\n    console.log(new Date())\n  },\n\n  process: function() {\n    clearTimeout(this.timeoutId);\n\n    this.timeoutId = setTimeout(()=>{\n      console.log('hi');\n      this.performProcessing();\n    }, 100);\n  }\n};\n\nprocessor.process();\n```\n\n在这段代码中，创建了一个 processor 对象。\n\n这个对象有 2 个方法：\n\nprocess( ) --- 初始化任何处理所必须调用的。\n\nperformProcessing( ) --- 实际进行的处理。\n\n调用 process( ) 时, 先 清除存好的 timeoutId, 来阻止之前的调用被执行。\n然后创建一个新的定时器调用 performProcessing( )。\n\n时间间隔是__100__ ，代表 __最后一次__调用 process( ) 之后__至少__ 100ms 后才会调用 performProcessing( ) 。假如 100ms 内调用 process( ) 共 __20__ 次，performanceProcessing( ) 仍只会被调用 1 次。\n\n这个模式可以使用 throttle( ) 函数来简化，这个函数可以自动进行定时器的设置和清除，如下：\n\n```\nfunction throttle( method, context ) {\n  clearTimeout( method.tId );\n  method.tId = setTimeout( () => {\n    method.call( context );\n  }, 100);\n}\n```\n\n如果你使用 resize 事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算。\n\n例如： 假设有 <div>  元素需要保持 高度 和 宽度 相同。\n\n```\nwindow.onresize = function() {\n  let div = document.getElementById(\"myDiv\");\n  div.style.height = div.offsetWidth + \"px\";\n}\n```\n\n上面有 两个问题 可能会导致浏览器运行缓慢。\n\n第一， 要计算 offsetWidth 属性。如果该元素或者页面上其他元素有非常复杂的 CSS 样式，那么这个过程会很复杂。\n\n第二，设置 __某个元素的高度__需要对页面进行 __回流__ 来令改动生效。\n\n这样，就可以使用 throttle( ) 函数。\n\n```\nfunction resizeDiv( ) {\n  let div = document.getElementById(\"myDiv\");\n  div.style.height = div.offsetWidth + \"px\";\n}\n\nwindow.onresize = function() {\n  throttle( resizeDiv );\n}\n```\n\n这样, onresize 事件处理程序调用 throttle() 并传入 resizeDiv 函数，而不是直接调用 resizeDiv()。\n\n只要代码是 __周期性__执行的，都应该使用 __节流__。\n但是不能控制请求执行的速率。\n\n{% blockquote %}\n参考：\n\n_JavaScript 高级程序设计_\n\n[How JavaScript Timers Work](http://ejohn.org/blog/how-javascript-timers-work/)\n\n[js事件线程机制和异步执行](http://www.cnblogs.com/gyx19930120/p/4419875.html)\n\n[知乎: javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?](https://www.zhihu.com/question/35905242?sort=created)\n\n[谈谈 JavaScript 的异步实现](http://www.cnblogs.com/sprying/archive/2013/05/26/3100639.html)\n\n[Javascript线程分析](http://www.coin163.com/it/2870178198278375178/javascript-)\n{% endblockquote %}\n\n\n\n\n","source":"_posts/timers.md","raw":"---\ntitle: JS 定时器\ncategories:\n- 编程\ntags:\n- 抄抄抄\n- JS 基础\n- 定时器\n---\n\n假设没有 Web Works\n\n### 基本知识\n\nJavaScript 的运行是 __单线程__的，而定时器只是 __计划__ 代码在未来某个时间执行。 而执行的时机是__不能__保证的。\n\n因为在页面的使命周期中，不同的时间可能有其他的代码在控制 ( 我的理解是 _占用_ ) JavaScript 进程 。\n\n在页面下载完成后的代码运行，事件处理程序，Ajax __回调函数__都必须在同一个线程中执行。\n\n__实际上，浏览器负责进行排序，指派某段代码在某个时间点上运行的优先级。__\n\n可以把 JS 想象成在时间线 ( __一维__ ) 上运行的。\n当页面载入时, 首先执行的是任何包含在 <script> 元素中的代码, 通常是页面生命周期后面要用到的一些简单的函数和变量的声明, 不过有时候也包含一些初始数据的处理。 在这之后， JS 进程将等待更多代码执行。__当进程空闲的时候，下一个代码会被触发并立刻执行。__ 例如，当点击某个按钮时，当 JS 进程处于空闲状态， onclick 事件处理程序会立刻执行。\n\n除了主 JS 执行进程外，还有一个需要在进程下一次空闲时执行的 __代码队列__。\n例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到 __队列__ 中，并在下一个可能的时间里执行。当接收到某个 __Ajax__ 响应时，__回调函数__ 的代码会被添加到__队列__。\n\n**在 JS 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行** 。\n\n![](http://img.jackon.me/js.svg)\n\n虽然 JS 的引擎是单线程的，但是 JS 的运行环境往往不是单线程的。\n比如，浏览器。浏览器有 Javascript 引擎线程 ( 用于处理 JS )，浏览器事件触发线程 ( 用于控制交互 )，Http 请求线程，GUI 界面渲染线程 ( 用于页面渲染 ) 等。\n\n- JS 引擎是基于事件驱动的，采用的是单线程运行机制。即 JS 引擎只会顺序的从任务列表中取任务执行。\n- 浏览器事件触发线程：当一个事件被触发的时候，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。\n- GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘( Repaint ) 或由于某种操作引发回流 ( Reflow ) 时，该线程就会执行。\nNOTE: GUI 渲染线程与 JS 引擎是 __互斥__的。因为 JS 可以操作 DOM 元素，会影响 GUI 的渲染结果。所以当 __JS  引擎__执行时 __ GUI 线程__就会被 __挂起__， __GUI 更新__会被保存在一个__队列__中等到 JS 引擎空闲时立即被执行。\n\n#### 定时器 setTimeout()\n\n- 定时器的工作方式是，__当特定的时间过去后，将代码插入到队列( 并不意味着立刻执行 )。__\n\n- 关于定时器 __最重要的事情__是, __指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。__\n\n- __由于 JS 进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定( 代码长时间运行中可能出现 )。__\n\n设置一个定时器，确保在定时器代码执行前至少有一个 __进程间隔__\n\n#### 重复的定时器 setInterval()\n\n使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列。\n\n但是，这样定时器代码再次被被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次。\n\n所以，__ 当使用 setInteval() 时，仅当没有该定时器的任何代码实例时，才将定时器代码添加到队列中。__\n\n这样确保了定时器代码加入到队列中的__最小时间间隔__为__指定间隔__。\n\n但是这种重复定时器的规则有两个问题：第 1 个问题，某些间隔会被跳过。第 2 个问题，多个定时器的代码执行之间的间隔会比预期的小。\n\n比如：某个 onclick 事件处理程序使用 setInterval() 设置了一个 200ms 间隔的重复定时器。如果事件处理程序花了 300ms 完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器的代码的情况。\n\n_为了避免 setInterval() 的重复定时器的这 2 个缺点，你可以通过用如下模式使用链式 setTimeout() 调用。_\n\n```\nsetTimeout(()=>{\n  // do somethings\n\n  setTimeout(arguments.callee, interval);\n}, interval);\n```\n\n这个模式链式调用了  setTimeout(), 每次函数执行的时候都会创建一个新的定时器。第二个 setTimeout() 调用使用了 arguments.callee 来获取对当前执行的函数的引用，并为其设置另外一个定时器。\n\n这样做的好处是：\n\n- 在前一个定时器代码执行完成之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。\n\n- 它可以保证在下一次定时器代码执行之前，__至少__要等待指定的间隔，__避免了连续的运行。__\n\n这个模式主要用于重复定时器，如下：\n\n```\nsetTimeout(()=>{\n  let div = document.getElementById('myDiv');\n  left = parseInt(div.style.left) + 5;\n  div.style.left = left + \"px\";\n\n  if( left < 200 ) {\n    setTimeout(arguments.callee, 50);\n  }\n}, 50 );\n```\n这段定时器代码每次执行的时候将一个 <div> 元素向右移动，当左坐标在 200 像素的时候停止。\n\nNOTE：\n每个浏览器窗口，标签页，或者  frame 都有其各自的代码执行队列。这意味着，进行跨  frame 或者 跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。无论何时需要使用这种通信类型，最好是在接收懂  frame 或者 窗口中创建一个定时器来执行代码。\n\n理解这个图就 ok 了！\n![](http://img.jackon.me/Timers.png)\n\n###  Yielding Processes\n\n运行在浏览器中的 JavaScript 都会被分配一个确定数量的资源。并且 浏览器严格限制了 JavaScript 需要的内存大小和处理时间。\n其中一个限制是长时间运行脚本的限制，如果代码运行超过了特定的时间或者特定的语句数量，就会弹出一个浏览器错误的对话框，告诉用户，某个脚本会用过长的时间执行，询问是否允许继续执行。\n所有 JavaScript 开发人员的目标就是确保用户永远不会在浏览器中看到这个对话框。\n\n定时器是绕开此限制的方法之一。\n\n脚本长时间运行的问题通常是由两个原因之一造成的： 过长的，过深嵌套的函数调用，或者是 进行大量处理的循环。\n这两者中，后者是比较容易解决的。\n长时间的循环通畅遵循以下模式：\n\n```\nfor (var i=0, len = data.length; i<len; i++ ){\n  process( data[i] );\n}\n```\n\n这个模式问题在于  __要处理的项目的数量__ 在运行前是 __不可知的__。 数组中的的项目数量之间关系到该数组循环的时间长度。同时由于 JS 的执行是一个 __阻塞操作__，脚本运行花费的时间越久，用户__无法__与页面交互的时间越久。\n\n 在展开该循环前，你需要回答这两个问题：\n\n- 该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。不过，如果你的回答是__否__, 那么可以将某些处理推迟。\n\n- 数据是否必须按顺序完成？如果项目的顺序不是非常 重要，可能可以将某些处理推迟。\n\n当你发现某个循环占用了大量的时间，同时对于上述的两个问题，你的回答都是 __否__, 那么你就可以使用 __定时器分割这个循环__。\n这是一种叫做 __数组分块__ 的技术。小块小块的处理数组。\n基本思路就是为要处理的项目 __创建一个队列__, 然后使用 __定时器__ 取出下一个要处理的项目进行处理，接着在 __设置另一个定时器__。基本模式如下：\n\n```\nsetTimeout( ()=>{\n\n  var item = array.shift();\n  process( item );\n\n  if( array.length > 0 ) {\n    setTimeout(arguments.callee, 100);\n  }\n} , 100);\n```\n\n在这个模式中， array 变量本质上就是一个 “待办事宜” 列表，它包含了要处理的项目。 使用 shift() 方法可以获取队列中的下一个要处理的项目，然后将其传递给某个函数。如果队列中还有项目，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。\n\n要实现数组分块可以使用以下函数：\n\n```\n/**\n * @ array 要处理的项目的数组\n * @ process 处理项目的函数\n * @ context 运行该函数的执行环境\n */\n\nfunction chunk(array, process, context) {\n  setTimeout( ()=>{\n    var item = array.shift();\n    process.call( context, item);\n\n    if( array.length > 0 ) {\n      setTimeout( arguments.callee, 100 );\n    }\n  }, 100);\n}\n```\n定时器的时间间隔设置了 100 ms , 使得在  JS 进程在处理项目的时间 间 转入空闲。\n\n__ NOTE: __\nchunk() 是会 __改变__ 传递进来的数组的。所以你想保持原数组不变，则应该将该数组的副本 传递给 chunk() , 如:\n\n```\nchunk( data.concat(), printValue );\n```\n\n数据分块的__重要性__在于：它可以将多个项目的处理在 __执行队列上分开__，在每个项目处理之后，__给予其他__的浏览器__处理机会__，_这样就可能避免长时间运行脚本的错误_。\n\nNOTE:\n一旦某函数需要花 __50ms__  以上的时间完成，那么最好看看是否能将任务分割。\n\n\n#### 函数节流\n\n浏览器中某些计算和处理要比其他的耗内存很多。例如： __DOM 操作__比起非 DOM 交互需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM 操作，可能会导致浏览器挂起，甚至崩溃。\n\n尤其在 IE 中使用 onresize 事件处理 ( 调整浏览器大小的时候，会连续触发 )，并在其内部尝试进行 DOM 操作，其高频的更改可能会让浏览器崩溃。\n\n为了这个问题，可以使用定时器对该函数进行 __节流__。\n\n函数节流的基本思想就是 ，__某些代码__不可以在没有间断的情况 __连续重复__执行。\n\n第一次调用函数，创建一个定时器，在指定的时间间隔后运行代码。\n\n第二次调用函数，__先清除前一次的定时器__，然后设置另一个。\n如果前一次的定时器还没有执行，就相当于将其替换为一个新的定时器。\n\n目的在于 只有在执行函数的请求 __停止了一段时间后__才__开始执行__。\n\n以下是该模式的基本形式：\n\n```\nvar processor = {\n  timeoutId: null,\n\n  performProcessing: function() {\n    console.log(new Date())\n  },\n\n  process: function() {\n    clearTimeout(this.timeoutId);\n\n    this.timeoutId = setTimeout(()=>{\n      console.log('hi');\n      this.performProcessing();\n    }, 100);\n  }\n};\n\nprocessor.process();\n```\n\n在这段代码中，创建了一个 processor 对象。\n\n这个对象有 2 个方法：\n\nprocess( ) --- 初始化任何处理所必须调用的。\n\nperformProcessing( ) --- 实际进行的处理。\n\n调用 process( ) 时, 先 清除存好的 timeoutId, 来阻止之前的调用被执行。\n然后创建一个新的定时器调用 performProcessing( )。\n\n时间间隔是__100__ ，代表 __最后一次__调用 process( ) 之后__至少__ 100ms 后才会调用 performProcessing( ) 。假如 100ms 内调用 process( ) 共 __20__ 次，performanceProcessing( ) 仍只会被调用 1 次。\n\n这个模式可以使用 throttle( ) 函数来简化，这个函数可以自动进行定时器的设置和清除，如下：\n\n```\nfunction throttle( method, context ) {\n  clearTimeout( method.tId );\n  method.tId = setTimeout( () => {\n    method.call( context );\n  }, 100);\n}\n```\n\n如果你使用 resize 事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算。\n\n例如： 假设有 <div>  元素需要保持 高度 和 宽度 相同。\n\n```\nwindow.onresize = function() {\n  let div = document.getElementById(\"myDiv\");\n  div.style.height = div.offsetWidth + \"px\";\n}\n```\n\n上面有 两个问题 可能会导致浏览器运行缓慢。\n\n第一， 要计算 offsetWidth 属性。如果该元素或者页面上其他元素有非常复杂的 CSS 样式，那么这个过程会很复杂。\n\n第二，设置 __某个元素的高度__需要对页面进行 __回流__ 来令改动生效。\n\n这样，就可以使用 throttle( ) 函数。\n\n```\nfunction resizeDiv( ) {\n  let div = document.getElementById(\"myDiv\");\n  div.style.height = div.offsetWidth + \"px\";\n}\n\nwindow.onresize = function() {\n  throttle( resizeDiv );\n}\n```\n\n这样, onresize 事件处理程序调用 throttle() 并传入 resizeDiv 函数，而不是直接调用 resizeDiv()。\n\n只要代码是 __周期性__执行的，都应该使用 __节流__。\n但是不能控制请求执行的速率。\n\n{% blockquote %}\n参考：\n\n_JavaScript 高级程序设计_\n\n[How JavaScript Timers Work](http://ejohn.org/blog/how-javascript-timers-work/)\n\n[js事件线程机制和异步执行](http://www.cnblogs.com/gyx19930120/p/4419875.html)\n\n[知乎: javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?](https://www.zhihu.com/question/35905242?sort=created)\n\n[谈谈 JavaScript 的异步实现](http://www.cnblogs.com/sprying/archive/2013/05/26/3100639.html)\n\n[Javascript线程分析](http://www.coin163.com/it/2870178198278375178/javascript-)\n{% endblockquote %}\n\n\n\n\n","slug":"timers","published":1,"date":"2016-12-23T10:39:50.000Z","updated":"2016-12-26T16:27:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix6as84u0000vurane2noi8p","content":"<p>假设没有 Web Works</p>\n<h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><p>JavaScript 的运行是 <strong>单线程</strong>的，而定时器只是 <strong>计划</strong> 代码在未来某个时间执行。 而执行的时机是<strong>不能</strong>保证的。</p>\n<p>因为在页面的使命周期中，不同的时间可能有其他的代码在控制 ( 我的理解是 <em>占用</em> ) JavaScript 进程 。</p>\n<p>在页面下载完成后的代码运行，事件处理程序，Ajax <strong>回调函数</strong>都必须在同一个线程中执行。</p>\n<p><strong>实际上，浏览器负责进行排序，指派某段代码在某个时间点上运行的优先级。</strong></p>\n<p>可以把 JS 想象成在时间线 ( <strong>一维</strong> ) 上运行的。<br>当页面载入时, 首先执行的是任何包含在 <script> 元素中的代码, 通常是页面生命周期后面要用到的一些简单的函数和变量的声明, 不过有时候也包含一些初始数据的处理。 在这之后， JS 进程将等待更多代码执行。<strong>当进程空闲的时候，下一个代码会被触发并立刻执行。</strong> 例如，当点击某个按钮时，当 JS 进程处于空闲状态， onclick 事件处理程序会立刻执行。</p>\n<p>除了主 JS 执行进程外，还有一个需要在进程下一次空闲时执行的 <strong>代码队列</strong>。<br>例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到 <strong>队列</strong> 中，并在下一个可能的时间里执行。当接收到某个 <strong>Ajax</strong> 响应时，<strong>回调函数</strong> 的代码会被添加到<strong>队列</strong>。</p>\n<p><strong>在 JS 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行</strong> 。</p>\n<p><img src=\"http://img.jackon.me/js.svg\" alt=\"\"></p>\n<p>虽然 JS 的引擎是单线程的，但是 JS 的运行环境往往不是单线程的。<br>比如，浏览器。浏览器有 Javascript 引擎线程 ( 用于处理 JS )，浏览器事件触发线程 ( 用于控制交互 )，Http 请求线程，GUI 界面渲染线程 ( 用于页面渲染 ) 等。</p>\n<ul>\n<li>JS 引擎是基于事件驱动的，采用的是单线程运行机制。即 JS 引擎只会顺序的从任务列表中取任务执行。</li>\n<li>浏览器事件触发线程：当一个事件被触发的时候，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。</li>\n<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘( Repaint ) 或由于某种操作引发回流 ( Reflow ) 时，该线程就会执行。<br>NOTE: GUI 渲染线程与 JS 引擎是 <strong>互斥</strong>的。因为 JS 可以操作 DOM 元素，会影响 GUI 的渲染结果。所以当 <strong>JS  引擎</strong>执行时 <strong> GUI 线程</strong>就会被 <strong>挂起</strong>， <strong>GUI 更新</strong>会被保存在一个<strong>队列</strong>中等到 JS 引擎空闲时立即被执行。</li>\n</ul>\n<h4 id=\"定时器-setTimeout\"><a href=\"#定时器-setTimeout\" class=\"headerlink\" title=\"定时器 setTimeout()\"></a>定时器 setTimeout()</h4><ul>\n<li><p>定时器的工作方式是，<strong>当特定的时间过去后，将代码插入到队列( 并不意味着立刻执行 )。</strong></p>\n</li>\n<li><p>关于定时器 <strong>最重要的事情</strong>是, <strong>指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</strong></p>\n</li>\n<li><p><strong>由于 JS 进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定( 代码长时间运行中可能出现 )。</strong></p>\n</li>\n</ul>\n<p>设置一个定时器，确保在定时器代码执行前至少有一个 <strong>进程间隔</strong></p>\n<h4 id=\"重复的定时器-setInterval\"><a href=\"#重复的定时器-setInterval\" class=\"headerlink\" title=\"重复的定时器 setInterval()\"></a>重复的定时器 setInterval()</h4><p>使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列。</p>\n<p>但是，这样定时器代码再次被被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次。</p>\n<p>所以，<strong> 当使用 setInteval() 时，仅当没有该定时器的任何代码实例时，才将定时器代码添加到队列中。</strong></p>\n<p>这样确保了定时器代码加入到队列中的<strong>最小时间间隔</strong>为<strong>指定间隔</strong>。</p>\n<p>但是这种重复定时器的规则有两个问题：第 1 个问题，某些间隔会被跳过。第 2 个问题，多个定时器的代码执行之间的间隔会比预期的小。</p>\n<p>比如：某个 onclick 事件处理程序使用 setInterval() 设置了一个 200ms 间隔的重复定时器。如果事件处理程序花了 300ms 完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器的代码的情况。</p>\n<p><em>为了避免 setInterval() 的重复定时器的这 2 个缺点，你可以通过用如下模式使用链式 setTimeout() 调用。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">  // do somethings</div><div class=\"line\"></div><div class=\"line\">  setTimeout(arguments.callee, interval);</div><div class=\"line\">&#125;, interval);</div></pre></td></tr></table></figure>\n<p>这个模式链式调用了  setTimeout(), 每次函数执行的时候都会创建一个新的定时器。第二个 setTimeout() 调用使用了 arguments.callee 来获取对当前执行的函数的引用，并为其设置另外一个定时器。</p>\n<p>这样做的好处是：</p>\n<ul>\n<li><p>在前一个定时器代码执行完成之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。</p>\n</li>\n<li><p>它可以保证在下一次定时器代码执行之前，<strong>至少</strong>要等待指定的间隔，<strong>避免了连续的运行。</strong></p>\n</li>\n</ul>\n<p>这个模式主要用于重复定时器，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">  let div = document.getElementById(&apos;myDiv&apos;);</div><div class=\"line\">  left = parseInt(div.style.left) + 5;</div><div class=\"line\">  div.style.left = left + &quot;px&quot;;</div><div class=\"line\"></div><div class=\"line\">  if( left &lt; 200 ) &#123;</div><div class=\"line\">    setTimeout(arguments.callee, 50);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, 50 );</div></pre></td></tr></table></figure>\n<p>这段定时器代码每次执行的时候将一个 <div> 元素向右移动，当左坐标在 200 像素的时候停止。</p>\n<p>NOTE：<br>每个浏览器窗口，标签页，或者  frame 都有其各自的代码执行队列。这意味着，进行跨  frame 或者 跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。无论何时需要使用这种通信类型，最好是在接收懂  frame 或者 窗口中创建一个定时器来执行代码。</p>\n<p>理解这个图就 ok 了！<br><img src=\"http://img.jackon.me/Timers.png\" alt=\"\"></p>\n<h3 id=\"Yielding-Processes\"><a href=\"#Yielding-Processes\" class=\"headerlink\" title=\"Yielding Processes\"></a>Yielding Processes</h3><p>运行在浏览器中的 JavaScript 都会被分配一个确定数量的资源。并且 浏览器严格限制了 JavaScript 需要的内存大小和处理时间。<br>其中一个限制是长时间运行脚本的限制，如果代码运行超过了特定的时间或者特定的语句数量，就会弹出一个浏览器错误的对话框，告诉用户，某个脚本会用过长的时间执行，询问是否允许继续执行。<br>所有 JavaScript 开发人员的目标就是确保用户永远不会在浏览器中看到这个对话框。</p>\n<p>定时器是绕开此限制的方法之一。</p>\n<p>脚本长时间运行的问题通常是由两个原因之一造成的： 过长的，过深嵌套的函数调用，或者是 进行大量处理的循环。<br>这两者中，后者是比较容易解决的。<br>长时间的循环通畅遵循以下模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=0, len = data.length; i&lt;len; i++ )&#123;</div><div class=\"line\">  process( data[i] );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个模式问题在于  <strong>要处理的项目的数量</strong> 在运行前是 <strong>不可知的</strong>。 数组中的的项目数量之间关系到该数组循环的时间长度。同时由于 JS 的执行是一个 <strong>阻塞操作</strong>，脚本运行花费的时间越久，用户<strong>无法</strong>与页面交互的时间越久。</p>\n<p> 在展开该循环前，你需要回答这两个问题：</p>\n<ul>\n<li><p>该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。不过，如果你的回答是<strong>否</strong>, 那么可以将某些处理推迟。</p>\n</li>\n<li><p>数据是否必须按顺序完成？如果项目的顺序不是非常 重要，可能可以将某些处理推迟。</p>\n</li>\n</ul>\n<p>当你发现某个循环占用了大量的时间，同时对于上述的两个问题，你的回答都是 <strong>否</strong>, 那么你就可以使用 <strong>定时器分割这个循环</strong>。<br>这是一种叫做 <strong>数组分块</strong> 的技术。小块小块的处理数组。<br>基本思路就是为要处理的项目 <strong>创建一个队列</strong>, 然后使用 <strong>定时器</strong> 取出下一个要处理的项目进行处理，接着在 <strong>设置另一个定时器</strong>。基本模式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout( ()=&gt;&#123;</div><div class=\"line\"></div><div class=\"line\">  var item = array.shift();</div><div class=\"line\">  process( item );</div><div class=\"line\"></div><div class=\"line\">  if( array.length &gt; 0 ) &#123;</div><div class=\"line\">    setTimeout(arguments.callee, 100);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; , 100);</div></pre></td></tr></table></figure>\n<p>在这个模式中， array 变量本质上就是一个 “待办事宜” 列表，它包含了要处理的项目。 使用 shift() 方法可以获取队列中的下一个要处理的项目，然后将其传递给某个函数。如果队列中还有项目，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。</p>\n<p>要实现数组分块可以使用以下函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @ array 要处理的项目的数组</div><div class=\"line\"> * @ process 处理项目的函数</div><div class=\"line\"> * @ context 运行该函数的执行环境</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">function chunk(array, process, context) &#123;</div><div class=\"line\">  setTimeout( ()=&gt;&#123;</div><div class=\"line\">    var item = array.shift();</div><div class=\"line\">    process.call( context, item);</div><div class=\"line\"></div><div class=\"line\">    if( array.length &gt; 0 ) &#123;</div><div class=\"line\">      setTimeout( arguments.callee, 100 );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, 100);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定时器的时间间隔设置了 100 ms , 使得在  JS 进程在处理项目的时间 间 转入空闲。</p>\n<p><strong> NOTE: </strong><br>chunk() 是会 <strong>改变</strong> 传递进来的数组的。所以你想保持原数组不变，则应该将该数组的副本 传递给 chunk() , 如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chunk( data.concat(), printValue );</div></pre></td></tr></table></figure>\n<p>数据分块的<strong>重要性</strong>在于：它可以将多个项目的处理在 <strong>执行队列上分开</strong>，在每个项目处理之后，<strong>给予其他</strong>的浏览器<strong>处理机会</strong>，<em>这样就可能避免长时间运行脚本的错误</em>。</p>\n<p>NOTE:<br>一旦某函数需要花 <strong>50ms</strong>  以上的时间完成，那么最好看看是否能将任务分割。</p>\n<h4 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><p>浏览器中某些计算和处理要比其他的耗内存很多。例如： <strong>DOM 操作</strong>比起非 DOM 交互需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM 操作，可能会导致浏览器挂起，甚至崩溃。</p>\n<p>尤其在 IE 中使用 onresize 事件处理 ( 调整浏览器大小的时候，会连续触发 )，并在其内部尝试进行 DOM 操作，其高频的更改可能会让浏览器崩溃。</p>\n<p>为了这个问题，可以使用定时器对该函数进行 <strong>节流</strong>。</p>\n<p>函数节流的基本思想就是 ，<strong>某些代码</strong>不可以在没有间断的情况 <strong>连续重复</strong>执行。</p>\n<p>第一次调用函数，创建一个定时器，在指定的时间间隔后运行代码。</p>\n<p>第二次调用函数，<strong>先清除前一次的定时器</strong>，然后设置另一个。<br>如果前一次的定时器还没有执行，就相当于将其替换为一个新的定时器。</p>\n<p>目的在于 只有在执行函数的请求 <strong>停止了一段时间后</strong>才<strong>开始执行</strong>。</p>\n<p>以下是该模式的基本形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var processor = &#123;</div><div class=\"line\">  timeoutId: null,</div><div class=\"line\"></div><div class=\"line\">  performProcessing: function() &#123;</div><div class=\"line\">    console.log(new Date())</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  process: function() &#123;</div><div class=\"line\">    clearTimeout(this.timeoutId);</div><div class=\"line\"></div><div class=\"line\">    this.timeoutId = setTimeout(()=&gt;&#123;</div><div class=\"line\">      console.log(&apos;hi&apos;);</div><div class=\"line\">      this.performProcessing();</div><div class=\"line\">    &#125;, 100);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">processor.process();</div></pre></td></tr></table></figure>\n<p>在这段代码中，创建了一个 processor 对象。</p>\n<p>这个对象有 2 个方法：</p>\n<p>process( ) — 初始化任何处理所必须调用的。</p>\n<p>performProcessing( ) — 实际进行的处理。</p>\n<p>调用 process( ) 时, 先 清除存好的 timeoutId, 来阻止之前的调用被执行。<br>然后创建一个新的定时器调用 performProcessing( )。</p>\n<p>时间间隔是<strong>100</strong> ，代表 <strong>最后一次</strong>调用 process( ) 之后<strong>至少</strong> 100ms 后才会调用 performProcessing( ) 。假如 100ms 内调用 process( ) 共 <strong>20</strong> 次，performanceProcessing( ) 仍只会被调用 1 次。</p>\n<p>这个模式可以使用 throttle( ) 函数来简化，这个函数可以自动进行定时器的设置和清除，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle( method, context ) &#123;</div><div class=\"line\">  clearTimeout( method.tId );</div><div class=\"line\">  method.tId = setTimeout( () =&gt; &#123;</div><div class=\"line\">    method.call( context );</div><div class=\"line\">  &#125;, 100);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你使用 resize 事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算。</p>\n<p>例如： 假设有 <div>  元素需要保持 高度 和 宽度 相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.onresize = function() &#123;</div><div class=\"line\">  let div = document.getElementById(&quot;myDiv&quot;);</div><div class=\"line\">  div.style.height = div.offsetWidth + &quot;px&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面有 两个问题 可能会导致浏览器运行缓慢。</p>\n<p>第一， 要计算 offsetWidth 属性。如果该元素或者页面上其他元素有非常复杂的 CSS 样式，那么这个过程会很复杂。</p>\n<p>第二，设置 <strong>某个元素的高度</strong>需要对页面进行 <strong>回流</strong> 来令改动生效。</p>\n<p>这样，就可以使用 throttle( ) 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function resizeDiv( ) &#123;</div><div class=\"line\">  let div = document.getElementById(&quot;myDiv&quot;);</div><div class=\"line\">  div.style.height = div.offsetWidth + &quot;px&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">window.onresize = function() &#123;</div><div class=\"line\">  throttle( resizeDiv );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样, onresize 事件处理程序调用 throttle() 并传入 resizeDiv 函数，而不是直接调用 resizeDiv()。</p>\n<p>只要代码是 <strong>周期性</strong>执行的，都应该使用 <strong>节流</strong>。<br>但是不能控制请求执行的速率。</p>\n<blockquote><p>参考：</p>\n<p><em>JavaScript 高级程序设计</em></p>\n<p><a href=\"http://ejohn.org/blog/how-javascript-timers-work/\">How JavaScript Timers Work</a></p>\n<p><a href=\"http://www.cnblogs.com/gyx19930120/p/4419875.html\">js事件线程机制和异步执行</a></p>\n<p><a href=\"https://www.zhihu.com/question/35905242?sort=created\">知乎: javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?</a></p>\n<p><a href=\"http://www.cnblogs.com/sprying/archive/2013/05/26/3100639.html\">谈谈 JavaScript 的异步实现</a></p>\n<p><a href=\"http://www.coin163.com/it/2870178198278375178/javascript-\">Javascript线程分析</a></p>\n</blockquote>\n</script></p>","excerpt":"","more":"<p>假设没有 Web Works</p>\n<h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><p>JavaScript 的运行是 <strong>单线程</strong>的，而定时器只是 <strong>计划</strong> 代码在未来某个时间执行。 而执行的时机是<strong>不能</strong>保证的。</p>\n<p>因为在页面的使命周期中，不同的时间可能有其他的代码在控制 ( 我的理解是 <em>占用</em> ) JavaScript 进程 。</p>\n<p>在页面下载完成后的代码运行，事件处理程序，Ajax <strong>回调函数</strong>都必须在同一个线程中执行。</p>\n<p><strong>实际上，浏览器负责进行排序，指派某段代码在某个时间点上运行的优先级。</strong></p>\n<p>可以把 JS 想象成在时间线 ( <strong>一维</strong> ) 上运行的。<br>当页面载入时, 首先执行的是任何包含在 <script> 元素中的代码, 通常是页面生命周期后面要用到的一些简单的函数和变量的声明, 不过有时候也包含一些初始数据的处理。 在这之后， JS 进程将等待更多代码执行。<strong>当进程空闲的时候，下一个代码会被触发并立刻执行。</strong> 例如，当点击某个按钮时，当 JS 进程处于空闲状态， onclick 事件处理程序会立刻执行。</p>\n<p>除了主 JS 执行进程外，还有一个需要在进程下一次空闲时执行的 <strong>代码队列</strong>。<br>例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到 <strong>队列</strong> 中，并在下一个可能的时间里执行。当接收到某个 <strong>Ajax</strong> 响应时，<strong>回调函数</strong> 的代码会被添加到<strong>队列</strong>。</p>\n<p><strong>在 JS 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行</strong> 。</p>\n<p><img src=\"http://img.jackon.me/js.svg\" alt=\"\"></p>\n<p>虽然 JS 的引擎是单线程的，但是 JS 的运行环境往往不是单线程的。<br>比如，浏览器。浏览器有 Javascript 引擎线程 ( 用于处理 JS )，浏览器事件触发线程 ( 用于控制交互 )，Http 请求线程，GUI 界面渲染线程 ( 用于页面渲染 ) 等。</p>\n<ul>\n<li>JS 引擎是基于事件驱动的，采用的是单线程运行机制。即 JS 引擎只会顺序的从任务列表中取任务执行。</li>\n<li>浏览器事件触发线程：当一个事件被触发的时候，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理。</li>\n<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘( Repaint ) 或由于某种操作引发回流 ( Reflow ) 时，该线程就会执行。<br>NOTE: GUI 渲染线程与 JS 引擎是 <strong>互斥</strong>的。因为 JS 可以操作 DOM 元素，会影响 GUI 的渲染结果。所以当 <strong>JS  引擎</strong>执行时 <strong> GUI 线程</strong>就会被 <strong>挂起</strong>， <strong>GUI 更新</strong>会被保存在一个<strong>队列</strong>中等到 JS 引擎空闲时立即被执行。</li>\n</ul>\n<h4 id=\"定时器-setTimeout\"><a href=\"#定时器-setTimeout\" class=\"headerlink\" title=\"定时器 setTimeout()\"></a>定时器 setTimeout()</h4><ul>\n<li><p>定时器的工作方式是，<strong>当特定的时间过去后，将代码插入到队列( 并不意味着立刻执行 )。</strong></p>\n</li>\n<li><p>关于定时器 <strong>最重要的事情</strong>是, <strong>指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</strong></p>\n</li>\n<li><p><strong>由于 JS 进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定( 代码长时间运行中可能出现 )。</strong></p>\n</li>\n</ul>\n<p>设置一个定时器，确保在定时器代码执行前至少有一个 <strong>进程间隔</strong></p>\n<h4 id=\"重复的定时器-setInterval\"><a href=\"#重复的定时器-setInterval\" class=\"headerlink\" title=\"重复的定时器 setInterval()\"></a>重复的定时器 setInterval()</h4><p>使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列。</p>\n<p>但是，这样定时器代码再次被被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次。</p>\n<p>所以，<strong> 当使用 setInteval() 时，仅当没有该定时器的任何代码实例时，才将定时器代码添加到队列中。</strong></p>\n<p>这样确保了定时器代码加入到队列中的<strong>最小时间间隔</strong>为<strong>指定间隔</strong>。</p>\n<p>但是这种重复定时器的规则有两个问题：第 1 个问题，某些间隔会被跳过。第 2 个问题，多个定时器的代码执行之间的间隔会比预期的小。</p>\n<p>比如：某个 onclick 事件处理程序使用 setInterval() 设置了一个 200ms 间隔的重复定时器。如果事件处理程序花了 300ms 完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器的代码的情况。</p>\n<p><em>为了避免 setInterval() 的重复定时器的这 2 个缺点，你可以通过用如下模式使用链式 setTimeout() 调用。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">  // do somethings</div><div class=\"line\"></div><div class=\"line\">  setTimeout(arguments.callee, interval);</div><div class=\"line\">&#125;, interval);</div></pre></td></tr></table></figure>\n<p>这个模式链式调用了  setTimeout(), 每次函数执行的时候都会创建一个新的定时器。第二个 setTimeout() 调用使用了 arguments.callee 来获取对当前执行的函数的引用，并为其设置另外一个定时器。</p>\n<p>这样做的好处是：</p>\n<ul>\n<li><p>在前一个定时器代码执行完成之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。</p>\n</li>\n<li><p>它可以保证在下一次定时器代码执行之前，<strong>至少</strong>要等待指定的间隔，<strong>避免了连续的运行。</strong></p>\n</li>\n</ul>\n<p>这个模式主要用于重复定时器，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">  let div = document.getElementById(&apos;myDiv&apos;);</div><div class=\"line\">  left = parseInt(div.style.left) + 5;</div><div class=\"line\">  div.style.left = left + &quot;px&quot;;</div><div class=\"line\"></div><div class=\"line\">  if( left &lt; 200 ) &#123;</div><div class=\"line\">    setTimeout(arguments.callee, 50);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, 50 );</div></pre></td></tr></table></figure>\n<p>这段定时器代码每次执行的时候将一个 <div> 元素向右移动，当左坐标在 200 像素的时候停止。</p>\n<p>NOTE：<br>每个浏览器窗口，标签页，或者  frame 都有其各自的代码执行队列。这意味着，进行跨  frame 或者 跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。无论何时需要使用这种通信类型，最好是在接收懂  frame 或者 窗口中创建一个定时器来执行代码。</p>\n<p>理解这个图就 ok 了！<br><img src=\"http://img.jackon.me/Timers.png\" alt=\"\"></p>\n<h3 id=\"Yielding-Processes\"><a href=\"#Yielding-Processes\" class=\"headerlink\" title=\"Yielding Processes\"></a>Yielding Processes</h3><p>运行在浏览器中的 JavaScript 都会被分配一个确定数量的资源。并且 浏览器严格限制了 JavaScript 需要的内存大小和处理时间。<br>其中一个限制是长时间运行脚本的限制，如果代码运行超过了特定的时间或者特定的语句数量，就会弹出一个浏览器错误的对话框，告诉用户，某个脚本会用过长的时间执行，询问是否允许继续执行。<br>所有 JavaScript 开发人员的目标就是确保用户永远不会在浏览器中看到这个对话框。</p>\n<p>定时器是绕开此限制的方法之一。</p>\n<p>脚本长时间运行的问题通常是由两个原因之一造成的： 过长的，过深嵌套的函数调用，或者是 进行大量处理的循环。<br>这两者中，后者是比较容易解决的。<br>长时间的循环通畅遵循以下模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var i=0, len = data.length; i&lt;len; i++ )&#123;</div><div class=\"line\">  process( data[i] );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个模式问题在于  <strong>要处理的项目的数量</strong> 在运行前是 <strong>不可知的</strong>。 数组中的的项目数量之间关系到该数组循环的时间长度。同时由于 JS 的执行是一个 <strong>阻塞操作</strong>，脚本运行花费的时间越久，用户<strong>无法</strong>与页面交互的时间越久。</p>\n<p> 在展开该循环前，你需要回答这两个问题：</p>\n<ul>\n<li><p>该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。不过，如果你的回答是<strong>否</strong>, 那么可以将某些处理推迟。</p>\n</li>\n<li><p>数据是否必须按顺序完成？如果项目的顺序不是非常 重要，可能可以将某些处理推迟。</p>\n</li>\n</ul>\n<p>当你发现某个循环占用了大量的时间，同时对于上述的两个问题，你的回答都是 <strong>否</strong>, 那么你就可以使用 <strong>定时器分割这个循环</strong>。<br>这是一种叫做 <strong>数组分块</strong> 的技术。小块小块的处理数组。<br>基本思路就是为要处理的项目 <strong>创建一个队列</strong>, 然后使用 <strong>定时器</strong> 取出下一个要处理的项目进行处理，接着在 <strong>设置另一个定时器</strong>。基本模式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout( ()=&gt;&#123;</div><div class=\"line\"></div><div class=\"line\">  var item = array.shift();</div><div class=\"line\">  process( item );</div><div class=\"line\"></div><div class=\"line\">  if( array.length &gt; 0 ) &#123;</div><div class=\"line\">    setTimeout(arguments.callee, 100);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; , 100);</div></pre></td></tr></table></figure>\n<p>在这个模式中， array 变量本质上就是一个 “待办事宜” 列表，它包含了要处理的项目。 使用 shift() 方法可以获取队列中的下一个要处理的项目，然后将其传递给某个函数。如果队列中还有项目，则设置另一个定时器，并通过 arguments.callee 调用同一个匿名函数。</p>\n<p>要实现数组分块可以使用以下函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @ array 要处理的项目的数组</div><div class=\"line\"> * @ process 处理项目的函数</div><div class=\"line\"> * @ context 运行该函数的执行环境</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">function chunk(array, process, context) &#123;</div><div class=\"line\">  setTimeout( ()=&gt;&#123;</div><div class=\"line\">    var item = array.shift();</div><div class=\"line\">    process.call( context, item);</div><div class=\"line\"></div><div class=\"line\">    if( array.length &gt; 0 ) &#123;</div><div class=\"line\">      setTimeout( arguments.callee, 100 );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;, 100);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定时器的时间间隔设置了 100 ms , 使得在  JS 进程在处理项目的时间 间 转入空闲。</p>\n<p><strong> NOTE: </strong><br>chunk() 是会 <strong>改变</strong> 传递进来的数组的。所以你想保持原数组不变，则应该将该数组的副本 传递给 chunk() , 如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chunk( data.concat(), printValue );</div></pre></td></tr></table></figure>\n<p>数据分块的<strong>重要性</strong>在于：它可以将多个项目的处理在 <strong>执行队列上分开</strong>，在每个项目处理之后，<strong>给予其他</strong>的浏览器<strong>处理机会</strong>，<em>这样就可能避免长时间运行脚本的错误</em>。</p>\n<p>NOTE:<br>一旦某函数需要花 <strong>50ms</strong>  以上的时间完成，那么最好看看是否能将任务分割。</p>\n<h4 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><p>浏览器中某些计算和处理要比其他的耗内存很多。例如： <strong>DOM 操作</strong>比起非 DOM 交互需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM 操作，可能会导致浏览器挂起，甚至崩溃。</p>\n<p>尤其在 IE 中使用 onresize 事件处理 ( 调整浏览器大小的时候，会连续触发 )，并在其内部尝试进行 DOM 操作，其高频的更改可能会让浏览器崩溃。</p>\n<p>为了这个问题，可以使用定时器对该函数进行 <strong>节流</strong>。</p>\n<p>函数节流的基本思想就是 ，<strong>某些代码</strong>不可以在没有间断的情况 <strong>连续重复</strong>执行。</p>\n<p>第一次调用函数，创建一个定时器，在指定的时间间隔后运行代码。</p>\n<p>第二次调用函数，<strong>先清除前一次的定时器</strong>，然后设置另一个。<br>如果前一次的定时器还没有执行，就相当于将其替换为一个新的定时器。</p>\n<p>目的在于 只有在执行函数的请求 <strong>停止了一段时间后</strong>才<strong>开始执行</strong>。</p>\n<p>以下是该模式的基本形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var processor = &#123;</div><div class=\"line\">  timeoutId: null,</div><div class=\"line\"></div><div class=\"line\">  performProcessing: function() &#123;</div><div class=\"line\">    console.log(new Date())</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  process: function() &#123;</div><div class=\"line\">    clearTimeout(this.timeoutId);</div><div class=\"line\"></div><div class=\"line\">    this.timeoutId = setTimeout(()=&gt;&#123;</div><div class=\"line\">      console.log(&apos;hi&apos;);</div><div class=\"line\">      this.performProcessing();</div><div class=\"line\">    &#125;, 100);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">processor.process();</div></pre></td></tr></table></figure>\n<p>在这段代码中，创建了一个 processor 对象。</p>\n<p>这个对象有 2 个方法：</p>\n<p>process( ) — 初始化任何处理所必须调用的。</p>\n<p>performProcessing( ) — 实际进行的处理。</p>\n<p>调用 process( ) 时, 先 清除存好的 timeoutId, 来阻止之前的调用被执行。<br>然后创建一个新的定时器调用 performProcessing( )。</p>\n<p>时间间隔是<strong>100</strong> ，代表 <strong>最后一次</strong>调用 process( ) 之后<strong>至少</strong> 100ms 后才会调用 performProcessing( ) 。假如 100ms 内调用 process( ) 共 <strong>20</strong> 次，performanceProcessing( ) 仍只会被调用 1 次。</p>\n<p>这个模式可以使用 throttle( ) 函数来简化，这个函数可以自动进行定时器的设置和清除，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function throttle( method, context ) &#123;</div><div class=\"line\">  clearTimeout( method.tId );</div><div class=\"line\">  method.tId = setTimeout( () =&gt; &#123;</div><div class=\"line\">    method.call( context );</div><div class=\"line\">  &#125;, 100);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你使用 resize 事件来改变页面布局的话，最好控制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算。</p>\n<p>例如： 假设有 <div>  元素需要保持 高度 和 宽度 相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.onresize = function() &#123;</div><div class=\"line\">  let div = document.getElementById(&quot;myDiv&quot;);</div><div class=\"line\">  div.style.height = div.offsetWidth + &quot;px&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面有 两个问题 可能会导致浏览器运行缓慢。</p>\n<p>第一， 要计算 offsetWidth 属性。如果该元素或者页面上其他元素有非常复杂的 CSS 样式，那么这个过程会很复杂。</p>\n<p>第二，设置 <strong>某个元素的高度</strong>需要对页面进行 <strong>回流</strong> 来令改动生效。</p>\n<p>这样，就可以使用 throttle( ) 函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function resizeDiv( ) &#123;</div><div class=\"line\">  let div = document.getElementById(&quot;myDiv&quot;);</div><div class=\"line\">  div.style.height = div.offsetWidth + &quot;px&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">window.onresize = function() &#123;</div><div class=\"line\">  throttle( resizeDiv );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样, onresize 事件处理程序调用 throttle() 并传入 resizeDiv 函数，而不是直接调用 resizeDiv()。</p>\n<p>只要代码是 <strong>周期性</strong>执行的，都应该使用 <strong>节流</strong>。<br>但是不能控制请求执行的速率。</p>\n<blockquote><p>参考：</p>\n<p><em>JavaScript 高级程序设计</em></p>\n<p><a href=\"http://ejohn.org/blog/how-javascript-timers-work/\">How JavaScript Timers Work</a></p>\n<p><a href=\"http://www.cnblogs.com/gyx19930120/p/4419875.html\">js事件线程机制和异步执行</a></p>\n<p><a href=\"https://www.zhihu.com/question/35905242?sort=created\">知乎: javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?</a></p>\n<p><a href=\"http://www.cnblogs.com/sprying/archive/2013/05/26/3100639.html\">谈谈 JavaScript 的异步实现</a></p>\n<p><a href=\"http://www.coin163.com/it/2870178198278375178/javascript-\">Javascript线程分析</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciwfxj93w00098mrav765ea0k","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94d000g8mra9iwzppha"},{"post_id":"ciwfxj93a00018mrarxin9yzu","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94i000k8mrabx7xpjs4"},{"post_id":"ciwfxj944000b8mraewjwm2tj","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94l000m8mraldhjypc9"},{"post_id":"ciwfxj94b000f8mrazqqvhman","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94o000q8mra9241q086"},{"post_id":"ciwfxj93h00038mrat1t8ucin","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94t000t8mra23927w0b"},{"post_id":"ciwfxj94j000l8mra2ubrp6s8","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94v000v8mra1boez630"},{"post_id":"ciwfxj93o00078mra5nn0ff90","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94x000y8mram6w9i374"},{"post_id":"ciwfxj94l000n8mrad8gzvij4","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94x000z8mralstbbtdx"},{"post_id":"ciwfxj94q000r8mrax80a7hrf","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwfxj94y00118mradiqy3tac"},{"post_id":"ciwfxj94e000h8mraap62291t","category_id":"ciwfxj94m000o8mra20fk29vr","_id":"ciwfxj95000128mraxom56vuh"},{"post_id":"ciwkdsbcm0007k2ra2bdm3z67","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwkdsbdc0009k2ra4ugmdsn5"},{"post_id":"ciwlk309e0000fprav9dybs9x","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwlk309v0003fpra4xz2gdt2"},{"post_id":"ciwlk309n0001fpragy4bd5q9","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwlk309v0004fpra5f3r00yq"},{"post_id":"ciwpvzd5b0003lcra58yxgdlx","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwpvzd5n0006lcrax39o280n"},{"post_id":"ciwpvzd6j000flcraarihfe2l","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwpvzd6p000hlcra60z1jxw7"},{"post_id":"ciwpwkc9e0000p4ra4techqkj","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwpwkc9n0002p4ra7xrse33f"},{"post_id":"ciwqo03qo0000lvralr0q162t","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwqo03rm0004lvra35b6xcwo"},{"post_id":"ciwqo03qy0001lvrakque9u4r","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwqo03rp0005lvra1funpshy"},{"post_id":"ciwu3unnk00007qrauogb2v6r","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwum62mj0001yirax8r1t433"},{"post_id":"ciwuq4a3d0005yira7xqvvwek","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwuwsl8s0008yirartv35gxd"},{"post_id":"ciwvin0nj000ayiraff3i7vml","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwvin0nu000cyiras9x6xkyw"},{"post_id":"ciwuvvoef0006yira2jazxsy0","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"ciwvivgoh000gyiraevlegsxs"},{"post_id":"ciwviz9kr000myirak7j3suzs","category_id":"ciwfxj94m000o8mra20fk29vr","_id":"ciwvjf5qp000oyirarg0zjon5"},{"post_id":"cix6as84u0000vurane2noi8p","category_id":"ciwfxj93l00058mra6ie3vkd3","_id":"cix6as85j0002vuralflcror2"}],"PostTag":[{"post_id":"ciwfxj93a00018mrarxin9yzu","tag_id":"ciwfxj93n00068mraqx6rwvo4","_id":"ciwfxj94a000e8mrae4kvbwmn"},{"post_id":"ciwfxj93h00038mrat1t8ucin","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwfxj94t000s8mrat9or7xel"},{"post_id":"ciwfxj93h00038mrat1t8ucin","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwfxj94u000u8mra3zcfdpsg"},{"post_id":"ciwfxj93o00078mra5nn0ff90","tag_id":"ciwfxj94o000p8mramf85b5i5","_id":"ciwfxj94w000x8mraquc06ft4"},{"post_id":"ciwfxj93w00098mrav765ea0k","tag_id":"ciwfxj93n00068mraqx6rwvo4","_id":"ciwfxj95100148mrap9gevayt"},{"post_id":"ciwfxj93w00098mrav765ea0k","tag_id":"ciwfxj94v000w8mra803jlqel","_id":"ciwfxj95100158mrax4snvk4q"},{"post_id":"ciwfxj93w00098mrav765ea0k","tag_id":"ciwfxj94y00108mraz477h1j3","_id":"ciwfxj95200178mrap5gnyqwm"},{"post_id":"ciwfxj944000b8mraewjwm2tj","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwfxj95400198mrat5zagnjv"},{"post_id":"ciwfxj944000b8mraewjwm2tj","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwfxj955001a8mrakdyozfch"},{"post_id":"ciwfxj94b000f8mrazqqvhman","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwfxj956001c8mrap0ug22bt"},{"post_id":"ciwfxj94b000f8mrazqqvhman","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwfxj956001d8mrafxsolv4y"},{"post_id":"ciwfxj94e000h8mraap62291t","tag_id":"ciwfxj955001b8mra6yc5k81v","_id":"ciwfxj957001f8mra232y4q2h"},{"post_id":"ciwfxj94j000l8mra2ubrp6s8","tag_id":"ciwfxj957001e8mralzbjbf5v","_id":"ciwfxj958001h8mratfq0tyms"},{"post_id":"ciwfxj94j000l8mra2ubrp6s8","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwfxj959001i8mrapyl4f5wd"},{"post_id":"ciwfxj94l000n8mrad8gzvij4","tag_id":"ciwfxj957001e8mralzbjbf5v","_id":"ciwfxj959001k8mraw1a3ah4f"},{"post_id":"ciwfxj94l000n8mrad8gzvij4","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwfxj959001l8mragpmcorsd"},{"post_id":"ciwfxj94q000r8mrax80a7hrf","tag_id":"ciwfxj93n00068mraqx6rwvo4","_id":"ciwfxj95b001m8mra2j0u3945"},{"post_id":"ciwfxj94q000r8mrax80a7hrf","tag_id":"ciwfxj959001j8mra4jbfi629","_id":"ciwfxj95b001n8mrawzh5t7uo"},{"post_id":"ciwkdsbcm0007k2ra2bdm3z67","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwkdsbd60008k2raax89iv3c"},{"post_id":"ciwkdsbcm0007k2ra2bdm3z67","tag_id":"ciwkd216d0001k2rawylirpa7","_id":"ciwkdsbdd000ak2raqc2izpqi"},{"post_id":"ciwkdsbcm0007k2ra2bdm3z67","tag_id":"ciwkd216i0003k2ra5p5ldhx3","_id":"ciwkdsbde000bk2raypbgxgez"},{"post_id":"ciwlk309e0000fprav9dybs9x","tag_id":"ciwlk309q0002fpra0511zxrb","_id":"ciwlk309x0006fprautjnju3y"},{"post_id":"ciwlk309e0000fprav9dybs9x","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwlk309x0007fprade1hnezi"},{"post_id":"ciwlk309n0001fpragy4bd5q9","tag_id":"ciwlk309w0005fpra5ekqwl7g","_id":"ciwlk309y0008fprac76oqlx9"},{"post_id":"ciwlk309n0001fpragy4bd5q9","tag_id":"ciwfxj94o000p8mramf85b5i5","_id":"ciwlk309y0009fpray24zr4h9"},{"post_id":"ciwpvzd5b0003lcra58yxgdlx","tag_id":"ciwfxj93n00068mraqx6rwvo4","_id":"ciwpvzd5u000clcratm80tilc"},{"post_id":"ciwpvzd5b0003lcra58yxgdlx","tag_id":"ciwpvzd5o0007lcra3n08o5lj","_id":"ciwpvzd5u000dlcrawyl4ms30"},{"post_id":"ciwpvzd5b0003lcra58yxgdlx","tag_id":"ciwpvzd5q000alcra9zmkc45v","_id":"ciwpvzd5v000elcras52e94ae"},{"post_id":"ciwpvzd6j000flcraarihfe2l","tag_id":"ciwfxj93n00068mraqx6rwvo4","_id":"ciwpvzd6p000glcran0gt4tge"},{"post_id":"ciwpvzd6j000flcraarihfe2l","tag_id":"ciwpvzd5o0007lcra3n08o5lj","_id":"ciwpvzd6p000ilcraylq4d82k"},{"post_id":"ciwpvzd6j000flcraarihfe2l","tag_id":"ciwpvzd5q000alcra9zmkc45v","_id":"ciwpvzd6p000jlcra5c49lve8"},{"post_id":"ciwpwkc9e0000p4ra4techqkj","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwpwkc9o0003p4ral09lfhoa"},{"post_id":"ciwpwkc9e0000p4ra4techqkj","tag_id":"ciwpwkc9l0001p4rag3cfmkn9","_id":"ciwpwkc9p0004p4rafwziyfoc"},{"post_id":"ciwpwkc9e0000p4ra4techqkj","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwpwkc9q0005p4rar41loyse"},{"post_id":"ciwqo03qo0000lvralr0q162t","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwqo03rr0007lvraqn54p1jo"},{"post_id":"ciwqo03qo0000lvralr0q162t","tag_id":"ciwqo03r10002lvrafmhtqz7u","_id":"ciwqo03rr0008lvramp93xjnw"},{"post_id":"ciwqo03qy0001lvrakque9u4r","tag_id":"ciwqo03rq0006lvraid4g18xj","_id":"ciwqo03ru000alvrafkibr5yi"},{"post_id":"ciwqo03qy0001lvrakque9u4r","tag_id":"ciwqo03r10002lvrafmhtqz7u","_id":"ciwqo03ru000blvranvxd3qg9"},{"post_id":"ciwqo03qy0001lvrakque9u4r","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwqo03ru000clvrav8g2uvql"},{"post_id":"ciwu3unnk00007qrauogb2v6r","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwum62mk0002yiraokqoiq6n"},{"post_id":"ciwu3unnk00007qrauogb2v6r","tag_id":"ciwum62mb0000yira4ki7birs","_id":"ciwum62mk0003yiraqcbal2s3"},{"post_id":"ciwu3unnk00007qrauogb2v6r","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwum62mk0004yira12acipr4"},{"post_id":"ciwuq4a3d0005yira7xqvvwek","tag_id":"ciwfxj94o000p8mramf85b5i5","_id":"ciwuwsl8o0007yira1yy1k0q8"},{"post_id":"ciwuq4a3d0005yira7xqvvwek","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwuwsl8t0009yira7zvqy9rd"},{"post_id":"ciwvin0nj000ayiraff3i7vml","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwvin0nt000byiraj4vpse08"},{"post_id":"ciwvin0nj000ayiraff3i7vml","tag_id":"ciwkd216d0001k2rawylirpa7","_id":"ciwvin0nu000dyira5lqg7snk"},{"post_id":"ciwvin0nj000ayiraff3i7vml","tag_id":"ciwpvzd5e0004lcra19ek9ro2","_id":"ciwvin0nu000eyirab2fngmy7"},{"post_id":"ciwuvvoef0006yira2jazxsy0","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"ciwvivgoi000iyirala78izwr"},{"post_id":"ciwuvvoef0006yira2jazxsy0","tag_id":"ciwvivgog000fyirafb6n2240","_id":"ciwvivgoj000jyiraeya53nnz"},{"post_id":"ciwuvvoef0006yira2jazxsy0","tag_id":"ciwvivgoi000hyirasgz9sjim","_id":"ciwvivgoj000kyirawdliygkn"},{"post_id":"ciwuvvoef0006yira2jazxsy0","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"ciwvivgoj000lyirahkhmcl4p"},{"post_id":"ciwviz9kr000myirak7j3suzs","tag_id":"ciwfxj94o000p8mramf85b5i5","_id":"ciwvjf5qq000pyirabcaekmbm"},{"post_id":"ciwviz9kr000myirak7j3suzs","tag_id":"ciwvjf5ql000nyiranh4vxyhx","_id":"ciwvjf5qq000qyira5b4zkczq"},{"post_id":"ciwuvvoef0006yira2jazxsy0","tag_id":"ciwfxj94o000p8mramf85b5i5","_id":"cix0jb97x00007mracb97ej17"},{"post_id":"cix6as84u0000vurane2noi8p","tag_id":"ciwfxj946000d8mra4nfk5643","_id":"cix6as85l0003vurao2mtkqua"},{"post_id":"cix6as84u0000vurane2noi8p","tag_id":"ciwfxj94h000j8mrae4ginnnx","_id":"cix6as85m0004vuraj6nbkrep"},{"post_id":"cix6as84u0000vurane2noi8p","tag_id":"cix6as85b0001vurape6294xy","_id":"cix6as85m0005vura6oxpnp4d"}],"Tag":[{"name":"记录","_id":"ciwfxj93n00068mraqx6rwvo4"},{"name":"抄抄抄","_id":"ciwfxj946000d8mra4nfk5643"},{"name":"JS 基础","_id":"ciwfxj94h000j8mrae4ginnnx"},{"name":"总结","_id":"ciwfxj94o000p8mramf85b5i5"},{"name":"操作","_id":"ciwfxj94v000w8mra803jlqel"},{"name":"CI","_id":"ciwfxj94y00108mraz477h1j3"},{"name":"开篇","_id":"ciwfxj955001b8mra6yc5k81v"},{"name":"DOM","_id":"ciwfxj957001e8mralzbjbf5v"},{"name":"Hexo","_id":"ciwfxj959001j8mra4jbfi629"},{"name":"CSS 布局","_id":"ciwkd216d0001k2rawylirpa7"},{"name":"margin","_id":"ciwkd216i0003k2ra5p5ldhx3"},{"name":"吵吵吵","_id":"ciwlk309q0002fpra0511zxrb"},{"name":"React","_id":"ciwlk309w0005fpra5ekqwl7g"},{"name":"BFC","_id":"ciwpvzd5e0004lcra19ek9ro2"},{"name":"存档","_id":"ciwpvzd5o0007lcra3n08o5lj"},{"name":"环境","_id":"ciwpvzd5q000alcra9zmkc45v"},{"name":"数组","_id":"ciwpwkc9l0001p4rag3cfmkn9"},{"name":"ES6","_id":"ciwqo03r10002lvrafmhtqz7u"},{"name":"promise","_id":"ciwqo03rq0006lvraid4g18xj"},{"name":"XMLHttpRequest","_id":"ciwum62mb0000yira4ki7birs"},{"name":"原型","_id":"ciwvivgog000fyirafb6n2240"},{"name":"prototype","_id":"ciwvivgoi000hyirasgz9sjim"},{"name":"lists","_id":"ciwvjf5ql000nyiranh4vxyhx"},{"name":"定时器","_id":"cix6as85b0001vurape6294xy"}]}}